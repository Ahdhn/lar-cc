% -------------------------------------------------------------------------
% ------ nuweb macros (redefine as desired, or omit with "nuweb -p") ------
% -------------------------------------------------------------------------
\providecommand{\NWtxtMacroDefBy}{Macro defined by}
\providecommand{\NWtxtMacroRefIn}{Macro referenced in}
\providecommand{\NWtxtMacroNoRef}{Macro never referenced}
\providecommand{\NWtxtDefBy}{Defined by}
\providecommand{\NWtxtRefIn}{Referenced in}
\providecommand{\NWtxtNoRef}{Not referenced}
\providecommand{\NWtxtFileDefBy}{File defined by}
\providecommand{\NWsep}{${\diamond}$}
\providecommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\providecommand{\NWtarget}[2]{% move baseline up by \baselineskip 
  \raisebox{\baselineskip}[1.5ex][0ex]{%
    \mbox{%
      \hypertarget{#1}{%
        \raisebox{-1\baselineskip}[0ex][0ex]{%
          \mbox{#2}%
}}}}}
% -------------------------------------------------------------------------

\documentclass[11pt,oneside]{article}	%use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}		%Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}		%...ora4paperora5paperor...
%\geometry{landscape}		%Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}		%Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}				%Usepdf,png,jpg,orepsßwithpdflatex;useepsinDVImode
								%TeXwillautomaticallyconverteps-->pdfinpdflatex		
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\usepackage[colorlinks]{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{The basic \texttt{larcc} module
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
\author{The LARCC team}
%\date{}							%Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\tableofcontents
\newpage


\section{Basic representations}

A few basic representation of topology are used in LARCC. They include some common sparse matrix representations: CSR (Compressed Sparse Row),  CSC (Compressed Sparse Column),   COO (Coordinate Representation), and BRC (Binary Row Compressed). 

\subsection{BRC (Binary Row Compressed)}

We denote as BRC (Binary Row Compressed) the standard input representation of our LARCC framework. A BRC representation is an array of arrays of integers, with no requirement of equal length for the component arrays. The BRC format is used to represent a (normally sparse) binary matrix. Each component array corresponds to a matrix row, and contains the indices of columns that store a 1 value. No storage is used for 0 values.

\paragraph{BRC format example}

Let $A = (a_{i,j} \in \{0,1\})$ be a binary matrix. The notation $\texttt{BRC}(A)$ is used for the corresponding data structure.
\[
A = \mat{
0,1,0,0,0,0,0,1,0,0\\
0,0,1,0,0,0,0,0,0,0\\
1,0,0,1,0,0,0,0,0,1\\
1,0,0,0,0,0,1,0,0,0\\
0,0,0,0,0,1,1,1,0,0\\
0,0,1,0,1,0,0,0,1,0\\
0,0,0,0,0,0,0,0,0,0\\
0,1,0,0,0,0,0,1,0,1\\
0,0,0,1,0,0,0,0,1,0\\
0,1,1,0,1,0,0,0,0,0\\
}
\qquad\mapsto\qquad \texttt{BRC}(A) =
\begin{minipage}[c]{5cm}
\begin{verbatim}
[[1,7],
 [2],
 [0,3,9],
 [0,6],
 [5,6,7],
 [2,4,8],
 [],
 [1,7,9],
 [3,8],
 [1,2,4]]
\end{verbatim}
\end{minipage}
\]


\subsection{Format conversions}

\paragraph{From triples to \texttt{scipy.sparse}}
The function \texttt{brc2Coo} transforms a \texttt{BRC} representation in a list of triples (\emph{row}, \emph{column}, 1) ordered by row.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap1}
\protect\makebox[0ex][r]{\NWtarget{nuweb2}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Brc to Coo transformation\nobreak\ {\footnotesize 2}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def brc2Coo(ListOfListOfInt):@\\
\mbox{}\verb@   COOm = [[k,col,1] for k,row in enumerate(ListOfListOfInt)@\\
\mbox{}\verb@         for col in row ]@\\
\mbox{}\verb@   return COOm@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

Two coordinate compressed sparse matrices \texttt{cooFV} and \texttt{cooEV} are created below, starting from the \texttt{BRC} representation \texttt{FV} and \texttt{EV} of the incidence of vertices on faces and edges, respectively, for a very simple plane triangulation.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap2}
\protect\makebox[0ex][r]{\NWtarget{nuweb3a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test example of Brc to Coo transformation\nobreak\ {\footnotesize 3a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> brc2Coo"@\\
\mbox{}\verb@V = [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]]@\\
\mbox{}\verb@FV = [[0, 1, 3], [1, 2, 4], [1, 3, 4], [2, 4, 5]]@\\
\mbox{}\verb@EV = [[0,1],[0,3],[1,2],[1,3],[1,4],[2,4],[2,5],[3,4],[4,5]]@\\
\mbox{}\verb@cooFV = brc2Coo(FV)@\\
\mbox{}\verb@cooEV = brc2Coo(EV)@\\
\mbox{}\verb@assert cooFV == [[0,0,1],[0,1,1],[0,3,1],[1,1,1],[1,2,1],[1,4,1],[2,1,1],@\\
\mbox{}\verb@[2,3,1], [2,4,1],[3,2,1],[3,4,1],[3,5,1]]@\\
\mbox{}\verb@assert cooEV == [[0,0,1],[0,1,1],[1,0,1],[1,3,1],[2,1,1],[2,2,1],[3,1,1],@\\
\mbox{}\verb@[3,3,1],[4,1,1],[4,4,1],[5,2,1],[5,4,1],[6,2,1],[6,5,1],[7,3,1],[7,4,1],@\\
\mbox{}\verb@[8,4,1],[8,5,1]]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Conversion to \texttt{csr} format}

Then we give the function \texttt{triples2mat} to make the transformation from the sparse matrix, given as a list of triples \emph{row,column,value} (non-zero elements), to the \texttt{scipy.sparse} format corresponding to the \texttt{shape} parameter, set by default to \texttt{"csr"}, that stands for \emph{Compressed Sparse Row}, the normal matrix format of the LARCC framework. 
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap3}
\protect\makebox[0ex][r]{\NWtarget{nuweb3b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$From list of triples to scipy.sparse\nobreak\ {\footnotesize 3b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def triples2mat(triples,shape="csr"):@\\
\mbox{}\verb@   n = len(triples)@\\
\mbox{}\verb@   data = arange(n)@\\
\mbox{}\verb@   ij = arange(2*n).reshape(2,n)@\\
\mbox{}\verb@   for k,item in enumerate(triples):@\\
\mbox{}\verb@      ij[0][k],ij[1][k],data[k] = item@\\
\mbox{}\verb@   return scipy.sparse.coo_matrix((data, ij)).asformat(shape)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
The conversion from triples to \texttt{csr} format is provided below.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap4}
\protect\makebox[0ex][r]{\NWtarget{nuweb3c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Coo to Csr transformation\nobreak\ {\footnotesize 3c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def coo2Csr(COOm):@\\
\mbox{}\verb@   CSRm = triples2mat(COOm,"csr")@\\
\mbox{}\verb@   return CSRm@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
Two CSR sparse matrices \texttt{csrFV} and \texttt{csrEV} are generated (by \emph{scipy.sparse})  in the following example:
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap5}
\protect\makebox[0ex][r]{\NWtarget{nuweb3d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test example of Coo to Csr transformation\nobreak\ {\footnotesize 3d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@csrFV = coo2Csr(cooFV)@\\
\mbox{}\verb@csrEV = coo2Csr(cooEV)@\\
\mbox{}\verb@print "\ncsr(FV) =\n", repr(csrFV)@\\
\mbox{}\verb@print "\ncsr(EV) =\n", repr(csrEV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
The \emph{scipy} printout of the last two lines above is the following:
%-------------------------------------------------------------------------------
{\small
\begin{verbatim}
csr(FV) = <4x6 sparse matrix of type '<type 'numpy.int64'>'
		   with 12 stored elements in Compressed Sparse Row format>
csr(EV) = <9x6 sparse matrix of type '<type 'numpy.int64'>'
		   with 18 stored elements in Compressed Sparse Row format>
\end{verbatim}}
%-------------------------------------------------------------------------------

\paragraph{Conversion from \texttt{BRC} to \texttt{CSR} format}
The transformation from BRC to CSR format is implemented slightly differently, according to the fact that the matrix dimension is either unknown (\texttt{shape=(0,0)}) or known.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap6}
\protect\makebox[0ex][r]{\NWtarget{nuweb4a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Brc to Csr transformation\nobreak\ {\footnotesize 4a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def csrCreate(BRCmatrix,lenV=0,shape=(0,0)):@\\
\mbox{}\verb@   triples = brc2Coo(BRCmatrix)@\\
\mbox{}\verb@   if shape == (0,0):@\\
\mbox{}\verb@      CSRmatrix = coo2Csr(triples)@\\
\mbox{}\verb@   else:@\\
\mbox{}\verb@      CSRmatrix = scipy.sparse.csr_matrix(shape)@\\
\mbox{}\verb@      for i,j,v in triples: CSRmatrix[i,j] = v@\\
\mbox{}\verb@   return CSRmatrix@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Example}
The conversion to CSR format of the characteristic matrix \emph{faces-vertices} \texttt{FV} is given below for our simple example made by four triangle of a manifold 2D space, graphically shown in Figure~\ref{fig:2D-non-manifold}a. The LAR representation with CSR matrices does not make difference between manifolds and non-manifolds, conversely than most modern solid modelling representation schemes, as shown by removing from \texttt{FV} the third triangle, giving the model in Figure~\ref{fig:2D-non-manifold}b.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap7}
\protect\makebox[0ex][r]{\NWtarget{nuweb4b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test example of Brc to Csr transformation\nobreak\ {\footnotesize 4b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> brc2Csr"@\\
\mbox{}\verb@V = [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]]@\\
\mbox{}\verb@FV = [[0, 1, 3], [1, 2, 4], [1, 3, 4], [2, 4, 5]]@\\
\mbox{}\verb@EV = [[0,1],[0,3],[1,2],[1,3],[1,4],[2,4],[2,5],[3,4],[4,5]]@\\
\mbox{}\verb@csrFV = csrCreate(FV)@\\
\mbox{}\verb@csrEV = csrCreate(EV)@\\
\mbox{}\verb@print "\ncsrCreate(FV) =\n", csrFV@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,FV))))@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,EV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb7}{7}\NWlink{nuweb35a}{, 35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.25\linewidth,width=0.25\linewidth]{images/larcc1a} 
   \includegraphics[height=0.25\linewidth,width=0.25\linewidth]{images/larcc1b} 
   \caption{(a) Simplicial 2-complex; (b) its 1-skeleton.}
   \label{fig:2D-non-manifold}
\end{figure}

\section{Matrix operations}

As we know, the LAR representation of topology is based on CSR representation of sparse binary (and integer) matrices. In this section we hence discuss the stack of matrix representations and operations implemented by this module.  The current python prototype makes reference to the scipy implementation of sparse matrices. Later implementations in different languages will necessarily make reference to different matrix packages.


\subsection{Basic operations}

Two utility functions allow to query the number of rows and columns of a CSR matrix, independently from the low-level implementation (that in the following is provided by \emph{scipy.sparse}).
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap8}
\protect\makebox[0ex][r]{\NWtarget{nuweb5a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Query Matrix shape\nobreak\ {\footnotesize 5a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def csrGetNumberOfRows(CSRmatrix):@\\
\mbox{}\verb@   Int = CSRmatrix.shape[0]@\\
\mbox{}\verb@   return Int@\\
\mbox{}\verb@   @\\
\mbox{}\verb@def csrGetNumberOfColumns(CSRmatrix):@\\
\mbox{}\verb@   Int = CSRmatrix.shape[1]@\\
\mbox{}\verb@   return Int@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap9}
\protect\makebox[0ex][r]{\NWtarget{nuweb5b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of Query Matrix shape\nobreak\ {\footnotesize 5b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> csrGetNumberOfRows"@\\
\mbox{}\verb@print "\ncsrGetNumberOfRows(csrFV) =", csrGetNumberOfRows(csrFV)@\\
\mbox{}\verb@print "\ncsrGetNumberOfRows(csrEV) =", csrGetNumberOfRows(csrEV)@\\
\mbox{}\verb@print "\n>>> csrGetNumberOfColumns"@\\
\mbox{}\verb@print "\ncsrGetNumberOfColumns(csrFV) =", csrGetNumberOfColumns(csrFV)@\\
\mbox{}\verb@print "\ncsrGetNumberOfColumns(csrEV) =", csrGetNumberOfColumns(csrEV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Sparse to dense matrix transformation}
The Scipy package provides the useful method \texttt{.todense()} in order to transform any sparse matrix format in the corresponding dense format. The function \texttt{csr2DenseMatrix} is given here for the sake of generality and portability.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap10}
\protect\makebox[0ex][r]{\NWtarget{nuweb6a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Sparse to dense matrix transformation\nobreak\ {\footnotesize 6a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def csr2DenseMatrix(CSRm):@\\
\mbox{}\verb@   nrows = csrGetNumberOfRows(CSRm)@\\
\mbox{}\verb@   ncolumns = csrGetNumberOfColumns(CSRm)@\\
\mbox{}\verb@   ScipyMat = zeros((nrows,ncolumns),int)@\\
\mbox{}\verb@   C = CSRm.tocoo()@\\
\mbox{}\verb@   for triple in zip(C.row,C.col,C.data):@\\
\mbox{}\verb@      ScipyMat[triple[0],triple[1]] = triple[2]@\\
\mbox{}\verb@   return ScipyMat@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap11}
\protect\makebox[0ex][r]{\NWtarget{nuweb6b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of Sparse to dense matrix transformation\nobreak\ {\footnotesize 6b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> csr2DenseMatrix"@\\
\mbox{}\verb@print "\nFV =\n", csr2DenseMatrix(csrFV)@\\
\mbox{}\verb@print "\nEV =\n", csr2DenseMatrix(csrEV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb7}{7}\NWlink{nuweb35a}{, 35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Matrix product and transposition}

The following macro provides the IDE interface for the two main matrix operations required by LARCC, the binary product of compatible matrices and the unary transposition of matrices.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap12}
\protect\makebox[0ex][r]{\NWtarget{nuweb6c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Matrix product and transposition\nobreak\ {\footnotesize 6c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def matrixProduct(CSRm1,CSRm2):@\\
\mbox{}\verb@   CSRm = CSRm1 * CSRm2@\\
\mbox{}\verb@   return CSRm@\\
\mbox{}\verb@@\\
\mbox{}\verb@def csrTranspose(CSRm):@\\
\mbox{}\verb@   CSRm = CSRm.T@\\
\mbox{}\verb@   return CSRm@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Characteristic matrices}

We define as \emph{characteristic matrices} $M_k$ ($0\leq k\leq d$) the binary matrices having as rows the images of the characteristic functions of the $k$-cells $\alpha_k\subset V$ of a cellular complex with vertices $V$.
Remember that characteristic (or \emph{indicator}) function is 
\[
\mathbf{1}_A\colon V \to \{0, 1\}, \qquad 
\]
which for a given subset $A$ of $X$, has value 1 at points of $A$ and 0 at points of $V - A$.
 
\paragraph{Example: from \texttt{BRC} to \texttt{CSR} to \texttt{dense} matrix} 
Let us compute and show in dense form the characteristic matrices of 2- and 1-cells of the simple manifold given in Figure~\ref{fig:2D-non-manifold}.
By running the file \texttt{test/py/larcc/test08.py} the reader will get the two matrices shown in Example~\ref{ex:denseMat}
%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap13}
\protect\makebox[0ex][r]{\NWtarget{nuweb7}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test08.py"@\nobreak\ {\footnotesize 7 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Characteristic matrices """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Brc to Csr transformation\nobreak\ {\footnotesize \NWlink{nuweb4b}{4b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of Sparse to dense matrix transformation\nobreak\ {\footnotesize \NWlink{nuweb6b}{6b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------
 
\begin{example}[Dense Characteristic matrices]\label{ex:denseMat}
Let us notice that the two matrices below have the some numbers of columns (indexed by vertices of the cell decomposition).
This very fact allows to multiply one matrix for the other transposed, and hence to compute the matrix form of linear operators between the spaces of cells of various dimensions.
\[
\texttt{FV} =
\begin{minipage}[c]{0.29\linewidth}
\begin{verbatim}
[[1 1 0 1 0 0]
 [0 1 1 0 1 0]
 [0 1 0 1 1 0]
 [0 0 1 0 1 1]]
\end{verbatim}
\end{minipage}
\qquad
\texttt{EV} =
\begin{minipage}[c]{0.29\linewidth}
\begin{verbatim}
[[1 1 0 0 0 0]
 [1 0 0 1 0 0]
 [0 1 1 0 0 0]
 [0 1 0 1 0 0]
 [0 1 0 0 1 0]
 [0 0 1 0 1 0]
 [0 0 1 0 0 1]
 [0 0 0 1 1 0]
 [0 0 0 0 1 1]]
\end{verbatim}
\end{minipage}
\]
\end{example}

\begin{example}[Operators from edges to faces and vice-versa]\label{ex:denseMat}
As a general rule for operators between two spaces of chains of different dimensions supported by the \emph{same} cellular complex, we use names made by two characters, whose first letter correspond to the target space, and whose second letter to the domain space. Hence \texttt{FE} must be read as the operator from edges to faces. Of course, since this use correspond to see the first letter as the space generated by rows, and the second letter as the space generated by columns. Notice that the element $(i,j)$ of such matrices stores the number of vertices shared between the (row-)cell $i$ and the (column-)cell $j$.
\[
\texttt{FE} = \texttt{FV}\ \texttt{EV}^\top = 
\begin{minipage}[c]{0.29\linewidth}
\begin{verbatim}
[[2 2 1 2 1 0 0 1 0]
 [1 0 2 1 2 2 1 1 1]
 [1 1 1 2 2 1 0 2 1]
 [0 0 1 0 1 2 2 1 2]]
\end{verbatim}
\end{minipage}
\qquad
\texttt{EF} = \texttt{EV}\ \texttt{FV}^\top = 
\begin{minipage}[c]{0.29\linewidth}
\begin{verbatim}
[[2 1 1 0]
 [2 0 1 0]
 [1 2 1 1]
 [2 1 2 0]
 [1 2 2 1]
 [0 2 1 2]
 [0 1 0 2]
 [1 1 2 1]
 [0 1 1 2]]
\end{verbatim}
\end{minipage}
\]
\end{example}

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.6\linewidth]{images/2complex} 
   \caption{example caption}
   \label{fig:2complex}
\end{figure}

\paragraph{Matrix elements filtering}

Some filtering operations on matrix elements are needed in the implementation of various topological operators. Some of such filtering operations are given below.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap14}
\protect\makebox[0ex][r]{\NWtarget{nuweb8}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Matrix filtering to produce the boundary matrix\nobreak\ {\footnotesize 8}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def csrBoundaryFilter(CSRm, facetLengths):@\\
\mbox{}\verb@   maxs = [max(CSRm[k].data) for k in range(CSRm.shape[0])]@\\
\mbox{}\verb@   inputShape = CSRm.shape@\\
\mbox{}\verb@   coo = CSRm.tocoo()@\\
\mbox{}\verb@   for k in range(len(coo.data)):@\\
\mbox{}\verb@      if coo.data[k]==maxs[coo.row[k]]: coo.data[k] = 1@\\
\mbox{}\verb@      else: coo.data[k] = 0@\\
\mbox{}\verb@   mtx = coo_matrix((coo.data, (coo.row, coo.col)), shape=inputShape)@\\
\mbox{}\verb@   out = mtx.tocsr()@\\
\mbox{}\verb@   return out@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap15}
\protect\makebox[0ex][r]{\NWtarget{nuweb9a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test example of Matrix filtering to produce the boundary matrix\nobreak\ {\footnotesize 9a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> csrBoundaryFilter"@\\
\mbox{}\verb@csrEF = matrixProduct(csrFV, csrTranspose(csrEV)).T@\\
\mbox{}\verb@facetLengths = [csrCell.getnnz() for csrCell in csrEV]@\\
\mbox{}\verb@CSRm = csrBoundaryFilter(csrEF, facetLengths).T@\\
\mbox{}\verb@print "\ncsrMaxFilter(csrFE) =\n", csr2DenseMatrix(CSRm)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap16}
\protect\makebox[0ex][r]{\NWtarget{nuweb9b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Matrix filtering via a generic predicate\nobreak\ {\footnotesize 9b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def csrPredFilter(CSRm, pred):@\\
\mbox{}\verb@   # can be done in parallel (by rows)@\\
\mbox{}\verb@   coo = CSRm.tocoo()@\\
\mbox{}\verb@   triples = [[row,col,val] for row,col,val @\\
\mbox{}\verb@            in zip(coo.row,coo.col,coo.data) if pred(val)]@\\
\mbox{}\verb@   i, j, data = TRANS(triples)@\\
\mbox{}\verb@   CSRm = scipy.sparse.coo_matrix((data,(i,j)),CSRm.shape).tocsr()@\\
\mbox{}\verb@   return CSRm@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap17}
\protect\makebox[0ex][r]{\NWtarget{nuweb9c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test example of Matrix filtering via a generic predicate\nobreak\ {\footnotesize 9c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@print "\n>>> csrPredFilter"@\\
\mbox{}\verb@CSRm = csrPredFilter(matrixProduct(csrFV, csrTranspose(csrEV)).T, GE(2)).T@\\
\mbox{}\verb@print "\nccsrPredFilter(csrFE) =\n", csr2DenseMatrix(CSRm)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\paragraph{Relational inversion (characteristic matrix transposition)}

The operation could be executed by simple matrix transposition of the CSR (Compressed Sparse Row) representation of the sparse characteristic matrix $M_d \equiv \texttt{CV}$.
A simple relational inversion using Python lists is given here. The \texttt{invertRelation} function 
is given here, linear in the size of the \texttt{CV} list, where the complexity of each cell is constant and 
small in most cases.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap18}
\protect\makebox[0ex][r]{\NWtarget{nuweb9d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Characteristic matrix transposition\nobreak\ {\footnotesize 9d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Characteristic matrix transposition """@\\
\mbox{}\verb@def invertRelation(CV):    @\\
\mbox{}\verb@    def myMax(List):@\\
\mbox{}\verb@        if List==[]:  return -1@\\
\mbox{}\verb@        else:  return max(List)@\\
\mbox{}\verb@            @\\
\mbox{}\verb@    columnNumber = max(AA(myMax)(CV))+1@\\
\mbox{}\verb@    VC = [[] for k in range(columnNumber)]@\\
\mbox{}\verb@    for k,cell in enumerate(CV):@\\
\mbox{}\verb@        for v in cell: VC[v] += [k]@\\
\mbox{}\verb@    return VC@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Computation of lower-dimensional skeletons}

In most cases, in particular when the cellular complex is made by convex cells, the only cells of maximal dimension must be entered to gain a complete knowledge of the whole complex.
Here we show how to compute the $(d-1)$-skeleton of a complex starting from its $d$-dimensional skeleton.

\paragraph{Extraction of facets of a cell complex} 

The following \texttt{larFacets} function returns the LAR model \texttt{V,cellFacets} starting from the input \texttt{model} parameter. Two optional parameters define the (intrinsic) dimension of the input cells, with default value equal to three, and the eventual presence of a \texttt{emptyCellNumber} of empty cells. Their number default to zero when the complex is closed, for example in the case it provides the $d$-boundary of a $(d+1)$-complex. If empty cells are present, their subset must be located at the end of the \texttt{cell} list.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap19}
\protect\makebox[0ex][r]{\NWtarget{nuweb10}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Extraction of facets of a cell complex\nobreak\ {\footnotesize 10}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def setup(model,dim):@\\
\mbox{}\verb@   V, cells = model@\\
\mbox{}\verb@   csr = csrCreate(cells)@\\
\mbox{}\verb@   csrAdjSquareMat = larCellAdjacencies(csr)@\\
\mbox{}\verb@   csrAdjSquareMat = csrPredFilter(csrAdjSquareMat, GE(dim)) # ? HOWTODO ?@\\
\mbox{}\verb@   return V,cells,csr,csrAdjSquareMat@\\
\mbox{}\verb@@\\
\mbox{}\verb@def larFacets(model, dim=3, emptyCellNumber=0):@\\
\mbox{}\verb@   """ Estraction of (d-1)-cellFacets from "model" := (V,d-cells)@\\
\mbox{}\verb@      Return (V, (d-1)-cellFacets)@\\
\mbox{}\verb@      """@\\
\mbox{}\verb@   V,cells,csr,csrAdjSquareMat = setup(model,dim)@\\
\mbox{}\verb@   solidCellNumber = len(cells) - emptyCellNumber@\\
\mbox{}\verb@   cellFacets = []@\\
\mbox{}\verb@   # for each input cell i@\\
\mbox{}\verb@   for i in range(len(cells)):@\\
\mbox{}\verb@      adjCells = csrAdjSquareMat[i].tocoo()@\\
\mbox{}\verb@      cell1 = csr[i].tocoo().col@\\
\mbox{}\verb@      pairs = zip(adjCells.col,adjCells.data)@\\
\mbox{}\verb@      for j,v in pairs:@\\
\mbox{}\verb@         if (i<j) and (i<solidCellNumber):@\\
\mbox{}\verb@            cell2 = csr[j].tocoo().col@\\
\mbox{}\verb@            cell = list(set(cell1).intersection(cell2))@\\
\mbox{}\verb@            cellFacets.append(sorted(cell))@\\
\mbox{}\verb@   # sort and remove duplicates@\\
\mbox{}\verb@   cellFacets = sorted(AA(list)(set(AA(tuple)(cellFacets))))@\\
\mbox{}\verb@   return V,cellFacets@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap20}
\protect\makebox[0ex][r]{\NWtarget{nuweb11a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computation of cell adjacencies\nobreak\ {\footnotesize 11a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larCellAdjacencies(CSRm):@\\
\mbox{}\verb@   CSRm = matrixProduct(CSRm,csrTranspose(CSRm))@\\
\mbox{}\verb@   return CSRm@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Examples}
Two simple complexes are defined below by providing the pair \texttt{V,FV}.
In both cases the \texttt{EV} relation is computed via the \texttt{larFacets} function.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap21}
\protect\makebox[0ex][r]{\NWtarget{nuweb11b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of Extraction of facets of a cell complex\nobreak\ {\footnotesize 11b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" A first (simplicial) example """@\\
\mbox{}\verb@V = [[0.,0.],[3.,0.],[0.,3.],[3.,3.],[1.,2.],[2.,2.],[1.,1.],[2.,1.]]@\\
\mbox{}\verb@FV = [[0,1,3],[1,2,4],[2,4,5],[3,4,6],[4,6,7],[5,7,8], # full@\\
\mbox{}\verb@   [1,3,4],[4,5,7], # empty@\\
\mbox{}\verb@   [0,1,2],[6,7,8],[0,3,6],[2,5,8]] # exterior     @\\
\mbox{}\verb@_,EV = larFacets((V,FV),dim=2)@\\
\mbox{}\verb@print "\nEV =",EV@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,EV))))@\\
\mbox{}\verb@@\\
\mbox{}\verb@""" Another (cuboidal) example """@\\
\mbox{}\verb@FV = [[0,1,6,7],[0,2,4,6],[4,5,6,7],[1,3,5,7],[2,3,4,5],[0,1,2,3]]@\\
\mbox{}\verb@_,EV = larFacets((V,FV),dim=2)@\\
\mbox{}\verb@print "\nEV =",EV@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,EV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Visualization of cell numbers}
The adjacentcy matrices between 2-cells and 1-cells are printed here. Finally, the complex is displayed by numbering with different colours and sizes (depending on the rank) the complex cells.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap22}
\protect\makebox[0ex][r]{\NWtarget{nuweb11c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of Computation of cell adjacencies\nobreak\ {\footnotesize 11c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@print "\n>>> larCellAdjacencies"@\\
\mbox{}\verb@adj_2_cells = larCellAdjacencies(csrCreate(FV))@\\
\mbox{}\verb@print "\nadj_2_cells =\n", csr2DenseMatrix(adj_2_cells)@\\
\mbox{}\verb@adj_1_cells = larCellAdjacencies(csrCreate(EV))@\\
\mbox{}\verb@print "\nadj_1_cells =\n", csr2DenseMatrix(adj_1_cells)@\\
\mbox{}\verb@@\\
\mbox{}\verb@submodel = mkSignedEdges((V,EV))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@VIEW(larModelNumbering(scalx=1,scaly=1,scalz=1)(V,[VV,EV,FV],submodel,2))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\section{Topological operations}

In this section we provide the matrix representation of operators to compute the more important and useful topological operations on cellular complexes, and/or the indexed relations they return. We start the section by giving a graphical tool used to test the developed software, concerning the graphical writing of the full set of indices of the cells of every dimension in a 3D cuboidal complex.  

\subsection{Visualization of cellular complexes}

It is often necessary to have a visual picture of the generated structures and computations.
This section provides some quite versatile visualisation tools of both the cells and/or their integer indices.

\paragraph{Visualization of cell indices}
As already outlined, the \texttt{modelIndexing} function return the \emph{hpc} value assembling both the 1-skeletons of the cells of every dimensions, and the graphical output of their indices, located on the centroid of each cell, and displayed using colors and sizes depending on the \emph{rank} of the cell.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap23}
\protect\makebox[0ex][r]{\NWtarget{nuweb12}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Visualization of cell indices\nobreak\ {\footnotesize 12}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Visualization of cell indices """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@def modelIndexing(shape):@\\
\mbox{}\verb@   V, bases = larCuboids(shape,True)@\\
\mbox{}\verb@   # bases = [[cell for cell in cellComplex if len(cell)==2**k] for k in range(4)]@\\
\mbox{}\verb@   color = [ORANGE,CYAN,GREEN,WHITE]@\\
\mbox{}\verb@   nums = AA(range)(AA(len)(bases))@\\
\mbox{}\verb@   hpcs = []@\\
\mbox{}\verb@   for k in range(4):@\\
\mbox{}\verb@      hpcs += [SKEL_1(STRUCT(MKPOLS((V,bases[k]))))]@\\
\mbox{}\verb@      hpcs += [cellNumbering((V,bases[k]),hpcs[2*k])(nums[k],color[k],0.3+0.2*k)]@\\
\mbox{}\verb@   return STRUCT(hpcs)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb12}{12}\NWlink{nuweb13a}{, 13a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap24}
\protect\makebox[0ex][r]{\NWtarget{nuweb13a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Visualization of cell indices\nobreak\ {\footnotesize 13a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Numbered visualization of a LAR model """@\\
\mbox{}\verb@def larModelNumbering(scalx=1,scaly=1,scalz=1):@\\
\mbox{}\verb@   def  larModelNumbering0(V,bases,submodel,numberScaling=1):@\\
\mbox{}\verb@      color = [ORANGE,CYAN,GREEN,WHITE]@\\
\mbox{}\verb@      nums = AA(range)(AA(len)(bases))@\\
\mbox{}\verb@      hpcs = [submodel]@\\
\mbox{}\verb@      for k in range(len(bases)):@\\
\mbox{}\verb@         hpcs += [cellNumbering((V,bases[k]),submodel)@\\
\mbox{}\verb@                  (nums[k],color[k],(0.5+0.1*k)*numberScaling)]@\\
\mbox{}\verb@      return STRUCT(hpcs)@\\
\mbox{}\verb@      #return EXPLODE(scalx,scaly,scalz)(hpcs)@\\
\mbox{}\verb@   return larModelNumbering0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb12}{12}\NWlink{nuweb13a}{, 13a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\paragraph{Drawing of oriented edges}
The following function return the \texttt{hpc} of the drawing with arrows of the oriented 1-cells of a 2D cellular complex. Of course, each edge orientation is from second to first vertex, independently from the vertex indices. Therefore, the edge orientation can be reversed by swapping the vertex indices in the 1-cell definition. 
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap25}
\protect\makebox[0ex][r]{\NWtarget{nuweb13b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Drawing of oriented edges\nobreak\ {\footnotesize 13b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Drawing of oriented edges (2D) """@\\
\mbox{}\verb@def mkSignedEdges (model,scalingFactor=1):@\\
\mbox{}\verb@   V,EV = model@\\
\mbox{}\verb@   assert len(V[0])==2@\\
\mbox{}\verb@   hpcs = []@\\
\mbox{}\verb@   times = C(SCALARVECTPROD)@\\
\mbox{}\verb@   frac = 0.06*scalingFactor@\\
\mbox{}\verb@   for e0,e1 in EV:@\\
\mbox{}\verb@      v0,v1 = V[e0], V[e1]@\\
\mbox{}\verb@      vx,vy = DIFF([ v1, v0 ])@\\
\mbox{}\verb@      nx,ny = [-vy, vx]@\\
\mbox{}\verb@      v2 = SUM([ v0, times(0.66)([vx,vy]) ])@\\
\mbox{}\verb@      v3 = SUM([ v0, times(0.6-frac)([vx,vy]), times(frac)([nx,ny]) ])@\\
\mbox{}\verb@      v4 = SUM([ v0, times(0.6-frac)([vx,vy]), times(-frac)([nx,ny]) ])@\\
\mbox{}\verb@      verts,cells = [v0,v1,v2,v3,v4],[[1,2],[3,4],[3,5]]@\\
\mbox{}\verb@      hpcs += [MKPOL([verts,cells,None])]@\\
\mbox{}\verb@   hpc = STRUCT(hpcs)@\\
\mbox{}\verb@   return hpc@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Example of oriented edge drawing}
An example of drawing of oriented edges is given in \texttt{test/py/larcc/test11.py} file, and in Figure~\ref{numberedcomplex}, showing both the numbering of the cells and the arrows indicating the edge orientation is illustrated in Figure~\ref{numberedcomplex}, where also the oriented boundary is shown.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.9\linewidth]{images/numberedcomplex} 
   
   \includegraphics[width=0.9\linewidth]{images/numberedcomplex1} 
   \caption{Example of numbered polytopal complex, including edge orientations, and its oriented boundary.}
   \label{numberedcomplex}
\end{figure}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap26}
\protect\makebox[0ex][r]{\NWtarget{nuweb14a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test11.py"@\nobreak\ {\footnotesize 14a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Example of oriented edge drawing\nobreak\ {\footnotesize \NWlink{nuweb14b}{14b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap27}
\protect\makebox[0ex][r]{\NWtarget{nuweb14b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Example of oriented edge drawing\nobreak\ {\footnotesize 14b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of oriented edge drawing """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@V = [[9,0],[13,2],[15,4],[17,8],[14,9],[13,10],[11,11],[9,10],[7,9],[5,9],[3,@\\
\mbox{}\verb@8],[0,6],[2,3],[2,1],[5,0],[7,1],[4,2],[12,10],[6,3],[8,3],[3,5],[5,5],[7,6],@\\
\mbox{}\verb@[8,5],[10,5],[11,4],[10,2],[13,4],[14,6],[13,7],[11,9],[9,7],[7,7],[4,7],[2,@\\
\mbox{}\verb@6],[12,7],[12,5]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@FV = [[0,1,26],[5,6,17],[6,7,17,30],[7,30,31],[7,8,31,32],[24,30,31,35],[3,4,@\\
\mbox{}\verb@28],[4,5,17,29,30,35],[4,28,29],[28,29,35,36],[8,9,32,33],[9,10,33],[11,10,@\\
\mbox{}\verb@33,34],[11,20,34],[20,33,34],[20,21,32,33],[18,21,22],[21,22,32],[22,23,31,@\\
\mbox{}\verb@32],[23,24,31],[11,12,20],[12,16,18,20,21],[18,22,23],[18,19,23],[19,23,24],@\\
\mbox{}\verb@[15,19,24,26],[0,15,26],[24,25,26],[24,25,35,36],[2,3,28],[1,2,27,28],[12,13,@\\
\mbox{}\verb@16],[13,14,16],[14,15,16,18,19],[1,25,26,27],[25,27,36],[36,27,28]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV))))@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@_,EV = larFacets((V,FV+[range(16)]),dim=2,emptyCellNumber=1)@\\
\mbox{}\verb@@\\
\mbox{}\verb@submodel = mkSignedEdges((V,EV))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@VIEW(larModelNumbering(scalx=1,scaly=1,scalz=1)(V,[VV,EV,FV],submodel,2))@\\
\mbox{}\verb@@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,[VV,EV,FV])@\\
\mbox{}\verb@cells = [EV[e] if sign==1 else REVERSE(EV[e]) for (sign,e) in zip(*orientedBoundary)]@\\
\mbox{}\verb@submodel = mkSignedEdges((V,cells))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb14a}{14a}\NWlink{nuweb16}{, 16}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Extracting the boundary of whichever chain}

The boundary of whichever chain, here defined as the list of indices of its cells, then transformed to its coordinate representation (column vector in the given basis), is explicitly computed by matrix product times the matrix of the boundary operator in the given basis, transformed back in its BRC representation, and displayed as  LAR model.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap28}
\protect\makebox[0ex][r]{\NWtarget{nuweb16}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test19.py"@\nobreak\ {\footnotesize 16 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of oriented edge drawing """@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Example of oriented edge drawing\nobreak\ {\footnotesize \NWlink{nuweb14b}{14b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@C2 = csr_matrix((len(FV),1))@\\
\mbox{}\verb@for i in [1,2, 12,13,14,15, 22,23, 29,30,31]: C2[i,0] = 1@\\
\mbox{}\verb@BD = boundary(FV,EV)@\\
\mbox{}\verb@C1 = BD * C2@\\
\mbox{}\verb@C_1 = [i for i in range(len(EV)) if ABS(C1[i,0]) == 1 ]@\\
\mbox{}\verb@C_2 = [i for i in range(len(FV)) if C2[i,0] == 1 ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,[EV[k] for k in C_1] + [FV[k] for k in C_2]))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------




\subsection{Incidence and adjacency operators}

Let us start by computing the more interesting subset of the binary relationships between the 4 decompositive and/or boundary entities of 3D cellular models.  Therefore, in this case we denote with \texttt{C}, \texttt{F}, \texttt{E}, and \texttt{V}, the 3-cells and their faces, edges and vertices, respectively.
The input is the full-fledged LAR representation provided by 
\begin{align}
\texttt{CV} := \texttt{CSR}(M_3) \\
\texttt{FV} := \texttt{CSR}(M_2) \\
\texttt{EV} := \texttt{CSR}(M_1) \\
\texttt{VV} := \texttt{CSR}(M_0) 
\end{align}

Of course, $\texttt{CSR}(M_0)$ coincides with the identity matrix of dimension $|V|$ and can by excluded by further considerations.
Some binary incidence and adjacency relations we are going to compute are:
\begin{align}
\texttt{CF} := \texttt{CV} \times \texttt{FV}^t = \texttt{CSR}(M_3)\times\texttt{CSR}(M_2)^t \\
\texttt{CE} := \texttt{CV} \times \texttt{EV}^t = \texttt{CSR}(M_3)\times\texttt{CSR}(M_1)^t \\
\texttt{FE} := \texttt{FV} \times \texttt{EV}^t = \texttt{CSR}(M_2)\times\texttt{CSR}(M_1)^t 
\end{align}

The other possible operators follow from a similer computational pattern.

\paragraph{The programming pattern for incidence computation}

A high-level function \texttt{larIncidence} useful to compute the LAR representation of the incidence matrix (operator) and the incidence relations is given in the script below.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap29}
\protect\makebox[0ex][r]{\NWtarget{nuweb17a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Some incidence operators\nobreak\ {\footnotesize 17a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Some incidence operators """@\\
\mbox{}\verb@def larIncidence(cells,facets):@\\
\mbox{}\verb@   csrCellFacet = csrCellFaceIncidence(cells,facets)@\\
\mbox{}\verb@   cooCellFacet = csrCellFacet.tocoo()@\\
\mbox{}\verb@   larCellFacet = [[] for cell in range(len(cells))]@\\
\mbox{}\verb@   for i,j,val in zip(cooCellFacet.row,cooCellFacet.col,cooCellFacet.data):@\\
\mbox{}\verb@      if val == 1: larCellFacet[i] += [j]@\\
\mbox{}\verb@   return larCellFacet@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Cell-Face incidence operator\nobreak\ {\footnotesize \NWlink{nuweb17b}{17b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Cell-Edge incidence operator\nobreak\ {\footnotesize \NWlink{nuweb17c}{17c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Face-Edge incidence operator\nobreak\ {\footnotesize \NWlink{nuweb18a}{18a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Cell-Face incidence}
The \texttt{csrCellFaceIncidence} and \texttt{larCellFace} functions are given below, and exported to the \texttt{larcc} module.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap30}
\protect\makebox[0ex][r]{\NWtarget{nuweb17b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Cell-Face incidence operator\nobreak\ {\footnotesize 17b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Cell-Face incidence operator """@\\
\mbox{}\verb@def csrCellFaceIncidence(CV,FV):@\\
\mbox{}\verb@   return boundary(FV,CV)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def larCellFace(CV,FV):@\\
\mbox{}\verb@   return larIncidence(CV,FV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb17a}{17a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Cell-Edge incidence}
Analogously, the \texttt{csrCellEdgeIncidence} and \texttt{larCellFace} functions are given in the following script.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap31}
\protect\makebox[0ex][r]{\NWtarget{nuweb17c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Cell-Edge incidence operator\nobreak\ {\footnotesize 17c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Cell-Edge incidence operator """@\\
\mbox{}\verb@def csrCellEdgeIncidence(CV,EV):@\\
\mbox{}\verb@    return boundary(EV,CV)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def larCellEdge(CV,EV):@\\
\mbox{}\verb@   return larIncidence(CV,EV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb17a}{17a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Face-Edge incidence}
Finally, the \texttt{csrCellEdgeIncidence} and \texttt{larCellFace} functions are provided below.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap32}
\protect\makebox[0ex][r]{\NWtarget{nuweb18a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Face-Edge incidence operator\nobreak\ {\footnotesize 18a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Face-Edge incidence operator """@\\
\mbox{}\verb@def csrFaceEdgeIncidence(FV,EV):@\\
\mbox{}\verb@   return boundary(EV,FV)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def larFaceEdge(FV,EV):@\\
\mbox{}\verb@   return larIncidence(FV,EV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb17a}{17a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Example}
The example below concerns a 3D cuboidal grid, by computing a full LAR stack of bases
\texttt{CV, FV, EV, VV}, showing its fully numbered 3D model, and finally by computing
some more useful binary relationships (\texttt{CF, CE, FE}), needed for example to compute the signed matrices of boundary operators.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap33}
\protect\makebox[0ex][r]{\NWtarget{nuweb18b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test10.py"@\nobreak\ {\footnotesize 18b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" A mesh model and various incidence operators """@\\
\mbox{}\verb@@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@shape = [2,2,2]@\\
\mbox{}\verb@V,(VV,EV,FV,CV) = larCuboids(shape,True)@\\
\mbox{}\verb@VIEW(modelIndexing(shape))@\\
\mbox{}\verb@@\\
\mbox{}\verb@CF = larCellFace(CV,FV)@\\
\mbox{}\verb@CE = larCellFace(CV,EV)@\\
\mbox{}\verb@FE = larCellFace(FV,EV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsubsection{Incidence chain}

Let denote with \texttt{CF}, \texttt{FE}, \texttt{EV} the three consecutive incidence relations between $k$-cells and $(k-1)$-cells ($3\leq k\leq 0$) in a 3-complex. In the general multidimensional case, let us call \texttt{CF}$_d$  the generic \emph{binary} incidence operator, between $d$-cells and $(d-1)$-facets, as:
\[
\texttt{CF}_d = M_{d-1} M_d^t, 
\]
with
\[
\texttt{CF}_d := \{a_{ij}\}, \qquad a_{ij} = 
\left\{
\begin{array}{cl}
1 & \mbox{if\ } M_{d-1}(i) M_d(j) = |f_j|  \\
0 & \mbox{otherwise}  \\  
\end{array}
\right.
\]

\paragraph{Incidence chain computation}
The function \texttt{incidenceChain}, given below, returns the full stack of \texttt{BRC} incidence matrices of a LAR representation for a cellular complex, starting from its list of bases, i.e.~from \texttt{[VV,EV,FV,CV,...]}. Notice that the function returns the inverse sequence 
\texttt{[EV,FE,CF,...]}, i.e., \texttt{CF}$_k$ ($1\leq k\leq d$).

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap34}
\protect\makebox[0ex][r]{\NWtarget{nuweb19a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Incidence chain computation\nobreak\ {\footnotesize 19a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Incidence chain computation """@\\
\mbox{}\verb@def incidenceChain(bases):@\\
\mbox{}\verb@   #print "\n len(bases) = ",len(bases),"\n"@\\
\mbox{}\verb@   pairsOfBases = zip(bases[1:],bases[:-1])@\\
\mbox{}\verb@   relations = [larIncidence(cells,facets) @\\
\mbox{}\verb@               for cells,facets in pairsOfBases]@\\
\mbox{}\verb@   return REVERSE(relations)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap35}
\protect\makebox[0ex][r]{\NWtarget{nuweb19b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test13.py"@\nobreak\ {\footnotesize 19b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of incidence chain computation """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@shape = (1,1,2) @\\
\mbox{}\verb@print "\n\nFor a better example provide a greater shape!"@\\
\mbox{}\verb@V,bases = larCuboids(shape,True)@\\
\mbox{}\verb@@\\
\mbox{}\verb@VV,EV,FV,CV = bases@\\
\mbox{}\verb@incidence = incidenceChain([VV,EV,FV,CV])@\\
\mbox{}\verb@relations = ["CF","FE","EV"]@\\
\mbox{}\verb@for k in range(3):@\\
\mbox{}\verb@   print "\n\n incidence", relations[k], "=\n", incidence[k],@\\
\mbox{}\verb@print "\n\n"@\\
\mbox{}\verb@@\\
\mbox{}\verb@submodel = SKEL_1(STRUCT(MKPOLS((V,EV))))@\\
\mbox{}\verb@VIEW(larModelNumbering(scalx=1,scaly=1,scalz=1)(V,[VV,EV,FV,CV],submodel,1))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Example of incidence chain computation}
When running the \texttt{test/py/larcc/test13.py} file one obtains the following printout. 
Notice that 
it provides the links between $d$-cell numerations and the numerations of their faces.
See Figure~\ref{incidenceChain} for this purpose.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.5\linewidth]{images/incidenceChain} 
   \caption{Che stack of incidence relations gives the common links between cell numerations.}
   \label{incidenceChain}
\end{figure}


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap36}
\protect\makebox[0ex][r]{\NWtarget{nuweb19c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Incidence chain for a 3D cuboidal complex\nobreak\ {\footnotesize 19c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@incidence CF = [[0,2,4,6,8,9],[1,3,5,7,9,10]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@incidence FE = [[0,2,8,9],[1,3,9,10],[4,6,11,12],[5,7,12,13],[0,4,14,15],@\\
\mbox{}\verb@[1,5,15,16],[2,6,17,18],[3,7,18,19],[8,11,14,17],[9,12,15,18],[10,13,16,19]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@incidence EV = [[0,1],[1,2],[3,4],[4,5],[6,7],[7,8],[9,10],[10,11],[0,3],@\\
\mbox{}\verb@[1,4],[2,5],[6,9],[7,10],[8,11],[0,6],[1,7],[2,8],[3,9],[4,10],[5,11]]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\subsection{Boundary and coboundary operators}

When computing the matrices of boundary and coboundary operators it may be useful to distinguish between simplicial complexes and general polytopal complexes, including  cuboidal ones. In the first cases all skeletons, and hence the other topological operators, may be computed using only combinatorial methods. In the second case some reference to their geometric embedding must be done, at least to compute the \emph{oriented} boundary and coboundary. Therefore we separate the two cases in the following sections.


\subsubsection{Non-oriented operators}

The \texttt{boundary} function below takes as parameters the \texttt{BRC} representations of $d$-cells and $(d-1)$-facets, and returns the \texttt{CSR} matrix of the boundary operator. Let us notice that such operator uses a mod 2 algebra, since it takes elements within the field $\Z_2=\{0,1\}$.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap37}
\protect\makebox[0ex][r]{\NWtarget{nuweb20}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of From cells and facets to boundary operator\nobreak\ {\footnotesize 20}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@V = [[0.0,0.0,0.0],[1.0,0.0,0.0],[0.0,1.0,0.0],[1.0,1.0,0.0],@\\
\mbox{}\verb@      [0.0,0.0,1.0],[1.0,0.0,1.0],[0.0,1.0,1.0],[1.0,1.0,1.0]]@\\
\mbox{}\verb@CV = [[0,1,2,4],[1,2,4,5],[2,4,5,6],[1,2,3,5],[2,3,5,6],[3,5,6,7]]@\\
\mbox{}\verb@FV = [[0,1,2],[0,1,4],[0,2,4],[1,2,3],[1,2,4],[1,2,5],[1,3,5],[1,4,5],[2,3,5],@\\
\mbox{}\verb@     [2,3,6],[2,4,5],[2,4,6],[2,5,6],[3,5,6],[3,5,7],[3,6,7],[4,5,6],[5,6,7]]@\\
\mbox{}\verb@EV = [[0,1],[0,2],[0,4],[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],@\\
\mbox{}\verb@     [2,6],[3,5],[3,6],[3,7],[4,5],[4,6],[5,6],[5,7],[6,7]]@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@@\\
\mbox{}\verb@print "\ncoboundary_2 =\n", csr2DenseMatrix(coboundary(CV,FV))@\\
\mbox{}\verb@print "\ncoboundary_1 =\n", csr2DenseMatrix(coboundary(FV,EV))@\\
\mbox{}\verb@print "\ncoboundary_0 =\n", csr2DenseMatrix(coboundary(EV,VV))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

In the script below it is necessary to guarantee that both \texttt{csrFV} and \texttt{csrCV} are created with the same number of column. The initial steps have this purpose.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap38}
\protect\makebox[0ex][r]{\NWtarget{nuweb21a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$From cells and facets to boundary operator\nobreak\ {\footnotesize 21a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def boundary(cells,facets):@\\
\mbox{}\verb@   lenV = max(max(cells),max(facets))@\\
\mbox{}\verb@   csrCV = csrCreate(cells,lenV)@\\
\mbox{}\verb@   csrFV = csrCreate(facets,lenV)@\\
\mbox{}\verb@   csrFC = matrixProduct(csrFV, csrTranspose(csrCV))@\\
\mbox{}\verb@   facetLengths = [csrCell.getnnz() for csrCell in csrCV]@\\
\mbox{}\verb@   return csrBoundaryFilter(csrFC,facetLengths)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def coboundary(cells,facets):@\\
\mbox{}\verb@   Boundary = boundary(cells,facets)@\\
\mbox{}\verb@   return csrTranspose(Boundary)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap39}
\protect\makebox[0ex][r]{\NWtarget{nuweb21b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$From cells and facets to boundary cells\nobreak\ {\footnotesize 21b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def totalChain(cells):@\\
\mbox{}\verb@   return csrCreate([[0] for cell in cells])  # ????  zero ??@\\
\mbox{}\verb@@\\
\mbox{}\verb@def boundaryCells(cells,facets):@\\
\mbox{}\verb@   csrBoundaryMat = boundary(cells,facets)@\\
\mbox{}\verb@   csrChain = totalChain(cells)@\\
\mbox{}\verb@   csrBoundaryChain = matrixProduct(csrBoundaryMat, csrChain)@\\
\mbox{}\verb@   for k,value in enumerate(csrBoundaryChain.data):@\\
\mbox{}\verb@      if value % 2 == 0: csrBoundaryChain.data[k] = 0@\\
\mbox{}\verb@   out = [k for k,val in enumerate(csrBoundaryChain.data.tolist()) if val == 1]@\\
\mbox{}\verb@   return out@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap40}
\protect\makebox[0ex][r]{\NWtarget{nuweb21c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples of From cells and facets to boundary cells\nobreak\ {\footnotesize 21c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@boundaryCells_2 = boundaryCells(CV,FV)@\\
\mbox{}\verb@boundaryCells_1 = boundaryCells([FV[k] for k in boundaryCells_2],EV)@\\
\mbox{}\verb@@\\
\mbox{}\verb@print "\nboundaryCells_2 =\n", boundaryCells_2@\\
\mbox{}\verb@print "\nboundaryCells_1 =\n", boundaryCells_1@\\
\mbox{}\verb@@\\
\mbox{}\verb@boundaryModel = (V,[FV[k] for k in boundaryCells_2])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(boundaryModel)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb35a}{35a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\subsubsection{Oriented operators}

Two $d$-cells are said \emph{coherently oriented} when their common $(d-1)$-facet has opposite orientations with respect to the two cells. When the boundary of an orientable solid partitionates its affine hull in two subsets corresponding to the \emph{interior} and the \emph{exterior} of the solid, then the boundary cells can be coherently oriented. This task is performed by the function \texttt{signedBoundaryCells} and \texttt{signedCellularBoundaryCells} in the following scripts.
The sparse matricial structures returned by the functions \texttt{signedSimplicialBoundary} and \texttt{signedCellularBoundary} take values in the Abelian group $\{-1,0,1\}$. We call them \emph{signed} matrices, and call \emph{signed} operators the corresponding boundary and coboundary.


\paragraph{Signed boundary matrix for simplicial complexes}

The computation of the \emph{signed} boundary matrix for simplicial complexes starts with enumerating the non-zero elements of the mod two (unoriented) boundary matrix. In particular, the \texttt{pairs} variable contains all the pairs of incident ($(d-1)$-cell, $d$-cell), corresponding to each 1 elements in the binary boundary matrix. Of course, their number equates the product of the number of $d$-cells, times the number of $(d-1)$-facets on the boundary of each $d$-cell. 

For the case of a 3-simplicial complex \texttt{CV}, we have $4|\texttt{CV}|$ \texttt{pairs} elements.  The actual goal of the function \texttt{signedSimplicialBoundary}, in the macro below, is to compute a sign for each of them.

The \texttt{pairs} values must be interpreted as $(i,j)$ values in the incidence matrix \texttt{FC} (\emph{facets}-\emph{cells}), and hence as pairs of indices $f$ and $c$ into the characteristic matrices $\texttt{FV}=\texttt{CSR}(M_{d-1})$ and $\texttt{CV}=\texttt{CSR}(M_{d})$, respectively.

For each incidence pair \texttt{f,c}, the list \texttt{vertLists}  contains the two lists of vertices associated to \texttt{f} and to \texttt{c}, called respectively the \texttt{face} and the \texttt{coface}. For each \texttt{face, coface} pair (i.e.~for each unit element in the unordered boundary matrix), the \texttt{missingVertIndices} list will contain the index of the \texttt{coface} vertex not contained in the incident \texttt{face}. 

Finally, the $\pm 1$ (signed) incidence coefficients are computed and stored in the \texttt{faceSigns}, and then located in their actual positions within the \texttt{csrSignedBoundaryMat}. The sign of the incidence coefficient associated to the pair (facet,cell), also called (face,coface) in the implementation below, is computed as the sign of $(-1)^k$, where $k$ is the position index of the removed vertex in the facet $\langle v_0, \ldots, v_{k-1}, v_{k+1}, \ldots, v_d \rangle$. of the $\langle v_0, \ldots, v_d \rangle$ cell.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap41}
\protect\makebox[0ex][r]{\NWtarget{nuweb23a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Signed boundary matrix for simplicial models\nobreak\ {\footnotesize 23a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def signedSimplicialBoundary (CV,FV):@\\
\mbox{}\verb@   # compute the set of pairs of indices to [boundary face,incident coface]@\\
\mbox{}\verb@   coo = boundary(CV,FV).tocoo()@\\
\mbox{}\verb@   pairs = [[coo.row[k],coo.col[k]] for k,val in enumerate(coo.data) if val != 0]@\\
\mbox{}\verb@@\\
\mbox{}\verb@   # compute the [face, coface] pair as vertex lists@\\
\mbox{}\verb@   vertLists = [[FV[f], CV[c]] for f,c in pairs]@\\
\mbox{}\verb@@\\
\mbox{}\verb@   # compute the local (interior to the coface) indices of missing vertices @\\
\mbox{}\verb@   def missingVert(face,coface): return list(set(coface).difference(face))[0]@\\
\mbox{}\verb@   missingVertIndices = [c.index(missingVert(f,c)) for f,c in vertLists]@\\
\mbox{}\verb@@\\
\mbox{}\verb@   # signed incidence coefficients@\\
\mbox{}\verb@   faceSigns = AA(C(POWER)(-1))(missingVertIndices)@\\
\mbox{}\verb@@\\
\mbox{}\verb@   # signed boundary matrix@\\
\mbox{}\verb@   csrSignedBoundaryMat = csr_matrix( (faceSigns, TRANS(pairs)) )@\\
\mbox{}\verb@   return csrSignedBoundaryMat@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Computation of signed boundary simplices}

The matrix of the signed boundary operator, with elements in $\{-1,0,1\}$, is computed in compressed sparse row (CSR) format, and stored in \texttt{csrSignedBoundaryMat}. In order to be able to return a list of \texttt{signedBoundaryCells} having a coherent orientation, we need to compute the coface of each boundary facet, i.e.~the single $d$-cell having the facet on its boundary, and provide a coherent orientation to such chain of $d$-cells. The goal is obtained computing the sign of the determinant of the coface matrices, i.e.~of square matrices having as rows the vertices of a coface, in normalised homogeneous coordinates.

The chain of boundary facets \texttt{boundaryCells}, obtained by multiplying the signed matrix of the boundary operator by the coordinate representation of the total $d$-chain, is coherently oriented by multiplication times the determinants of the \texttt{cofaceMats}.

The \texttt{cofaceMats} list is filled 
with the matrices having per row the position vectors of vertices of a coface, in normalized 
homogeneous coordinates. The list of signed face indices \texttt{orientedBoundaryCells} is returned by the function.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap42}
\protect\makebox[0ex][r]{\NWtarget{nuweb23b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Orientation of general convex cells\nobreak\ {\footnotesize 23b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def swap(mylist): return [mylist[1]]+[mylist[0]]+mylist[2:]@\\
\mbox{}\verb@@\\
\mbox{}\verb@def boundaryCellsCocells(cells,facets):@\\
\mbox{}\verb@   csrSignedBoundaryMat = signedSimplicialBoundary(cells,facets)@\\
\mbox{}\verb@   csrTotalChain = totalChain(cells)@\\
\mbox{}\verb@   csrBoundaryChain = matrixProduct(csrSignedBoundaryMat, csrTotalChain)@\\
\mbox{}\verb@   cooCells = csrBoundaryChain.tocoo() @\\
\mbox{}\verb@   boundaryCells = []@\\
\mbox{}\verb@   for k,v in enumerate(cooCells.data):@\\
\mbox{}\verb@      if abs(v) == 1:@\\
\mbox{}\verb@         boundaryCells += [int(cooCells.row[k] * cooCells.data[k])]        @\\
\mbox{}\verb@   boundaryCocells = []@\\
\mbox{}\verb@   for k,v in enumerate(boundaryCells):@\\
\mbox{}\verb@      boundaryCocells += list(csrSignedBoundaryMat[abs(v)].tocoo().col)    @\\
\mbox{}\verb@   return boundaryCells,boundaryCocells@\\
\mbox{}\verb@@\\
\mbox{}\verb@def signedBoundaryCells(verts,cells,facets):@\\
\mbox{}\verb@   boundaryCells,boundaryCocells = boundaryCellsCocells(cells,facets)      @\\
\mbox{}\verb@   boundaryCofaceMats = [[verts[v]+[1] for v in cells[c]] for c in boundaryCocells]@\\
\mbox{}\verb@   boundaryCofaceSigns = AA(SIGN)(AA(np.linalg.det)(boundaryCofaceMats))@\\
\mbox{}\verb@   orientedBoundaryCells = list(array(boundaryCells)*array(boundaryCofaceSigns))@\\
\mbox{}\verb@   @\\
\mbox{}\verb@   return orientedBoundaryCells@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Signed boundary matrix for polytopal complexes}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap43}
\protect\makebox[0ex][r]{\NWtarget{nuweb24}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Signed boundary matrix for polytopal complexes\nobreak\ {\footnotesize 24}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Signed boundary matrix for polytopal complexes """@\\
\mbox{}\verb@def signedCellularBoundary(V,bases):@\\
\mbox{}\verb@   coo = boundary(bases[-1],bases[-2]).tocoo()@\\
\mbox{}\verb@   pairs = [[coo.row[k],coo.col[k]] for k,val in enumerate(coo.data) if val != 0]@\\
\mbox{}\verb@   signs = []@\\
\mbox{}\verb@   dim = len(bases)-1@\\
\mbox{}\verb@   chain = incidenceChain(bases)@\\
\mbox{}\verb@   @\\
\mbox{}\verb@   for pair in pairs:      # for each facet/coface pair@\\
\mbox{}\verb@      flag = REVERSE(pair) #  [c,f]@\\
\mbox{}\verb@      #print "flag 1 =",flag@\\
\mbox{}\verb@      for k in range(dim-1):@\\
\mbox{}\verb@         cell = flag[-1]@\\
\mbox{}\verb@         flag += [chain[k+1][cell][1]]@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      verts = [CCOMB([V[v] for v in bases[dim-k][flag[k]]]) for k in range(dim+1)]@\\
\mbox{}\verb@      flagMat = [verts[v]+[1] for v in range(dim+1)]@\\
\mbox{}\verb@      flagSign = SIGN(np.linalg.det(flagMat))@\\
\mbox{}\verb@      signs += [flagSign]@\\
\mbox{}\verb@   @\\
\mbox{}\verb@   csrSignedBoundaryMat = csr_matrix( (signs, TRANS(pairs)) )@\\
\mbox{}\verb@   # numpy.set_printoptions(threshold=numpy.nan)@\\
\mbox{}\verb@   # print csrSignedBoundaryMat.todense()@\\
\mbox{}\verb@   return csrSignedBoundaryMat@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Oriented boundary cells for polytopal complexes}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap44}
\protect\makebox[0ex][r]{\NWtarget{nuweb25a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Signed boundary cells for polytopal complexes\nobreak\ {\footnotesize 25a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Signed boundary cells for polytopal complexes """@\\
\mbox{}\verb@from scipy.sparse import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@def signedCellularBoundaryCells(verts,bases):@\\
\mbox{}\verb@   CV = bases[-1]@\\
\mbox{}\verb@   boundaryMat = signedCellularBoundary(verts,bases)@\\
\mbox{}\verb@   chainCoords = csc_matrix((len(CV), 1))@\\
\mbox{}\verb@   for cell in range(len(CV)): chainCoords[cell,0] = 1@\\
\mbox{}\verb@   boundaryCells = list((boundaryMat * chainCoords).tocoo().row)@\\
\mbox{}\verb@   orientations = list((boundaryMat * chainCoords).tocoo().data)@\\
\mbox{}\verb@   return orientations,boundaryCells@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsubsection{Examples}
%-------------------------------------------------------------------------------

\paragraph{Boundary of a 2D cuboidal grid}
The \texttt{larCuboids} function, when applied to a \texttt{shape} parameter and to the optional parameter \texttt{full=True}, returns both the intoger vertices \texttt{V} of the generated complex, and the list of \texttt{bases} of cells of dimension $k$ ($0\leq k\leq d$), where $d = \texttt{len(shape)}-1$.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap45}
\protect\makebox[0ex][r]{\NWtarget{nuweb25b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test14.py"@\nobreak\ {\footnotesize 25b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary of a 2D cuboidal grid """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@V,bases = larCuboids([6,6],True)@\\
\mbox{}\verb@[VV,EV,FV] = bases@\\
\mbox{}\verb@submodel = mkSignedEdges((V,EV))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@VIEW(larModelNumbering(scalx=1,scaly=1,scalz=1)(V,bases,submodel,1))@\\
\mbox{}\verb@@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,bases)@\\
\mbox{}\verb@FV = [EV[e] if sign==1 else REVERSE(EV[e])  for (sign,e) in zip(*orientedBoundary)]@\\
\mbox{}\verb@submodel = mkSignedEdges((V,FV))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@VIEW(larModelNumbering(scalx=1,scaly=1,scalz=1)(V,bases,submodel,1))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Oriented cuboidal and simplicial cells}
In the example \texttt{test/py/larcc/test15.py} we generate a simplicial and a cuboidal decomposition of the space parallelepiped with $\texttt{shape}=[5,5,3]$.
In both cases the boundary matrix is computed by using the general polytopal approach provided by the \texttt{signedCellularBoundaryCells} function, showing in both cases the oriented boundary of the two complexes
(Just notice that in the cuboidal version \texttt{pyplasm} makes a wrong rendering, to be fixed).

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap46}
\protect\makebox[0ex][r]{\NWtarget{nuweb26a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test15.py"@\nobreak\ {\footnotesize 26a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Oriented cuboidal and simplicial cells (same algorithm) """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@# cuboidal grid@\\
\mbox{}\verb@V,bases = larCuboids([5,5,3],True)@\\
\mbox{}\verb@[VV,EV,FV,CV] = bases@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,AA(AA(REVERSE))([VV,EV,FV,CV]))@\\
\mbox{}\verb@cells = [FV[f] if sign==1 else REVERSE(FV[f])  for (sign,f) in zip(*orientedBoundary)]@\\
\mbox{}\verb@VIEW(EXPLODE(1.25,1.25,1.25)(MKPOLS((V,cells))))@\\
\mbox{}\verb@@\\
\mbox{}\verb@# simplicial grid@\\
\mbox{}\verb@V,CV = larSimplexGrid1([5,5,3])@\\
\mbox{}\verb@FV = larSimplexFacets(CV)@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@bases = [VV,EV,FV,CV]@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,bases)@\\
\mbox{}\verb@cells = [FV[f] if sign==1 else REVERSE(FV[f])  for (sign,f) in zip(*orientedBoundary)]@\\
\mbox{}\verb@VIEW(EXPLODE(1.25,1.25,1.25)(MKPOLS((V,cells))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap47}
\protect\makebox[0ex][r]{\NWtarget{nuweb26b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test18.py"@\nobreak\ {\footnotesize 26b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Oriented cuboidal cells """@\\
\mbox{}\verb@""" Oriented cuboidal cells """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@def orientedBoundaryCells(V,(VV,EV,FV,CV)):@\\
\mbox{}\verb@    boundaryMat = signedCellularBoundary(V,[VV,EV,FV,CV])@\\
\mbox{}\verb@    chainCoords = csc_matrix((len(CV), 1))@\\
\mbox{}\verb@    for cell in range(len(CV)): chainCoords[cell,0] = 1@\\
\mbox{}\verb@    boundaryCells = list((boundaryMat * chainCoords).tocoo().row)@\\
\mbox{}\verb@    orientations = list((boundaryMat * chainCoords).tocoo().data)@\\
\mbox{}\verb@    return zip(orientations,boundaryCells)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def normalVector(V,facet):@\\
\mbox{}\verb@    v0,v1,v2 = facet[:3]@\\
\mbox{}\verb@    return VECTPROD([ DIFF([V[v1],V[v0]]), DIFF([V[v2],V[v0]]) ])@\\
\mbox{}\verb@@\\
\mbox{}\verb@# cuboidal grid@\\
\mbox{}\verb@V,bases = larCuboids([5,5,3],True)@\\
\mbox{}\verb@[VV,EV,FV,CV] = bases@\\
\mbox{}\verb@BCpairs = orientedBoundaryCells(V,[VV,EV,FV,CV])@\\
\mbox{}\verb@orientedBoundary = [FV[face] if sign>0 else swap(FV[face]) for (sign,face) in BCpairs]@\\
\mbox{}\verb@normals = [ normalVector(V,facet)  for facet in orientedBoundary ]@\\
\mbox{}\verb@facetCentroids = [CCOMB([V[v] for v in facet]) for facet in orientedBoundary]@\\
\mbox{}\verb@appliedNormals = [[centroid,SUM([centroid,normal])] for (centroid,normal) in zip(facetCentroids,normals)]@\\
\mbox{}\verb@normalVectors = AA(POLYLINE)(appliedNormals)@\\
\mbox{}\verb@@\\
\mbox{}\verb@orientedQuads = [[sign,FV[face]] if sign>0 else [sign,swap(FV[face])] for (sign,face) in BCpairs]@\\
\mbox{}\verb@FVtriangles = CAT([[[v0,v1,v2],[v2,v1,v3]] if sign==1 else [[v0,v1,v2],[v0,v2,v3]]@\\
\mbox{}\verb@            for (sign,[v0,v1,v2,v3]) in orientedQuads])@\\
\mbox{}\verb@@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,FVtriangles))+normalVectors))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------





\subsubsection{Boundary orientation of a random (2D) cubical complex}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap48}
\protect\makebox[0ex][r]{\NWtarget{nuweb27}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test17.py"@\nobreak\ {\footnotesize 27 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary orientation of a random 2D cubical complex """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@from random import random@\\
\mbox{}\verb@@\\
\mbox{}\verb@# test model generation@\\
\mbox{}\verb@shape = 20,20@\\
\mbox{}\verb@V,FV = larCuboids(shape)@\\
\mbox{}\verb@cellSpan = prod(shape)@\\
\mbox{}\verb@fraction = 0.5@\\
\mbox{}\verb@remove = [int(random()*cellSpan) for k in range(int(cellSpan*fraction)) ]@\\
\mbox{}\verb@FV = [FV[k] for k in range(cellSpan) if not (k in remove)]@\\
\mbox{}\verb@_,EV = larCuboidsFacets((V,FV))@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,[VV,EV,FV])@\\
\mbox{}\verb@cells = [EV[e] if sign==1 else REVERSE(EV[e]) for (sign,e) in zip(*orientedBoundary)]@\\
\mbox{}\verb@@\\
\mbox{}\verb@# test model visualization@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,FV))))@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,EV))))@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,cells))))@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,cells))))@\\
\mbox{}\verb@VIEW(mkSignedEdges((V,cells),2))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsubsection{Boundary orientation of a random (2D) triangulation}

Here we provide a 2D example of computation of the oriented boundary of a quite convoluted random cellular complex. The steps performed by the scripts in the following paragraphs are listed below:

\begin{enumerate}
\item	vertices are generated as random point in the unit circle
\item	the Delaunay triangulation of the whole set of points is built.
\item	spike-like triangles elimination
\item	the 90\% of triangles is randomly discarded
\item	the input LAR is provided by the remaining triangles
\item	the 1-cells are computed, and —  if  $n_i < n_j$ -- oriented as $v_i \to v_j$
\item	the 2-cells are "coherently oriented" via the sign of their 3x3 determinant 
	using normalised homogeneous coordinates of vertices: ccw if $\det > 0$
\item	the signed boundary matrix $[\partial_2]$ is built (with elements in $\{-1,0,1\}$ )
\item	the signed boundary 1-chain (the red one) is computed by $[\partial_2][\mathbf{1}_2]$,
	where $[\mathbf{1}_2]$ is the coordinate representation of the “total” 2-chain
\end{enumerate}



\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.243\linewidth,width=0.243\linewidth]{images/zigzag1} 
   \includegraphics[height=0.243\linewidth,width=0.243\linewidth]{images/zigzag2} 
   \includegraphics[height=0.243\linewidth,width=0.243\linewidth]{images/zigzag3} 
   \includegraphics[height=0.243\linewidth,width=0.243\linewidth]{images/zigzag4} 
   \caption{The orientation of the boundary of a random cuboidal 2-complex;
   (a) 2-cells; (b) 1-cells; (c) exploded boundary 1-chain; (d) oriented boundary 1-chain.}
   \label{zigzag}
\vspace{5mm}
   \centering
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/randomdelaunay1} 
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/randomdelaunay2} 
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/randomdelaunay3} 
   \caption{The orientation of the boundary of a random simplicial 2-complex;
   (a) 2-cells; (b) 1-cells; (c) oriented boundary 1-chain (red).}
   \label{randomdelaunay}
\end{figure}


\paragraph{Top-down implementation}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap49}
\protect\makebox[0ex][r]{\NWtarget{nuweb28}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test16.py"@\nobreak\ {\footnotesize 28 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary orientation of a random 2D triangulation """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@from random import random@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Vertices V generated as random point in the unit circle\nobreak\ {\footnotesize \NWlink{nuweb30a}{30a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Delaunay triangulation of the whole set V of points\nobreak\ {\footnotesize \NWlink{nuweb30b}{30b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Fraction of triangles randomly discarded\nobreak\ {\footnotesize \NWlink{nuweb30c}{30c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Coherently orient the input LAR model (V,FV)\nobreak\ {\footnotesize \NWlink{nuweb30d}{30d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Compute the 1-cell and 0-cell bases EV and VV\nobreak\ {\footnotesize \NWlink{nuweb31a}{31a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Signed 2-boundary matrix and signed boundary 1-chain\nobreak\ {\footnotesize \NWlink{nuweb31b}{31b}}$\,\rangle$}\verb@   @\\
\mbox{}\verb@@\hbox{$\langle\,$Display the boundary 1-chain\nobreak\ {\footnotesize \NWlink{nuweb31c}{31c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Vertices V generated as random point in the unit circle}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap50}
\protect\makebox[0ex][r]{\NWtarget{nuweb30a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Vertices V generated as random point in the unit circle\nobreak\ {\footnotesize 30a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Vertices V generated as random point in the unit circle """@\\
\mbox{}\verb@verts = []@\\
\mbox{}\verb@npoints = 200@\\
\mbox{}\verb@for k in range(npoints):@\\
\mbox{}\verb@   t = 2*pi*random()@\\
\mbox{}\verb@   u = random()+random()@\\
\mbox{}\verb@   if u > 1: r = 2-u @\\
\mbox{}\verb@   else: r = u@\\
\mbox{}\verb@   verts += [[r*cos(t), r*sin(t)]]@\\
\mbox{}\verb@VIEW(STRUCT(AA(MK)(verts)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Delaunay triangulation of the whole set V of points}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap51}
\protect\makebox[0ex][r]{\NWtarget{nuweb30b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Delaunay triangulation of the whole set V of points\nobreak\ {\footnotesize 30b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Delaunay triangulation of the whole set V of points """@\\
\mbox{}\verb@triangles = Delaunay(verts)@\\
\mbox{}\verb@def area(cell): return linalg.det([verts[v]+[1] for v in cell])/2@\\
\mbox{}\verb@cells = [ cell for cell in triangles.vertices.tolist() if area(cell)>PI/(3*npoints)]@\\
\mbox{}\verb@V, FV = AA(list)(verts), cells@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Fraction of triangles randomly discarded}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap52}
\protect\makebox[0ex][r]{\NWtarget{nuweb30c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Fraction of triangles randomly discarded\nobreak\ {\footnotesize 30c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Fraction of triangles randomly discarded """@\\
\mbox{}\verb@fraction = 0.7@\\
\mbox{}\verb@cellSpan = len(FV)@\\
\mbox{}\verb@remove = [int(random()*cellSpan) for k in range(int(cellSpan*fraction)) ]@\\
\mbox{}\verb@FV = [FV[k] for k in range(cellSpan) if not k in remove]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Coherent orientation of input LAR model (V,FV)}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap53}
\protect\makebox[0ex][r]{\NWtarget{nuweb30d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Coherently orient the input LAR model (V,FV)\nobreak\ {\footnotesize 30d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Coherently orient the input LAR model (V,FV) """@\\
\mbox{}\verb@def positiveOrientation(model):@\\
\mbox{}\verb@   V,simplices = model@\\
\mbox{}\verb@   out = []@\\
\mbox{}\verb@   for simplex in simplices:@\\
\mbox{}\verb@      theMat = [V[v]+[1] for v in simplex]@\\
\mbox{}\verb@      if sign(linalg.det(theMat)) > 0:  out += [simplex]@\\
\mbox{}\verb@      else: out += [REVERSE(simplex)]@\\
\mbox{}\verb@   return V,out@\\
\mbox{}\verb@@\\
\mbox{}\verb@V,FV = positiveOrientation((V,FV))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Compute the 1-cell and 0-cell bases EV and VV}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap54}
\protect\makebox[0ex][r]{\NWtarget{nuweb31a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Compute the 1-cell and 0-cell bases EV and VV\nobreak\ {\footnotesize 31a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Compute the 1-cell and 0-cell bases EV and VV """@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@VV = AA(LIST)(range(len(V)))@\\
\mbox{}\verb@VIEW(mkSignedEdges((V,EV)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Signed boundary matrix [$\partial_2$] and signed boundary 1-chain}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap55}
\protect\makebox[0ex][r]{\NWtarget{nuweb31b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Signed 2-boundary matrix and signed boundary 1-chain\nobreak\ {\footnotesize 31b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Signed 2-boundary matrix  and signed boundary 1-chain """@\\
\mbox{}\verb@orientedBoundary = signedCellularBoundaryCells(V,[VV,EV,FV])@\\
\mbox{}\verb@cells = [EV[e] if sign==1 else REVERSE(EV[e]) for (sign,e) in zip(*orientedBoundary)]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Display the boundary 1-chain}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap56}
\protect\makebox[0ex][r]{\NWtarget{nuweb31c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Display the boundary 1-chain\nobreak\ {\footnotesize 31c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Display the boundary 1-chain """@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS((V,FV))))@\\
\mbox{}\verb@VIEW(STRUCT(@\\
\mbox{}\verb@   MKPOLS((V,FV)) +@\\
\mbox{}\verb@   [COLOR(RED)(mkSignedEdges((V,cells)))]  ))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb28}{28}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------

\subsection{Orienting polytopal cells}

An orientation can be allocated to a general convex (polytopal) cell by computing the biggest simplex in its interior, and attributing to the cell the orientation of the contained simplex. 
It is in fact easy to see that the orientation can be propagated via adjacent coherently oriented simplexes, until to cover the whole cell.

The variables in the following script have the meaning specified below:
{input} :  "cell" indices of a convex and solid polytopes and "V" vertices;
{output} :  biggest "simplex" indices spanning the polytope;
{\tt m} : number of cell vertices;
{\tt d} : dimension (number of coordinates) of cell vertices;
{\tt d+1} : number of simplex vertices;
{\tt vcell} : cell vertices;
{\tt vsimplex} : simplex vertices;
{\tt Id} : identity matrix;
{\tt basis} : orthonormal spanning set of vectors $e_k$;
{\tt vector} : position vector of a simplex vertex in translated coordinates;
{\tt unUsedIndices} : cell indices not moved to simplex.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap57}
\protect\makebox[0ex][r]{\NWtarget{nuweb32}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Oriented boundary cells for simplicial models\nobreak\ {\footnotesize 32}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def pivotSimplices(V,CV,d=3):@\\
\mbox{}\verb@   simplices = []@\\
\mbox{}\verb@   for cell in CV:@\\
\mbox{}\verb@      vcell = np.array([V[v] for v in cell])@\\
\mbox{}\verb@      m, simplex = len(cell), []@\\
\mbox{}\verb@      # translate the cell: for each k, vcell[k] -= vcell[0], and simplex[0] := cell[0]@\\
\mbox{}\verb@      for k in range(m-1,-1,-1): vcell[k] -= vcell[0]@\\
\mbox{}\verb@      # simplex = [0], basis = [], tensor = Id(d+1)@\\
\mbox{}\verb@      simplex += [cell[0]]@\\
\mbox{}\verb@      basis = []@\\
\mbox{}\verb@      tensor = np.array(IDNT(d))@\\
\mbox{}\verb@      # look for most distant cell vertex@\\
\mbox{}\verb@      dists = [SUM([SQR(x) for x in v])**0.5 for v in vcell]@\\
\mbox{}\verb@      maxDistIndex = max(enumerate(dists),key=lambda x: x[1])[0]@\\
\mbox{}\verb@      vector = np.array([vcell[maxDistIndex]])@\\
\mbox{}\verb@      # normalize vector@\\
\mbox{}\verb@      den=(vector**2).sum(axis=-1) **0.5@\\
\mbox{}\verb@      basis = [vector/den]@\\
\mbox{}\verb@      simplex += [cell[maxDistIndex]]@\\
\mbox{}\verb@      unUsedIndices = [h for h in cell if h not in simplex]@\\
\mbox{}\verb@      @\\
\mbox{}\verb@      # for k in {2,d+1}:@\\
\mbox{}\verb@      for k in range(2,d+1):@\\
\mbox{}\verb@         # update the orthonormal tensor@\\
\mbox{}\verb@         e = basis[-1]@\\
\mbox{}\verb@         tensor = tensor - np.dot(e.T, e)@\\
\mbox{}\verb@         # compute the index h of a best vector@\\
\mbox{}\verb@         # look for most distant cell vertex@\\
\mbox{}\verb@         dists = [SUM([SQR(x) for x in np.dot(tensor,v)])**0.5@\\
\mbox{}\verb@         if h in unUsedIndices else 0.0@\\
\mbox{}\verb@         for (h,v) in zip(cell,vcell)]@\\
\mbox{}\verb@         # insert the best vector index h in output simplex@\\
\mbox{}\verb@         maxDistIndex = max(enumerate(dists),key=lambda x: x[1])[0]@\\
\mbox{}\verb@         vector = np.array([vcell[maxDistIndex]])@\\
\mbox{}\verb@         # normalize vector@\\
\mbox{}\verb@         den=(vector**2).sum(axis=-1) **0.5@\\
\mbox{}\verb@         basis += [vector/den]@\\
\mbox{}\verb@         simplex += [cell[maxDistIndex]]@\\
\mbox{}\verb@         unUsedIndices = [h for h in cell if h not in simplex]@\\
\mbox{}\verb@      simplices += [simplex]@\\
\mbox{}\verb@   return simplices@\\
\mbox{}\verb@@\\
\mbox{}\verb@def simplexOrientations(V,simplices):@\\
\mbox{}\verb@   vcells = [[V[v]+[1.0] for v in simplex] for simplex in simplices]@\\
\mbox{}\verb@   return [SIGN(np.linalg.det(vcell)) for vcell in vcells]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\section{Exporting the library}

\subsection{MIT licence}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap58}
\protect\makebox[0ex][r]{\NWtarget{nuweb33}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$The MIT Licence\nobreak\ {\footnotesize 33}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@"""@\\
\mbox{}\verb@The MIT License@\\
\mbox{}\verb@===============@\\
\mbox{}\verb@   @\\
\mbox{}\verb@Permission is hereby granted, free of charge, to any person obtaining@\\
\mbox{}\verb@a copy of this software and associated documentation files (the@\\
\mbox{}\verb@'Software'), to deal in the Software without restriction, including@\\
\mbox{}\verb@without limitation the rights to use, copy, modify, merge, publish,@\\
\mbox{}\verb@distribute, sublicense, and/or sell copies of the Software, and to@\\
\mbox{}\verb@permit persons to whom the Software is furnished to do so, subject to@\\
\mbox{}\verb@the following conditions:@\\
\mbox{}\verb@@\\
\mbox{}\verb@The above copyright notice and this permission notice shall be@\\
\mbox{}\verb@included in all copies or substantial portions of the Software.@\\
\mbox{}\verb@@\\
\mbox{}\verb@THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,@\\
\mbox{}\verb@EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF@\\
\mbox{}\verb@MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.@\\
\mbox{}\verb@IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY@\\
\mbox{}\verb@CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,@\\
\mbox{}\verb@TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE@\\
\mbox{}\verb@SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.@\\
\mbox{}\verb@"""@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\subsection{Importing of modules or packages}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap59}
\protect\makebox[0ex][r]{\NWtarget{nuweb34a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Importing of modules or packages\nobreak\ {\footnotesize 34a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@import collections@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@from scipy import zeros,arange,mat,amin,amax,array@\\
\mbox{}\verb@from scipy.sparse import vstack,hstack,csr_matrix,coo_matrix,lil_matrix,triu@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Writing the library file}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap60}
\protect\makebox[0ex][r]{\NWtarget{nuweb34b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"larlib/larlib/larcc.py"@\nobreak\ {\footnotesize 34b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# -*- coding: utf-8 -*-@\\
\mbox{}\verb@""" Basic LARCC library """@\\
\mbox{}\verb@@\hbox{$\langle\,$The MIT Licence\nobreak\ {\footnotesize \NWlink{nuweb33}{33}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Importing of modules or packages\nobreak\ {\footnotesize \NWlink{nuweb34a}{34a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$From list of triples to scipy.sparse\nobreak\ {\footnotesize \NWlink{nuweb3b}{3b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Brc to Coo transformation\nobreak\ {\footnotesize \NWlink{nuweb2}{2}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Coo to Csr transformation\nobreak\ {\footnotesize \NWlink{nuweb3c}{3c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Brc to Csr transformation\nobreak\ {\footnotesize \NWlink{nuweb4a}{4a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Query Matrix shape\nobreak\ {\footnotesize \NWlink{nuweb5a}{5a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Sparse to dense matrix transformation\nobreak\ {\footnotesize \NWlink{nuweb6a}{6a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Matrix product and transposition\nobreak\ {\footnotesize \NWlink{nuweb6c}{6c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Matrix filtering to produce the boundary matrix\nobreak\ {\footnotesize \NWlink{nuweb8}{8}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Matrix filtering via a generic predicate\nobreak\ {\footnotesize \NWlink{nuweb9b}{9b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Characteristic matrix transposition\nobreak\ {\footnotesize \NWlink{nuweb9d}{9d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$From cells and facets to boundary operator\nobreak\ {\footnotesize \NWlink{nuweb21a}{21a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$From cells and facets to boundary cells\nobreak\ {\footnotesize \NWlink{nuweb21b}{21b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Signed boundary matrix for simplicial models\nobreak\ {\footnotesize \NWlink{nuweb23a}{23a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Orientation of general convex cells\nobreak\ {\footnotesize \NWlink{nuweb23b}{23b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computation of cell adjacencies\nobreak\ {\footnotesize \NWlink{nuweb11a}{11a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Extraction of facets of a cell complex\nobreak\ {\footnotesize \NWlink{nuweb10}{10}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Some incidence operators\nobreak\ {\footnotesize \NWlink{nuweb17a}{17a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Visualization of cell indices\nobreak\ {\footnotesize \NWlink{nuweb12}{12}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Numbered visualization of a LAR model\nobreak\ {\footnotesize ?}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Drawing of oriented edges\nobreak\ {\footnotesize \NWlink{nuweb13b}{13b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Incidence chain computation\nobreak\ {\footnotesize \NWlink{nuweb19a}{19a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Signed boundary matrix for polytopal complexes\nobreak\ {\footnotesize \NWlink{nuweb24}{24}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Signed boundary cells for polytopal complexes\nobreak\ {\footnotesize \NWlink{nuweb25a}{25a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Oriented boundary cells for simplicial models\nobreak\ {\footnotesize \NWlink{nuweb32}{32}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@if __name__ == "__main__": @\\
\mbox{}\verb@   @\hbox{$\langle\,$Test examples\nobreak\ {\footnotesize \NWlink{nuweb35a}{35a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\section{Unit tests}


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap61}
\protect\makebox[0ex][r]{\NWtarget{nuweb35a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test examples\nobreak\ {\footnotesize 35a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Brc to Coo transformation\nobreak\ {\footnotesize \NWlink{nuweb3a}{3a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Coo to Csr transformation\nobreak\ {\footnotesize \NWlink{nuweb3d}{3d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Brc to Csr transformation\nobreak\ {\footnotesize \NWlink{nuweb4b}{4b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of Query Matrix shape\nobreak\ {\footnotesize \NWlink{nuweb5b}{5b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of Sparse to dense matrix transformation\nobreak\ {\footnotesize \NWlink{nuweb6b}{6b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Matrix filtering to produce the boundary matrix\nobreak\ {\footnotesize \NWlink{nuweb9a}{9a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test example of Matrix filtering via a generic predicate\nobreak\ {\footnotesize \NWlink{nuweb9c}{9c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of From cells and facets to boundary operator\nobreak\ {\footnotesize \NWlink{nuweb20}{20}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of From cells and facets to boundary cells\nobreak\ {\footnotesize \NWlink{nuweb21c}{21c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of Computation of cell adjacencies\nobreak\ {\footnotesize \NWlink{nuweb11c}{11c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test examples of Extraction of facets of a cell complex\nobreak\ {\footnotesize \NWlink{nuweb11b}{11b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34b}{34b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Comparing oriented and unoriented boundary}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap62}
\protect\makebox[0ex][r]{\NWtarget{nuweb35b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test09.py"@\nobreak\ {\footnotesize 35b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" comparing oriented boundary and unoriented boundary extraction on a simple example """@\\
\mbox{}\verb@import sys; sys.path.insert(0, 'lib/py/')@\\
\mbox{}\verb@from largrid import *@\\
\mbox{}\verb@from larcc import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@V,CV = larSimplexGrid1([1,1,1])@\\
\mbox{}\verb@FV = larSimplexFacets(CV)@\\
\mbox{}\verb@@\\
\mbox{}\verb@orientedBoundary = signedBoundaryCells(V,CV,FV)@\\
\mbox{}\verb@orientedBoundaryFV = [FV[-k] if k<0 else swap(FV[k]) for k in orientedBoundary]@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,orientedBoundaryFV))))@\\
\mbox{}\verb@@\\
\mbox{}\verb@BF = boundaryCells(CV,FV)@\\
\mbox{}\verb@boundaryCellsFV = [FV[k] for k in BF]@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,boundaryCellsFV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap63}
\protect\makebox[0ex][r]{\NWtarget{nuweb36a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test12.py"@\nobreak\ {\footnotesize 36a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" comparing edge orientation and oriented boundary extraction """@\\
\mbox{}\verb@import sys; sys.path.insert(0, 'lib/py/')@\\
\mbox{}\verb@from largrid import *@\\
\mbox{}\verb@from larcc import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@V,FV = larSimplexGrid1([5,5])@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@VIEW(mkSignedEdges((V,EV)))@\\
\mbox{}\verb@@\\
\mbox{}\verb@orientedBoundary = signedBoundaryCells(V,FV,EV)@\\
\mbox{}\verb@orientedBoundaryEV = [EV[-k] if k<0 else swap(EV[k]) for k in orientedBoundary]@\\
\mbox{}\verb@VIEW(mkSignedEdges((V,orientedBoundaryEV)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------



\appendix

\section{Appendix: Tutorials}


\subsection{Model generation, skeleton and boundary extraction}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap64}
\protect\makebox[0ex][r]{\NWtarget{nuweb36b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test01.py"@\nobreak\ {\footnotesize 36b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Model generation, skeleton and boundary extraction """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\hbox{$\langle\,$input of 2D topology and geometry data\nobreak\ {\footnotesize \NWlink{nuweb36c}{36c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$characteristic matrices\nobreak\ {\footnotesize \NWlink{nuweb36d}{36d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$incidence matrix\nobreak\ {\footnotesize \NWlink{nuweb37a}{37a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$boundary and coboundary operators\nobreak\ {\footnotesize \NWlink{nuweb37b}{37b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$product of cell complexes\nobreak\ {\footnotesize \NWlink{nuweb37c}{37c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$2-skeleton extraction\nobreak\ {\footnotesize \NWlink{nuweb37d}{37d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$1-skeleton extraction\nobreak\ {\footnotesize \NWlink{nuweb38a}{38a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$0-coboundary computation\nobreak\ {\footnotesize \NWlink{nuweb38b}{38b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$1-coboundary computation\nobreak\ {\footnotesize \NWlink{nuweb38c}{38c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$2-coboundary computation\nobreak\ {\footnotesize \NWlink{nuweb38d}{38d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$boundary chain visualisation\nobreak\ {\footnotesize \NWlink{nuweb39a}{39a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap65}
\protect\makebox[0ex][r]{\NWtarget{nuweb36c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$input of 2D topology and geometry data\nobreak\ {\footnotesize 36c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@# input of geometry and topology  @\\
\mbox{}\verb@V2 = [[4,10],[8,10],[14,10],[8,7],[14,7],[4,4],[8,4],[14,4]]@\\
\mbox{}\verb@EV = [[0,1],[1,2],[3,4],[5,6],[6,7],[0,5],[1,3],[2,4],[3,6],[4,7]]@\\
\mbox{}\verb@FV = [[0,1,3,5,6],[1,2,3,4],[3,4,6,7]]@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap66}
\protect\makebox[0ex][r]{\NWtarget{nuweb36d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$characteristic matrices\nobreak\ {\footnotesize 36d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# characteristic matrices@\\
\mbox{}\verb@csrFV = csrCreate(FV)@\\
\mbox{}\verb@csrEV = csrCreate(EV)@\\
\mbox{}\verb@print "\nFV =\n", csr2DenseMatrix(csrFV)@\\
\mbox{}\verb@print "\nEV =\n", csr2DenseMatrix(csrEV)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap67}
\protect\makebox[0ex][r]{\NWtarget{nuweb37a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$incidence matrix\nobreak\ {\footnotesize 37a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# product@\\
\mbox{}\verb@csrEF = matrixProduct(csrEV, csrTranspose(csrFV))@\\
\mbox{}\verb@print "\nEF =\n", csr2DenseMatrix(csrEF)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap68}
\protect\makebox[0ex][r]{\NWtarget{nuweb37b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$boundary and coboundary operators\nobreak\ {\footnotesize 37b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# boundary and coboundary operators@\\
\mbox{}\verb@facetLengths = [csrCell.getnnz() for csrCell in csrEV]@\\
\mbox{}\verb@boundary = csrBoundaryFilter(csrEF,facetLengths)@\\
\mbox{}\verb@coboundary_1 = csrTranspose(boundary)@\\
\mbox{}\verb@print "\ncoboundary_1 =\n", csr2DenseMatrix(coboundary_1)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap69}
\protect\makebox[0ex][r]{\NWtarget{nuweb37c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$product of cell complexes\nobreak\ {\footnotesize 37c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# product operator@\\
\mbox{}\verb@mod_2D = (V2,FV)@\\
\mbox{}\verb@V1,topol_0 = [[0.],[1.],[2.]], [[0],[1],[2]]@\\
\mbox{}\verb@topol_1 = [[0,1],[1,2]]@\\
\mbox{}\verb@mod_0D = (V1,topol_0)@\\
\mbox{}\verb@mod_1D = (V1,topol_1)@\\
\mbox{}\verb@V3,CV = larModelProduct([mod_2D,mod_1D])@\\
\mbox{}\verb@mod_3D = (V3,CV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(mod_3D)))@\\
\mbox{}\verb@print "\nk_3 =", len(CV), "\n"@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap70}
\protect\makebox[0ex][r]{\NWtarget{nuweb37d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$2-skeleton extraction\nobreak\ {\footnotesize 37d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# 2-skeleton of the 3D product complex@\\
\mbox{}\verb@mod_2D_1 = (V2,EV)@\\
\mbox{}\verb@mod_3D_h2 = larModelProduct([mod_2D,mod_0D])@\\
\mbox{}\verb@mod_3D_v2 = larModelProduct([mod_2D_1,mod_1D])@\\
\mbox{}\verb@_,FV_h = mod_3D_h2@\\
\mbox{}\verb@_,FV_v = mod_3D_v2@\\
\mbox{}\verb@FV3 = FV_h + FV_v@\\
\mbox{}\verb@SK2 = (V3,FV3)@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(SK2)))@\\
\mbox{}\verb@print "\nk_2 =", len(FV3), "\n"@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap71}
\protect\makebox[0ex][r]{\NWtarget{nuweb38a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$1-skeleton extraction\nobreak\ {\footnotesize 38a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# 1-skeleton of the 3D product complex @\\
\mbox{}\verb@mod_2D_0 = (V2,AA(LIST)(range(len(V2))))@\\
\mbox{}\verb@mod_3D_h1 = larModelProduct([mod_2D_1,mod_0D])@\\
\mbox{}\verb@mod_3D_v1 = larModelProduct([mod_2D_0,mod_1D])@\\
\mbox{}\verb@_,EV_h = mod_3D_h1@\\
\mbox{}\verb@_,EV_v = mod_3D_v1@\\
\mbox{}\verb@EV3 = EV_h + EV_v@\\
\mbox{}\verb@SK1 = (V3,EV3)@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(SK1)))@\\
\mbox{}\verb@print "\nk_1 =", len(EV3), "\n"@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap72}
\protect\makebox[0ex][r]{\NWtarget{nuweb38b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$0-coboundary computation\nobreak\ {\footnotesize 38b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# boundary and coboundary operators@\\
\mbox{}\verb@np.set_printoptions(threshold=sys.maxint)@\\
\mbox{}\verb@csrFV3 = csrCreate(FV3)@\\
\mbox{}\verb@csrEV3 = csrCreate(EV3)@\\
\mbox{}\verb@csrVE3 = csrTranspose(csrEV3)@\\
\mbox{}\verb@facetLengths = [csrCell.getnnz() for csrCell in csrEV3]@\\
\mbox{}\verb@boundary = csrBoundaryFilter(csrVE3,facetLengths)@\\
\mbox{}\verb@coboundary_0 = csrTranspose(boundary)@\\
\mbox{}\verb@print "\ncoboundary_0 =\n", csr2DenseMatrix(coboundary_0)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap73}
\protect\makebox[0ex][r]{\NWtarget{nuweb38c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$1-coboundary computation\nobreak\ {\footnotesize 38c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@csrEF3 = matrixProduct(csrEV3, csrTranspose(csrFV3))@\\
\mbox{}\verb@facetLengths = [csrCell.getnnz() for csrCell in csrFV3]@\\
\mbox{}\verb@boundary = csrBoundaryFilter(csrEF3,facetLengths)@\\
\mbox{}\verb@coboundary_1 = csrTranspose(boundary)@\\
\mbox{}\verb@print "\ncoboundary_1.T =\n", csr2DenseMatrix(coboundary_1.T)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap74}
\protect\makebox[0ex][r]{\NWtarget{nuweb38d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$2-coboundary computation\nobreak\ {\footnotesize 38d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@csrCV = csrCreate(CV)@\\
\mbox{}\verb@csrFC3 = matrixProduct(csrFV3, csrTranspose(csrCV))@\\
\mbox{}\verb@facetLengths = [csrCell.getnnz() for csrCell in csrCV]@\\
\mbox{}\verb@boundary = csrBoundaryFilter(csrFC3,facetLengths)@\\
\mbox{}\verb@coboundary_2 = csrTranspose(boundary)@\\
\mbox{}\verb@print "\ncoboundary_2 =\n", csr2DenseMatrix(coboundary_2)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap75}
\protect\makebox[0ex][r]{\NWtarget{nuweb39a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$boundary chain visualisation\nobreak\ {\footnotesize 39a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@# boundary chain visualisation@\\
\mbox{}\verb@boundaryCells_2 = boundaryCells(CV,FV3)@\\
\mbox{}\verb@boundary = (V3,[FV3[k] for k in boundaryCells_2])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(boundary)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb36b}{36b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\subsection{Boundary of 3D simplicial grid}

%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap76}
\protect\makebox[0ex][r]{\NWtarget{nuweb39b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test02.py"@\nobreak\ {\footnotesize 39b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary of 3D simplicial grid """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$boundary of 3D simplicial grid\nobreak\ {\footnotesize \NWlink{nuweb39c}{39c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap77}
\protect\makebox[0ex][r]{\NWtarget{nuweb39c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$boundary of 3D simplicial grid\nobreak\ {\footnotesize 39c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@V,CV = larSimplexGrid1([10,10,3])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,CV))))@\\
\mbox{}\verb@SK2 = (V,larSimplexFacets(CV))@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(SK2)))@\\
\mbox{}\verb@_,FV = SK2@\\
\mbox{}\verb@SK1 = (V,larSimplexFacets(FV))@\\
\mbox{}\verb@_,EV = SK1@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(SK1)))@\\
\mbox{}\verb@@\\
\mbox{}\verb@boundaryCells_2 = boundaryCells(CV,FV)@\\
\mbox{}\verb@boundary = (V,[FV[k] for k in boundaryCells_2])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(boundary)))@\\
\mbox{}\verb@print "\nboundaryCells_2 =\n", boundaryCells_2@\\
\mbox{}\verb@@\\
\mbox{}\verb@boundaryCells_2 = signedBoundaryCells(V,CV,FV)@\\
\mbox{}\verb@boundaryFV = [FV[-k] if k<0 else swap(FV[k]) for k in boundaryCells_2]@\\
\mbox{}\verb@@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,boundaryFV))))@\\
\mbox{}\verb@print "\nboundaryCells_2 =\n", boundaryFV@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb39b}{39b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Oriented boundary of a random simplicial complex}


%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap78}
\protect\makebox[0ex][r]{\NWtarget{nuweb40a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test03.py"@\nobreak\ {\footnotesize 40a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Oriented boundary of a random simplicial complex """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Importing external modules\nobreak\ {\footnotesize \NWlink{nuweb40b}{40b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Generating and viewing a random 3D simplicial complex\nobreak\ {\footnotesize \NWlink{nuweb40c}{40c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computing and viewing its non-oriented boundary\nobreak\ {\footnotesize \NWlink{nuweb40d}{40d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computing and viewing its oriented boundary\nobreak\ {\footnotesize \NWlink{nuweb41a}{41a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap79}
\protect\makebox[0ex][r]{\NWtarget{nuweb40b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Importing external modules\nobreak\ {\footnotesize 40b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Importing external modules """@\\
\mbox{}\verb@from scipy.spatial import Delaunay@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb40a}{40a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap80}
\protect\makebox[0ex][r]{\NWtarget{nuweb40c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Generating and viewing a random 3D simplicial complex\nobreak\ {\footnotesize 40c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@verts = np.random.rand(10000, 3) # 1000 points in 3-d@\\
\mbox{}\verb@verts = [AA(lambda x: 2*x)(VECTDIFF([vert,[0.5,0.5,0.5]])) for vert in verts]@\\
\mbox{}\verb@verts = [vert for vert in verts if VECTNORM(vert) < 1.0]@\\
\mbox{}\verb@tetra = Delaunay(verts)@\\
\mbox{}\verb@cells = [cell for cell in tetra.vertices.tolist()@\\
\mbox{}\verb@       if  ((verts[cell[0]][2]<0) and (verts[cell[1]][2]<0) @\\
\mbox{}\verb@            and (verts[cell[2]][2]<0) and (verts[cell[3]][2]<0) ) ]@\\
\mbox{}\verb@V, CV = verts, cells@\\
\mbox{}\verb@VIEW(MKPOL([V,AA(AA(lambda k:k+1))(CV),[]]))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb40a}{40a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap81}
\protect\makebox[0ex][r]{\NWtarget{nuweb40d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computing and viewing its non-oriented boundary\nobreak\ {\footnotesize 40d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@FV = larSimplexFacets(CV)@\\
\mbox{}\verb@VIEW(MKPOL([V,AA(AA(lambda k:k+1))(FV),[]]))@\\
\mbox{}\verb@boundaryCells_2 = boundaryCells(CV,FV)@\\
\mbox{}\verb@print "\nboundaryCells_2 =\n", boundaryCells_2@\\
\mbox{}\verb@bndry = (V,[FV[k] for k in boundaryCells_2])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(bndry)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb40a}{40a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap82}
\protect\makebox[0ex][r]{\NWtarget{nuweb41a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computing and viewing its oriented boundary\nobreak\ {\footnotesize 41a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@boundaryCells_2 = signedBoundaryCells(V,CV,FV)@\\
\mbox{}\verb@print "\nboundaryCells_2 =\n", boundaryCells_2@\\
\mbox{}\verb@boundaryFV = [FV[-k] if k<0 else swap(FV[k]) for k in boundaryCells_2]@\\
\mbox{}\verb@boundaryModel = (V,boundaryFV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(boundaryModel)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb40a}{40a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Oriented boundary of a simplicial grid}

%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap83}
\protect\makebox[0ex][r]{\NWtarget{nuweb41b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test04.py"@\nobreak\ {\footnotesize 41b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\hbox{$\langle\,$Generate and view a 3D simplicial grid\nobreak\ {\footnotesize \NWlink{nuweb41c}{41c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computing and viewing the 2-skeleton of simplicial grid\nobreak\ {\footnotesize \NWlink{nuweb41d}{41d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computing and viewing the oriented boundary of simplicial grid\nobreak\ {\footnotesize \NWlink{nuweb41e}{41e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap84}
\protect\makebox[0ex][r]{\NWtarget{nuweb41c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Generate and view a 3D simplicial grid\nobreak\ {\footnotesize 41c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Generate and view a 3D simplicial grid """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@V,CV = larSimplexGrid1([4,4,4])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,CV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap85}
\protect\makebox[0ex][r]{\NWtarget{nuweb41d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computing and viewing the 2-skeleton of simplicial grid\nobreak\ {\footnotesize 41d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@FV = larSimplexFacets(CV)@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,FV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap86}
\protect\makebox[0ex][r]{\NWtarget{nuweb41e}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computing and viewing the oriented boundary of simplicial grid\nobreak\ {\footnotesize 41e}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@csrSignedBoundaryMat = signedSimplicialBoundary (CV,FV)@\\
\mbox{}\verb@boundaryCells_2 = signedBoundaryCells(V,CV,FV)@\\
\mbox{}\verb@boundaryFV = [FV[-k] if k<0 else swap(FV[k]) for k in boundaryCells_2]@\\
\mbox{}\verb@boundary = (V,boundaryFV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(boundary)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb41b}{41b}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Skeletons and oriented boundary of a simplicial complex}


%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap87}
\protect\makebox[0ex][r]{\NWtarget{nuweb42a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test05.py"@\nobreak\ {\footnotesize 42a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Skeletons and oriented boundary of a simplicial complex """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Skeletons computation and visualisation\nobreak\ {\footnotesize ?}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Oriented boundary matrix visualization\nobreak\ {\footnotesize \NWlink{nuweb42c}{42c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Computation of oriented boundary cells\nobreak\ {\footnotesize \NWlink{nuweb42d}{42d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap88}
\protect\makebox[0ex][r]{\NWtarget{nuweb42b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Skeletons computation and vilualisation\nobreak\ {\footnotesize 42b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Skeletons computation and vilualisation """@\\
\mbox{}\verb@V,FV = larSimplexGrid1([3,3])@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,FV))))@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,EV))))@\\
\mbox{}\verb@VV = larSimplexFacets(EV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,VV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap89}
\protect\makebox[0ex][r]{\NWtarget{nuweb42c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Oriented boundary matrix visualization\nobreak\ {\footnotesize 42c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Oriented boundary matrix visualization """@\\
\mbox{}\verb@np.set_printoptions(threshold='nan')@\\
\mbox{}\verb@csrSignedBoundaryMat = signedSimplicialBoundary (FV,EV)@\\
\mbox{}\verb@Z = csr2DenseMatrix(csrSignedBoundaryMat)@\\
\mbox{}\verb@print "\ncsrSignedBoundaryMat =\n", Z@\\
\mbox{}\verb@import matplotlib.pyplot@\\
\mbox{}\verb@from pylab import *@\\
\mbox{}\verb@matshow(Z)@\\
\mbox{}\verb@show()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb42a}{42a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap90}
\protect\makebox[0ex][r]{\NWtarget{nuweb42d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Computation of oriented boundary cells\nobreak\ {\footnotesize 42d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@"""  Computation of oriented boundary cells """@\\
\mbox{}\verb@boundaryCells_1 = signedBoundaryCells(V,FV,EV)@\\
\mbox{}\verb@print "\nboundaryCells_1 =\n", boundaryCells_1@\\
\mbox{}\verb@boundaryEV = [EV[-k] if k<0 else swap(EV[k]) for k in boundaryCells_1]@\\
\mbox{}\verb@bndry = (V,boundaryEV)@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(bndry)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb42a}{42a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Boundary of random 2D simplicial complex}

%-------------------------------------------------------------------------------
\begin{flushleft} \small
\begin{minipage}{\linewidth} \label{scrap91}
\protect\makebox[0ex][r]{\NWtarget{nuweb43a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test06.py"@\nobreak\ {\footnotesize 43a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary of random 2D simplicial complex """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@from scipy.spatial import Delaunay@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Test for quasi-equilateral triangles\nobreak\ {\footnotesize \NWlink{nuweb43b}{43b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Generation and selection of random triangles\nobreak\ {\footnotesize \NWlink{nuweb43c}{43c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Boundary computation and visualisation\nobreak\ {\footnotesize \NWlink{nuweb44a}{44a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{minipage}\\[4ex]
\end{flushleft}
%-------------------------------------------------------------------------------


\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.25\linewidth,width=0.32\linewidth]{images/tria0} 
   \includegraphics[height=0.25\linewidth,width=0.32\linewidth]{images/tria1} 
   \includegraphics[height=0.25\linewidth,width=0.32\linewidth]{images/tria2} 
   \caption{example caption}
   \label{fig:example}
\end{figure}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap92}
\protect\makebox[0ex][r]{\NWtarget{nuweb43b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Test for quasi-equilateral triangles\nobreak\ {\footnotesize 43b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Test for quasi-equilateral triangles """@\\
\mbox{}\verb@def quasiEquilateral(tria):@\\
\mbox{}\verb@   a = VECTNORM(VECTDIFF(tria[0:2]))@\\
\mbox{}\verb@   b = VECTNORM(VECTDIFF(tria[1:3]))@\\
\mbox{}\verb@   c = VECTNORM(VECTDIFF([tria[0],tria[2]]))@\\
\mbox{}\verb@   m = max(a,b,c)@\\
\mbox{}\verb@   if m/a < 1.7 and m/b < 1.7 and m/c < 1.7: return True@\\
\mbox{}\verb@   else: return False@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb43a}{43a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap93}
\protect\makebox[0ex][r]{\NWtarget{nuweb43c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Generation and selection of random triangles\nobreak\ {\footnotesize 43c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Generation and selection of random triangles """@\\
\mbox{}\verb@verts = np.random.rand(50,2)@\\
\mbox{}\verb@verts = (verts - [0.5,0.5]) * 2@\\
\mbox{}\verb@triangles = Delaunay(verts)@\\
\mbox{}\verb@cells = [ cell for cell in triangles.vertices.tolist()@\\
\mbox{}\verb@       if (not quasiEquilateral([verts[k] for k in cell])) ]@\\
\mbox{}\verb@V, FV = AA(list)(verts), cells@\\
\mbox{}\verb@EV = larSimplexFacets(FV)@\\
\mbox{}\verb@pols2D = MKPOLS((V,FV))@\\
\mbox{}\verb@VIEW(EXPLODE(1.5,1.5,1.5)(pols2D))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb43a}{43a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap94}
\protect\makebox[0ex][r]{\NWtarget{nuweb44a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Boundary computation and visualisation\nobreak\ {\footnotesize 44a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Boundary computation and visualisation """@\\
\mbox{}\verb@orientedBoundary = signedBoundaryCells(V,FV,EV)@\\
\mbox{}\verb@submodel = mkSignedEdges((V,orientedBoundary))@\\
\mbox{}\verb@VIEW(submodel)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb43a}{43a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap95}
\protect\makebox[0ex][r]{\NWtarget{nuweb44b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Decompose a permutation into cycles\nobreak\ {\footnotesize 44b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Decompose a permutation into cycles """@\\
\mbox{}\verb@def permutationOrbits(List):@\\
\mbox{}\verb@   d = dict((i,int(x)) for i,x in enumerate(List))@\\
\mbox{}\verb@   out = []@\\
\mbox{}\verb@   while d:@\\
\mbox{}\verb@      x = list(d)[0]@\\
\mbox{}\verb@      orbit = []@\\
\mbox{}\verb@      while x in d:@\\
\mbox{}\verb@         orbit += [x],@\\
\mbox{}\verb@         x = d.pop(x)@\\
\mbox{}\verb@      out += [CAT(orbit)+orbit[0]]@\\
\mbox{}\verb@   return out@\\
\mbox{}\verb@      @\\
\mbox{}\verb@if __name__ == "__main__":@\\
\mbox{}\verb@   print [2, 3, 4, 5, 6, 7, 0, 1]@\\
\mbox{}\verb@   print permutationOrbits([2, 3, 4, 5, 6, 7, 0, 1])@\\
\mbox{}\verb@   print [3,9,8,4,10,7,2,11,6,0,1,5]@\\
\mbox{}\verb@   print permutationOrbits([3,9,8,4,10,7,2,11,6,0,1,5])@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Assemblies of simplices and hypercubes}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap96}
\protect\makebox[0ex][r]{\NWtarget{nuweb44c}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/larcc/test07.py"@\nobreak\ {\footnotesize 44c }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Assemblies of simplices and hypercubes """@\\
\mbox{}\verb@from larlib import *@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Definition of 1-dimensional LAR models\nobreak\ {\footnotesize \NWlink{nuweb45a}{45a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Assembly generation of squares and triangles\nobreak\ {\footnotesize \NWlink{nuweb45b}{45b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Assembly generation of cubes and tetrahedra\nobreak\ {\footnotesize \NWlink{nuweb45c}{45c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.405\linewidth]{images/assembly1} 
   \includegraphics[width=0.315\linewidth]{images/assembly2} 
   \caption{(a) Assemblies of squares and triangles; (b) assembly of cubes and tetrahedra.}
   \label{fig:example}
\end{figure}

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap97}
\protect\makebox[0ex][r]{\NWtarget{nuweb45a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Definition of 1-dimensional LAR models\nobreak\ {\footnotesize 45a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Definition of 1-dimensional LAR models  """@\\
\mbox{}\verb@geom_0,topol_0 = [[0.],[1.],[2.],[3.],[4.]],[[0,1],[1,2],[3,4]]@\\
\mbox{}\verb@geom_1,topol_1 = [[0.],[1.],[2.]], [[0,1],[1,2]]@\\
\mbox{}\verb@mod_0 = (geom_0,topol_0)@\\
\mbox{}\verb@mod_1 = (geom_1,topol_1)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb44c}{44c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap98}
\protect\makebox[0ex][r]{\NWtarget{nuweb45b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Assembly generation of squares and triangles\nobreak\ {\footnotesize 45b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Assembly generation of squares and triangles """@\\
\mbox{}\verb@squares = larModelProduct([mod_0,mod_1])@\\
\mbox{}\verb@V,FV = squares@\\
\mbox{}\verb@simplices = pivotSimplices(V,FV,d=2)@\\
\mbox{}\verb@VIEW(STRUCT([ MKPOL([V,AA(AA(C(SUM)(1)))(simplices),[]]),@\\
\mbox{}\verb@           SKEL_1(STRUCT(MKPOLS((V,FV)))) ]))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb44c}{44c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap99}
\protect\makebox[0ex][r]{\NWtarget{nuweb45c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Assembly generation of cubes and tetrahedra\nobreak\ {\footnotesize 45c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Assembly generation  of cubes and tetrahedra """@\\
\mbox{}\verb@cubes = larModelProduct([squares,mod_0])@\\
\mbox{}\verb@V,CV = cubes@\\
\mbox{}\verb@simplices = pivotSimplices(V,CV,d=3)@\\
\mbox{}\verb@VIEW(STRUCT([ MKPOL([V,AA(AA(C(SUM)(1)))(simplices),[]]),@\\
\mbox{}\verb@           SKEL_1(STRUCT(MKPOLS((V,CV)))) ]))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb44c}{44c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------







\bibliographystyle{amsalpha}
\bibliography{larcc}

\end{document}
