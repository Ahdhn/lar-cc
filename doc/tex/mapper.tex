% -------------------------------------------------------------------------
% ------ nuweb macros (redefine as desired, or omit with "nuweb -p") ------
% -------------------------------------------------------------------------
\providecommand{\NWtxtMacroDefBy}{Macro defined by}
\providecommand{\NWtxtMacroRefIn}{Macro referenced in}
\providecommand{\NWtxtMacroNoRef}{Macro never referenced}
\providecommand{\NWtxtDefBy}{Defined by}
\providecommand{\NWtxtRefIn}{Referenced in}
\providecommand{\NWtxtNoRef}{Not referenced}
\providecommand{\NWtxtFileDefBy}{File defined by}
\providecommand{\NWsep}{${\diamond}$}
\providecommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\providecommand{\NWtarget}[2]{% move baseline up by \baselineskip 
  \raisebox{\baselineskip}[1.5ex][0ex]{%
    \mbox{%
      \hypertarget{#1}{%
        \raisebox{-1\baselineskip}[0ex][0ex]{%
          \mbox{#2}%
}}}}}
% -------------------------------------------------------------------------

\documentclass[11pt,oneside]{article}	%use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}		%Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}		%...ora4paperora5paperor...
%\geometry{landscape}		%Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}		%Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}				%Usepdf,png,jpg,orepsÃŸwithpdflatex;useepsinDVImode
								%TeXwillautomaticallyconverteps-->pdfinpdflatex		
\usepackage{amssymb}
\usepackage{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{Domain mapping with LAR
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
\author{Alberto Paoluzzi}
%\date{}							%Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\begin{abstract}
In this module a first implementation (no optimisations) is done of several \texttt{LAR} operators, reproducing the behaviour of the plasm  \texttt{STRUCT} and \texttt{MAP} primitives, but with better handling of the topology, including the stitching of decomposed (simplicial domains) about their possible sewing. A definition of specialised classes \texttt{Model}, \texttt{Mat} and \texttt{Verts} is also contained in this module, together with the design and the implementation of the \emph{traversal} algorithms for networks of structures.
\end{abstract}

\tableofcontents

%===============================================================================
\section{Introduction}
%===============================================================================

The \texttt{mapper} module, introduced here, aims to provide the tools needed to apply both dimension-independent affine transformations and general simplicial maps to geometric objects and assemblies developed within the LAR scheme. 

For this purpose, a simplicial decomposition of the $[0,1]^d$ hypercube ($d \geq 1$) with any possible \texttt{shape} is firstly given, followed by its scaled version with any  according $\texttt{size}\in\E^d$, being its position vector the mapped image of the point $\mathbf{1}\in\E^d$. A general mapping mechanism is specified, to map any domain decomposition (either simplicial or not) with a given set of coordinate functions, providing a piecewise-linear approximation of any curved embedding of a $d$-dimensional domain in any $\E^n$ space, with $n \geq d$. 
A suitable function is also given to identify corresponding vertices when mapping a domain decomposition of the fundamental polygon (or polyhedron) of a closed manifold. 

The geometric tools given in this chapter employ a normalised homogeneous representation of vertices of the represented shapes, where the added coordinate is the \emph{last} of the ordered list of vertex coordinates. The homogeneous representation of vertices is used \emph{implicitly}, by inserting the extra coordinate only when needed by the operation at hand, mainly for computing the product of the object's vertices times the matrix of an affine tensor. 

A set of primitive surface and solid shapes is also provided, via the mapping mechanism of a simplicial decomposition of a $d$-dimensional chart. A simplified version of the PLaSM specification of dimension-independent elementary affine transformation is given as well.

The second part of this module is dedicated to the development of a complete framework for the implementation of hierarchical assemblies of shapes and scene graphs, by using the simplest possible set of computing tools. In this case no hierarchical graphs or multigraph are employed, i.e.~no specialised data structures are produced. The ordered list model of hierarchical structures, inherited from PHIGS and PLaSM, is employed in this context. A recursive traversal is used to transform all the component parts of a hierarchical assembly into the reference frame of the first object of the assembly, i.e.~in world coordinates.

%===============================================================================
\section{Piecewise-linear mapping of topological spaces}
%===============================================================================

A very simple but foundational software subsystem is developed in this section, by giving a general mechanism to produce curved maps of topological spaces, via the simplicial decomposition of a chart, i.e.~of a planar embedding of the fundamental polygon of a $d$-dimensional manifold, and the definition of coordinate functions to be applied to its vertices ($0$-cells of the decomposition) to generate an embedding of the manifold.

\subsection{Domain decomposition}
%-------------------------------------------------------------------------------

A simplicial map is a map between simplicial complexes with the property that the images of the vertices of a simplex always span a simplex.  Simplicial maps are thus determined by their effects on vertices, and provide a piecewise-linear approximation of their underlying polyhedra.


\paragraph{Standard and scaled decomposition of unit domain}
The \texttt{larDomain} of given \texttt{shape} is decomposed by \texttt{larSimplexGrid} as an hypercube of dimension $d \equiv\texttt{len(shape)}$, where the \texttt{shape} tuple provides the number or row, columns, pages, etc.~of the decomposition.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap1}
\protect\makebox[0ex][r]{\NWtarget{nuweb2}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Generate a simplicial decomposition ot the $[0,1]^d$ domain\nobreak\ {\footnotesize 2}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" simplicial decomposition of the unit d-cube """@\\
\mbox{}\verb@def larDomain(shape):@\\
\mbox{}\verb@   # V,CV = larSimplexGrid(shape)@\\
\mbox{}\verb@   V,CV = larCuboids(shape)@\\
\mbox{}\verb@   V = scalePoints(V, [1./d for d in shape])@\\
\mbox{}\verb@   return V,CV@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

A scaled simplicial decomposition is provided by the second-order  \texttt{larIntervals} function, with \texttt{len(shape)} and \texttt{len(size)} parameters, where the $d$-dimensionale vector \texttt{len(size)} is assumed as the scaling vector to be applied to the point $\mathbf{1}\in\E^d$.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap2}
\protect\makebox[0ex][r]{\NWtarget{nuweb3a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Scaled simplicial decomposition ot the $[0,1]^d$ domain\nobreak\ {\footnotesize 3a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larIntervals(shape):@\\
\mbox{}\verb@   def larIntervals0(size):@\\
\mbox{}\verb@      V,CV = larDomain(shape)@\\
\mbox{}\verb@      V = scalePoints(V, [scaleFactor for scaleFactor in size])@\\
\mbox{}\verb@      return V,CV@\\
\mbox{}\verb@   return larIntervals0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Mapping domain vertices}
The second-order texttt{larMap} function is the LAR implementation of the PLaSM primitive \texttt{MAP}.
It is applied to the array \texttt{coordFuncs} of coordinate functions and to the simplicially decomposed  \texttt{domain}, returning an embedded and/or curved \texttt{domain} instance.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap3}
\protect\makebox[0ex][r]{\NWtarget{nuweb3b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Primitive mapping function\nobreak\ {\footnotesize 3b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larMap(coordFuncs):@\\
\mbox{}\verb@   def larMap0(domain,dim=2):@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      V = TRANS(CONS(coordFuncs)(V))  # plasm CONStruction@\\
\mbox{}\verb@      return checkModel((V,CV),dim)@\\
\mbox{}\verb@   return larMap0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Identify close or coincident points}

The function \texttt{checkModel}, applied to a \texttt{model} parameter, i.e.~to a (vertices, cells)  pair, returns the model after identification of vertices with coincident or very close position vectors.
The \texttt{checkModel} function works as follows: first a dictionary \texttt{vertDict} is created, with key a suitably approximated position converted into a string by the \texttt{vcode} converter (given in the Appendix), and with value the list of vertex indices with the same (approximated) position. Then, an \texttt{invertedindex} array is created, associating each original vertex index with the new index produced by enumerating the (distinct) keys of the dictionary. Finally, a new list \texttt{CV} of cells is created, by substituting the new vertex indices for the old ones. 

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap4}
\protect\makebox[0ex][r]{\NWtarget{nuweb3c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Create a dictionary with key the point location\nobreak\ {\footnotesize 3c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def checkModel(model,dim=2):@\\
\mbox{}\verb@   V,CV = model; n = len(V)@\\
\mbox{}\verb@   vertDict = defaultdict(list)@\\
\mbox{}\verb@   for k,v in enumerate(V): vertDict[vcode(v)].append(k) @\\
\mbox{}\verb@   points,verts = TRANS(vertDict.items())@\\
\mbox{}\verb@   invertedindex = [None]*n@\\
\mbox{}\verb@   V = []@\\
\mbox{}\verb@   for k,value in enumerate(verts):@\\
\mbox{}\verb@      V.append(eval(points[k]))@\\
\mbox{}\verb@      for i in value:@\\
\mbox{}\verb@         invertedindex[i]=k   @\\
\mbox{}\verb@   CV = [[invertedindex[v] for v in cell] for cell in CV]@\\
\mbox{}\verb@   # filter out degenerate cells@\\
\mbox{}\verb@   CV = [list(set(cell)) for cell in CV if len(set(cell))>=dim+1]@\\
\mbox{}\verb@   return V, CV@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\subsection{Embedding or projecting LAR models}
%-------------------------------------------------------------------------------

In order to apply 3D transformations to a two-dimensional LAR model, we must embed it in 3D space, by adding one more coordinate to its vertices. 

\paragraph{Embedding or projecting a geometric model}

This task is performed by the function \texttt{larEmbed} with parameter $k$, that inserts its $d$-dimensional geometric argument in the $x_{d+1}, \ldots, x_{d+k}=0$ subspace of $\E^{d+k}$.
A projection transformation, that removes the last $k$ coordinate of vertices, without changing the object topology, is performed by the function \texttt{larEmbed} with \emph{negative} integer parameter.


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap5}
\protect\makebox[0ex][r]{\NWtarget{nuweb4}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Embedding and projecting a geometric model\nobreak\ {\footnotesize 4}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larEmbed(k):@\\
\mbox{}\verb@   def larEmbed0(model):@\\
\mbox{}\verb@      V,CV = model@\\
\mbox{}\verb@      if k>0:@\\
\mbox{}\verb@         V = [v+[0.]*k for v in V] @\\
\mbox{}\verb@      elif k<0:@\\
\mbox{}\verb@         V = [v[:-k] for v in V] @\\
\mbox{}\verb@      return V,CV@\\
\mbox{}\verb@   return larEmbed0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
%===============================================================================
\section{Primitive objects}
\label{sec:generators}
%===============================================================================

A large number of primitive surfaces or solids is defined in this section, using the \texttt{larMap} mechanism and the coordinate functions of a suitable chart.

%-------------------------------------------------------------------------------
\subsection{1D primitives}
%-------------------------------------------------------------------------------

\paragraph{Circle}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap6}
\protect\makebox[0ex][r]{\NWtarget{nuweb5a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Circle centered in the origin\nobreak\ {\footnotesize 5a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larCircle(radius=1.,angle=2*PI,dim=1):@\\
\mbox{}\verb@   def larCircle0(shape=36):@\\
\mbox{}\verb@      domain = larIntervals([shape])([angle])@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      x = lambda V : [radius*COS(p[0]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [radius*SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y])(domain,dim)@\\
\mbox{}\verb@   return larCircle0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{2D primitives}
%-------------------------------------------------------------------------------
Some useful 2D primitive objects either in $\E^2$ or embedded in $\E^3$ are defined here, including 2D disks and rings, as well as cylindrical, spherical and toroidal surfaces.

\paragraph{Disk surface}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap7}
\protect\makebox[0ex][r]{\NWtarget{nuweb5b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Disk centered in the origin\nobreak\ {\footnotesize 5b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larDisk(radius=1.,angle=2*PI):@\\
\mbox{}\verb@   def larDisk0(shape=[36,1]):@\\
\mbox{}\verb@      domain = larIntervals(shape)([angle,radius])@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      x = lambda V : [p[1]*COS(p[0]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [p[1]*SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y])(domain)@\\
\mbox{}\verb@   return larDisk0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Ring surface}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap8}
\protect\makebox[0ex][r]{\NWtarget{nuweb5c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Ring centered in the origin\nobreak\ {\footnotesize 5c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larRing(r1,r2,angle=2*PI):@\\
\mbox{}\verb@   def larRing0(shape=[36,1]):@\\
\mbox{}\verb@      V,CV = larIntervals(shape)([angle,r2-r1])@\\
\mbox{}\verb@      V = translatePoints(V,[0,r1])@\\
\mbox{}\verb@      domain = V,CV@\\
\mbox{}\verb@      x = lambda V : [p[1] * COS(p[0]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [p[1] * SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y])(domain)@\\
\mbox{}\verb@   return larRing0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Cylinder surface}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap9}
\protect\makebox[0ex][r]{\NWtarget{nuweb6a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Cylinder surface with $z$ axis\nobreak\ {\footnotesize 6a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@from scipy.linalg import det@\\
\mbox{}\verb@"""@\\
\mbox{}\verb@def makeOriented(model):@\\
\mbox{}\verb@   V,CV = model@\\
\mbox{}\verb@   out = []@\\
\mbox{}\verb@   for cell in CV: @\\
\mbox{}\verb@      mat = scipy.array([V[v]+[1] for v in cell]+[[0,0,0,1]])@\\
\mbox{}\verb@      if det(mat) < 0.0:@\\
\mbox{}\verb@         out.append(cell)@\\
\mbox{}\verb@      else:@\\
\mbox{}\verb@         out.append([cell[1]]+[cell[0]]+cell[2:])@\\
\mbox{}\verb@   return V,out@\\
\mbox{}\verb@"""@\\
\mbox{}\verb@def larCylinder(radius,height,angle=2*PI):@\\
\mbox{}\verb@   def larCylinder0(shape=[36,1]):@\\
\mbox{}\verb@      domain = larIntervals(shape)([angle,1])@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      x = lambda V : [radius*COS(p[0]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [radius*SIN(p[0]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [height*p[1] for p in V]@\\
\mbox{}\verb@      mapping = [x,y,z]@\\
\mbox{}\verb@      model = larMap(mapping)(domain)@\\
\mbox{}\verb@      # model = makeOriented(model)@\\
\mbox{}\verb@      return model@\\
\mbox{}\verb@   return larCylinder0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Spherical surface of given radius}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap10}
\protect\makebox[0ex][r]{\NWtarget{nuweb6b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Spherical surface of given radius\nobreak\ {\footnotesize 6b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larSphere(radius=1,angle1=PI,angle2=2*PI):@\\
\mbox{}\verb@   def larSphere0(shape=[18,36]):@\\
\mbox{}\verb@      V,CV = larIntervals(shape)([angle1,angle2])@\\
\mbox{}\verb@      V = translatePoints(V,[-angle1/2,-angle2/2])@\\
\mbox{}\verb@      domain = V,CV@\\
\mbox{}\verb@      x = lambda V : [radius*COS(p[0])*COS(p[1]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [radius*COS(p[0])*SIN(p[1]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [radius*SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larSphere0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Toroidal surface}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap11}
\protect\makebox[0ex][r]{\NWtarget{nuweb7a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Toroidal surface of given radiuses\nobreak\ {\footnotesize 7a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larToroidal(r,R,angle1=2*PI,angle2=2*PI):@\\
\mbox{}\verb@   def larToroidal0(shape=[24,36]):@\\
\mbox{}\verb@      domain = larIntervals(shape)([angle1,angle2])@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      x = lambda V : [(R + r*COS(p[0])) * COS(p[1]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [(R + r*COS(p[0])) * SIN(p[1]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [-r * SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larToroidal0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Crown surface}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap12}
\protect\makebox[0ex][r]{\NWtarget{nuweb7b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Half-toroidal surface of given radiuses\nobreak\ {\footnotesize 7b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larCrown(r,R,angle=2*PI):@\\
\mbox{}\verb@   def larCrown0(shape=[24,36]):@\\
\mbox{}\verb@      V,CV = larIntervals(shape)([PI,angle])@\\
\mbox{}\verb@      V = translatePoints(V,[-PI/2,0])@\\
\mbox{}\verb@      domain = V,CV@\\
\mbox{}\verb@      x = lambda V : [(R + r*COS(p[0])) * COS(p[1]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [(R + r*COS(p[0])) * SIN(p[1]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [-r * SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larCrown0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{3D primitives}
%-------------------------------------------------------------------------------


\paragraph{Solid Box}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap13}
\protect\makebox[0ex][r]{\NWtarget{nuweb8a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Solid box of given extreme vectors\nobreak\ {\footnotesize 8a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larBox(minVect,maxVect):@\\
\mbox{}\verb@   size = DIFF([maxVect,minVect])@\\
\mbox{}\verb@   print "size =",size@\\
\mbox{}\verb@   box = larApply(s(*size))(larCuboids([1,1,1]))@\\
\mbox{}\verb@   print "box =",box@\\
\mbox{}\verb@   return larApply(t(*minVect))(box)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------



\paragraph{Solid Ball}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap14}
\protect\makebox[0ex][r]{\NWtarget{nuweb8b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Solid Sphere of given radius\nobreak\ {\footnotesize 8b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larBall(radius=1,angle1=PI,angle2=2*PI):@\\
\mbox{}\verb@   def larBall0(shape=[18,36]):@\\
\mbox{}\verb@      V,CV = checkModel(larSphere(radius,angle1,angle2)(shape))@\\
\mbox{}\verb@      return V,[range(len(V))]@\\
\mbox{}\verb@   return larBall0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Solid cylinder}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap15}
\protect\makebox[0ex][r]{\NWtarget{nuweb8c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Solid cylinder of given radius and height\nobreak\ {\footnotesize 8c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larRod(radius,height,angle=2*PI):@\\
\mbox{}\verb@   def larRod0(shape=[36,1]):@\\
\mbox{}\verb@      V,CV = checkModel(larCylinder(radius,height,angle)(shape))@\\
\mbox{}\verb@      return V,[range(len(V))]@\\
\mbox{}\verb@   return larRod0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Hollow cylinder}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap16}
\protect\makebox[0ex][r]{\NWtarget{nuweb8d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Hollow cylinder of given radiuses and height\nobreak\ {\footnotesize 8d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larHollowCyl(r,R,height,angle=2*PI):@\\
\mbox{}\verb@   def larHollowCyl0(shape=[36,1,1]):@\\
\mbox{}\verb@      V,CV = larIntervals(shape)([angle,R-r,height])@\\
\mbox{}\verb@      V = translatePoints(V,[0,r,0])@\\
\mbox{}\verb@      domain = V,CV@\\
\mbox{}\verb@      x = lambda V : [p[1] * COS(p[0]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [p[1] * SIN(p[0]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [p[2] * height for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larHollowCyl0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Hollow sphere}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap17}
\protect\makebox[0ex][r]{\NWtarget{nuweb9a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Hollow sphere of given radiuses\nobreak\ {\footnotesize 9a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larHollowSphere(r,R,angle1=PI,angle2=2*PI):@\\
\mbox{}\verb@   def larHollowSphere0(shape=[36,1,1]):@\\
\mbox{}\verb@      V,CV = larIntervals(shape)([angle1,angle2,R-r])@\\
\mbox{}\verb@      V = translatePoints(V,[-angle1/2,-angle2/2,r])@\\
\mbox{}\verb@      domain = V,CV@\\
\mbox{}\verb@      x = lambda V : [p[2]*COS(p[0])*COS(p[1]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [p[2]*COS(p[0])*SIN(p[1]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [p[2]*SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larHollowSphere0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{Solid torus}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap18}
\protect\makebox[0ex][r]{\NWtarget{nuweb9b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Solid torus of given radiuses\nobreak\ {\footnotesize 9b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larTorus(r,R,angle1=2*PI,angle2=2*PI):@\\
\mbox{}\verb@   def larTorus0(shape=[24,36,1]):@\\
\mbox{}\verb@      domain = larIntervals(shape)([angle1,angle2,r])@\\
\mbox{}\verb@      V,CV = domain@\\
\mbox{}\verb@      x = lambda V : [(R + p[2]*COS(p[0])) * COS(p[1]) for p in V]@\\
\mbox{}\verb@      y = lambda V : [(R + p[2]*COS(p[0])) * SIN(p[1]) for p in V]@\\
\mbox{}\verb@      z = lambda V : [-p[2] * SIN(p[0]) for p in V]@\\
\mbox{}\verb@      return larMap([x,y,z])(domain)@\\
\mbox{}\verb@   return larTorus0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Solid pizza}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap19}
\protect\makebox[0ex][r]{\NWtarget{nuweb9c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Solid pizza of given radiuses\nobreak\ {\footnotesize 9c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larPizza(r,R,angle=2*PI):@\\
\mbox{}\verb@   assert angle <= PI@\\
\mbox{}\verb@   def larPizza0(shape=[24,36]):@\\
\mbox{}\verb@      V,CV = checkModel(larCrown(r,R,angle)(shape))@\\
\mbox{}\verb@      V += [[0,0,-r],[0,0,r]]@\\
\mbox{}\verb@      return V,[range(len(V))]@\\
\mbox{}\verb@   return larPizza0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%===============================================================================
\section{Affine transformations}
%===============================================================================
%-------------------------------------------------------------------------------
\subsection{Design decision}
%-------------------------------------------------------------------------------
First we state the general rules that will be satisfied by the matrices used in this module, mainly devoted to apply affine transformations to vertices of models in structure environments:
\begin{enumerate}
\item assume the scipy \texttt{ndarray} as the type of vertices, stored in row-major order;
\item use the last coordinate as the homogeneous coordinate of vertices, but do not store it explicitly;
\item store explicitly the homogeneous coordinate of transformation matrices.
\item use labels '\texttt{verts}' and '\texttt{mat}' to distinguish between vertices and transformation matrices.
\item transformation matrices are dimension-independent, and their dimension is computed as the length of the parameter vector passed to the generating function.
\end{enumerate}


%-------------------------------------------------------------------------------
\subsection{Affine mapping}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap20}
\protect\makebox[0ex][r]{\NWtarget{nuweb10}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Apply an affine transformation to a LAR model\nobreak\ {\footnotesize 10}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larApply(affineMatrix):@\\
\mbox{}\verb@   def larApply0(model):@\\
\mbox{}\verb@      if isinstance(model,Model):@\\
\mbox{}\verb@         V = scipy.dot([v.tolist()+[1.0] for v in model.verts], affineMatrix.T).tolist()@\\
\mbox{}\verb@         V = [v[:-1] for v in V]@\\
\mbox{}\verb@         CV = copy(model.cells)@\\
\mbox{}\verb@         d = copy(model.d)@\\
\mbox{}\verb@         return Model((V,CV),d)@\\
\mbox{}\verb@      elif isinstance(model,tuple):@\\
\mbox{}\verb@         V,CV = model@\\
\mbox{}\verb@         V = scipy.dot([v+[1.0] for v in V], affineMatrix.T).tolist()@\\
\mbox{}\verb@         return [v[:-1] for v in V],CV@\\
\mbox{}\verb@   return larApply0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\subsection{Elementary matrices}
%-------------------------------------------------------------------------------
Elementary matrices for affine transformation of vectors in any dimensional vector space are defined here. They include translation, scaling, rotation and shearing. 

\paragraph{Translation}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap21}
\protect\makebox[0ex][r]{\NWtarget{nuweb11a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Translation matrices\nobreak\ {\footnotesize 11a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def t(*args): @\\
\mbox{}\verb@   d = len(args)@\\
\mbox{}\verb@   mat = scipy.identity(d+1)@\\
\mbox{}\verb@   for k in range(d): @\\
\mbox{}\verb@      mat[k,d] = args[k]@\\
\mbox{}\verb@   return mat.view(Mat)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Scaling}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap22}
\protect\makebox[0ex][r]{\NWtarget{nuweb11b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Scaling matrices\nobreak\ {\footnotesize 11b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def s(*args): @\\
\mbox{}\verb@   d = len(args)@\\
\mbox{}\verb@   mat = scipy.identity(d+1)@\\
\mbox{}\verb@   for k in range(d): @\\
\mbox{}\verb@      mat[k,k] = args[k]@\\
\mbox{}\verb@   return mat.view(Mat)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
\paragraph{Rotation}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap23}
\protect\makebox[0ex][r]{\NWtarget{nuweb11c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Rotation matrices\nobreak\ {\footnotesize 11c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def r(*args): @\\
\mbox{}\verb@   args = list(args)@\\
\mbox{}\verb@   n = len(args)@\\
\mbox{}\verb@   @\hbox{$\langle\,$plane rotation (in 2D)\nobreak\ {\footnotesize \NWlink{nuweb11d}{11d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@   @\hbox{$\langle\,$space rotation (in 3D)\nobreak\ {\footnotesize \NWlink{nuweb12a}{12a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@   return mat.view(Mat)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap24}
\protect\makebox[0ex][r]{\NWtarget{nuweb11d}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$plane rotation (in 2D)\nobreak\ {\footnotesize 11d}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if n == 1: # rotation in 2D@\\
\mbox{}\verb@   angle = args[0]; cos = COS(angle); sin = SIN(angle)@\\
\mbox{}\verb@   mat = scipy.identity(3)@\\
\mbox{}\verb@   mat[0,0] = cos;   mat[0,1] = -sin;@\\
\mbox{}\verb@   mat[1,0] = sin;   mat[1,1] = cos;@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb11c}{11c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap25}
\protect\makebox[0ex][r]{\NWtarget{nuweb12a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$space rotation (in 3D)\nobreak\ {\footnotesize 12a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if n == 3: # rotation in 3D@\\
\mbox{}\verb@   mat = scipy.identity(4)@\\
\mbox{}\verb@   angle = VECTNORM(args); axis = UNITVECT(args)@\\
\mbox{}\verb@   cos = COS(angle); sin = SIN(angle)@\\
\mbox{}\verb@   @\hbox{$\langle\,$elementary rotations (in 3D)\nobreak\ {\footnotesize \NWlink{nuweb12b}{12b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@   @\hbox{$\langle\,$general rotations (in 3D)\nobreak\ {\footnotesize \NWlink{nuweb12c}{12c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb11c}{11c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap26}
\protect\makebox[0ex][r]{\NWtarget{nuweb12b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$elementary rotations (in 3D)\nobreak\ {\footnotesize 12b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if axis[1]==axis[2]==0.0:  # rotation about x@\\
\mbox{}\verb@   mat[1,1] = cos;   mat[1,2] = -sin;@\\
\mbox{}\verb@   mat[2,1] = sin;   mat[2,2] = cos;@\\
\mbox{}\verb@elif axis[0]==axis[2]==0.0:   # rotation about y@\\
\mbox{}\verb@   mat[0,0] = cos;   mat[0,2] = sin;@\\
\mbox{}\verb@   mat[2,0] = -sin;  mat[2,2] = cos;@\\
\mbox{}\verb@elif axis[0]==axis[1]==0.0:   # rotation about z@\\
\mbox{}\verb@   mat[0,0] = cos;   mat[0,1] = -sin;@\\
\mbox{}\verb@   mat[1,0] = sin;   mat[1,1] = cos;@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb12a}{12a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap27}
\protect\makebox[0ex][r]{\NWtarget{nuweb12c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$general rotations (in 3D)\nobreak\ {\footnotesize 12c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@else:    # general 3D rotation (Rodrigues' rotation formula)   @\\
\mbox{}\verb@   I = scipy.identity(3) ; u = axis@\\
\mbox{}\verb@   Ux = scipy.array([@\\
\mbox{}\verb@      [0,      -u[2],    u[1]],@\\
\mbox{}\verb@      [u[2],      0,    -u[0]],@\\
\mbox{}\verb@      [-u[1],   u[0],      0]])@\\
\mbox{}\verb@   UU = scipy.array([@\\
\mbox{}\verb@      [u[0]*u[0], u[0]*u[1],  u[0]*u[2]],@\\
\mbox{}\verb@      [u[1]*u[0], u[1]*u[1],  u[1]*u[2]],@\\
\mbox{}\verb@      [u[2]*u[0], u[2]*u[1],  u[2]*u[2]]])@\\
\mbox{}\verb@   mat[:3,:3] = cos*I + sin*Ux + (1.0-cos)*UU@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb12a}{12a}.
\end{list}
\end{flushleft}
%===============================================================================
\section{Hierarchical complexes}
%===============================================================================
Hierarchical models of complex assemblies are generated by an aggregation
of subassemblies, each one defined in a local coordinate system, and
relocated by affine transformations of coordinates.  This operation
may be repeated hierarchically, with some subassemblies defined by
aggregation of simpler parts, and so on, until one obtains a set of
elementary components, which cannot be further decomposed.

Two main advantages can be found in a hierarchical modeling approach. Each elementary part and each assembly, at every hierarchical level, are defined independently from each other, using a local coordinate frame, suitably chosen to make its definition easier. Furthermore, only one copy of each component is stored in the memory, and may be instanced in different locations and orientations how many times it is needed.

%-------------------------------------------------------------------------------
\subsection{Traversal of hierarchical structures}
%-------------------------------------------------------------------------------

Of course, the main algorithm with hierarchical structures is the \emph{traversal} of the structure network, whose aim is to transform every encountered object from local to global coordinates, where the global coordinates are those of the network root (the only node with indegree zero).

A structure network can be modelled using a directed acyclic multigraph, i.e.~a triple $(N,A,f)$
made by a set $N$ of nodes, a set $A$ of arcs, and a function $f:A \to N^2$ from arcs to ordered pairs of nodes. Conversely that in standard oriented graphs, in this kind of structure more than one oriented arc is allowed between the same pair on nodes.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.8\linewidth]{images/traversal} 
   \caption{Traversal algorithm of an acyclic multigraph.}
   \label{fig:traversal}
\end{figure}

A simple modification of a DFS (Depth First Search) visit of a graph can be used to traverse the structure network This algorithm is given in Figure~\ref{fig:traversal} from~\cite{Paoluzzi2003a}. 

\subsubsection{Traversal of nested lists}

The representation chosen for structure networks with LAR is the serialised one, consisting in ordered sequences (lists) of either (a) LAR models, or (b) affine transformations, or (c) references to other structures, either directly nested within some given structure, or called by reference (name) from within the list.

The aim of a structure network traversal is, of course, to transform every component structure, usually defined in a local coordinate system, into the reference frame of the structure as a whole, normally corresponding with the reference system of the structure's root, called the \emph{world coordinate} system.

\paragraph{The pattern of calls and returned values}

In order to better understand the behaviour of the traversal algorithm, where every transformation is applied to all the following models, --- but only if included in the same structure  (i.e.~list) --- it may be very useful to start with an \emph{algorithm emulation}. In particular, the recursive script below discriminates between three different cases (number, string, or sequence), whereas the actual traversal must do with (a) Models, (b) Matrices, and (c) Structures, respectively.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap28}
\protect\makebox[0ex][r]{\NWtarget{nuweb15a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Emulation of scene multigraph traversal\nobreak\ {\footnotesize 15a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@from pyplasm import *@\\
\mbox{}\verb@def __traverse(CTM, stack, o):@\\
\mbox{}\verb@    for i in range(len(o)):@\\
\mbox{}\verb@        if ISNUM(o[i]): print o[i], REVERSE(CTM)@\\
\mbox{}\verb@        elif ISSTRING(o[i]): @\\
\mbox{}\verb@            CTM.append(o[i])@\\
\mbox{}\verb@        elif ISSEQ(o[i]):@\\
\mbox{}\verb@            stack.append(o[i])            # push the stack@\\
\mbox{}\verb@            __traverse(CTM, stack, o[i])@\\
\mbox{}\verb@            CTM = CTM[:-len(stack)]       # pop the stack@\\
\mbox{}\verb@@\\
\mbox{}\verb@def algorithm(data):@\\
\mbox{}\verb@    CTM,stack = ["I"],[]@\\
\mbox{}\verb@    __traverse(CTM, stack, data)  @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

Some use example of the above algorithm are provided below. The printout produced at run time is shown from the \texttt{emulation of traversal algorithm} macro.
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap29}
\protect\makebox[0ex][r]{\NWtarget{nuweb15b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Examples of multigraph traversal\nobreak\ {\footnotesize 15b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@data = [1,"A", 2, 3, "B", [4, "C", 5], [6,"D", "E", 7, 8], 9]  @\\
\mbox{}\verb@print algorithm(data)@\\
\mbox{}\verb@>>> 1 ['I']@\\
\mbox{}\verb@   2 ['A', 'I']@\\
\mbox{}\verb@   3 ['A', 'I']@\\
\mbox{}\verb@   4 ['B', 'A', 'I']@\\
\mbox{}\verb@   5 ['C', 'B', 'A', 'I']@\\
\mbox{}\verb@   6 ['B', 'A', 'I']@\\
\mbox{}\verb@   7 ['E', 'D', 'B', 'A', 'I']@\\
\mbox{}\verb@   8 ['E', 'D', 'B', 'A', 'I']@\\
\mbox{}\verb@   9 ['B', 'A', 'I']@\\
\mbox{}\verb@@\\
\mbox{}\verb@data = [1,"A", [2, 3, "B", 4, "C", 5, 6,"D"], "E", 7, 8, 9]  @\\
\mbox{}\verb@print algorithm(data)@\\
\mbox{}\verb@>>> 1 ['I']@\\
\mbox{}\verb@   2 ['A', 'I']@\\
\mbox{}\verb@   3 ['A', 'I']@\\
\mbox{}\verb@   4 ['B', 'A', 'I']@\\
\mbox{}\verb@   5 ['C', 'B', 'A', 'I']@\\
\mbox{}\verb@   6 ['C', 'B', 'A', 'I']@\\
\mbox{}\verb@   7 ['E', 'A', 'I']@\\
\mbox{}\verb@   8 ['E', 'A', 'I']@\\
\mbox{}\verb@   9 ['E', 'A', 'I']@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap30}
\protect\makebox[0ex][r]{\NWtarget{nuweb16}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Emulation of traversal algorithm\nobreak\ {\footnotesize 16}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@dat = [2, 3, "B", 4, "C", 5, 6,"D"]@\\
\mbox{}\verb@print algorithm(dat)@\\
\mbox{}\verb@>>> 2 ['I']@\\
\mbox{}\verb@   3 ['I']@\\
\mbox{}\verb@   4 ['B', 'I']@\\
\mbox{}\verb@   5 ['C', 'B', 'I']@\\
\mbox{}\verb@   6 ['C', 'B', 'I']@\\
\mbox{}\verb@data = [1,"A", dat, "E", 7, 8, 9]@\\
\mbox{}\verb@print algorithm(data)@\\
\mbox{}\verb@>>> 1 ['I']@\\
\mbox{}\verb@   2 ['A', 'I']@\\
\mbox{}\verb@   3 ['A', 'I']@\\
\mbox{}\verb@   4 ['B', 'A', 'I']@\\
\mbox{}\verb@   5 ['C', 'B', 'A', 'I']@\\
\mbox{}\verb@   6 ['C', 'B', 'A', 'I']@\\
\mbox{}\verb@   7 ['E', 'A', 'I']@\\
\mbox{}\verb@   8 ['E', 'A', 'I']@\\
\mbox{}\verb@   9 ['E', 'A', 'I']@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Traversal of a scene multigraph}

The previous traversal algorithm is here customised for scene multigraph, where the objects are LAR models, i.e.~pairs of vertices of type '\texttt{Verts} and cells, and where the transformations are matrix transformations of type '\texttt{Mat}'.

\paragraph{Check models for common dimension}
The input list of a call to \texttt{larStruct} primitive is preliminary checked for uniform dimensionality of the enclosed LAR models and transformations. The common dimension \texttt{dim} of models and matrices is returned by the function \texttt{checkStruct}, within the class definition \texttt{Struct} in the module \texttt{lar2psm}. Otherwise, an exception is generated (TODO).

\paragraph{Initialization and call of the algorithm}

The function \texttt{evalStruct} is used to evaluate a structure network, i.e.~to return a \texttt{scene}
list of objects of type \texttt{Model}, all referenced in the world coordinate system. The input variable \texttt{struct} must contain an object of class \texttt{Struct}, i.e.~a reference to an unevaluated structure network. The variable \texttt{dim}  contains the embedding dimension of the structure, i.e.~the number of doordinates of its vertices (normally either 2 or 3), the CTM (Current Transformation Matrix) is initialised to the (homogeneous) identity matrix, and  the \texttt{scene} is returned by calling the \texttt{traverse} algorithm.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap31}
\protect\makebox[0ex][r]{\NWtarget{nuweb17a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Traversal of a scene multigraph\nobreak\ {\footnotesize 17a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Traversal of a scene multigraph """@\\
\mbox{}\verb@@\hbox{$\langle\,$Structure traversal algorithm\nobreak\ {\footnotesize \NWlink{nuweb17b}{17b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@def evalStruct(struct):@\\
\mbox{}\verb@    dim = struct.n@\\
\mbox{}\verb@    CTM, stack = scipy.identity(dim+1), []@\\
\mbox{}\verb@    scene = traversal(CTM, stack, struct) @\\
\mbox{}\verb@    return scene@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Structure traversal algorithm}

The \texttt{traversal} algorithm decides between three different cases, depending on the type of the currently inspected object. If the object is a \texttt{Model} instance, then applies to it the \texttt{CTM} matrix; else if the object is a \texttt{Mat} instance, then the \texttt{CTM} matrix is updated by (right) product with it; else if the object is a \texttt{Struct} instance, then the \texttt{CTM} is pushed on the stack, initially empty, then the \texttt{traversal} is called (recursion), and finally, at (each) return from recursion, the \texttt{CTM} is recovered by popping the stack.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap32}
\protect\makebox[0ex][r]{\NWtarget{nuweb17b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Structure traversal algorithm\nobreak\ {\footnotesize 17b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def traversal(CTM, stack, obj, scene=[]):@\\
\mbox{}\verb@    for i in range(len(obj)):@\\
\mbox{}\verb@        if isinstance(obj[i],Model): @\\
\mbox{}\verb@            scene += [larApply(CTM)(obj[i])]@\\
\mbox{}\verb@        elif isinstance(obj[i],Mat): @\\
\mbox{}\verb@            CTM = scipy.dot(CTM, obj[i])@\\
\mbox{}\verb@        elif isinstance(obj[i],Struct):@\\
\mbox{}\verb@            stack.append(CTM) @\\
\mbox{}\verb@            traversal(CTM, stack, obj[i], scene)@\\
\mbox{}\verb@            CTM = stack.pop()@\\
\mbox{}\verb@    return scene@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb17a}{17a}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\subsection{Example}
%-------------------------------------------------------------------------------
Some examples of structures as combinations of LAR models and affine transformations are given in this section. 

\paragraph{Global coordinates}
We start with a simple 2D example of a non-nested list of translated 2D object instances and rotation about the origin.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap33}
\protect\makebox[0ex][r]{\NWtarget{nuweb18a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test04.py"@\nobreak\ {\footnotesize 18a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of non-nested structure with translation and rotations """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@square = larCuboids([1,1])@\\
\mbox{}\verb@table = larApply( t(-.5,-.5) )(square)@\\
\mbox{}\verb@chair = larApply( s(.35,.35) )(table)@\\
\mbox{}\verb@chair1 = larApply( t(.75, 0) )(chair)@\\
\mbox{}\verb@chair2 = larApply( r(PI/2) )(chair1)@\\
\mbox{}\verb@chair3 = larApply( r(PI/2) )(chair2)@\\
\mbox{}\verb@chair4 = larApply( r(PI/2) )(chair3)@\\
\mbox{}\verb@VIEW(SKEL_1(STRUCT(MKPOLS(table)+MKPOLS(chair1)+@\\
\mbox{}\verb@               MKPOLS(chair2)+MKPOLS(chair3)+MKPOLS(chair4))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Local coordinates}
A different composition of transformations, from local to global coordinate frames, is used in the following example.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap34}
\protect\makebox[0ex][r]{\NWtarget{nuweb18b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test05.py"@\nobreak\ {\footnotesize 18b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of non-nested structure with translation and rotations """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@square = larCuboids([1,1])@\\
\mbox{}\verb@square = Model(square,2)@\\
\mbox{}\verb@table = larApply( t(-.5,-.5) )(square)@\\
\mbox{}\verb@chair = larApply( s(.35,.35) )(table)@\\
\mbox{}\verb@chair = larApply( t(.75, 0) )(chair)@\\
\mbox{}\verb@struct = Struct([table] + 4*[chair, r(PI/2)])@\\
\mbox{}\verb@scene = evalStruct(struct)@\\
\mbox{}\verb@VIEW(SKEL_1(STRUCT(CAT(AA(MKPOLS)(scene)))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Call of nested structures by reference}
Finally, a similar 2D example is given, by nesting one (or more) structures via separate definition and call by reference from the interior. Of course, a cyclic set of calls must be avoided, since it would result in a \emph{non acyclic} multigraph of the structure network.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap35}
\protect\makebox[0ex][r]{\NWtarget{nuweb18c}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test06.py"@\nobreak\ {\footnotesize 18c }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Example of nested structures with translation and rotations """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@square = larCuboids([1,1])@\\
\mbox{}\verb@square = Model(square,2)@\\
\mbox{}\verb@table = larApply( t(-.5,-.5) )(square)@\\
\mbox{}\verb@chair = Struct([ t(.75, 0), s(.35,.35), table ])@\\
\mbox{}\verb@struct = Struct( [t(2,1)] + [table] + 4*[r(PI/2), chair])@\\
\mbox{}\verb@scene = evalStruct(struct)@\\
\mbox{}\verb@VIEW(SKEL_1(STRUCT(CAT(AA(MKPOLS)(scene)))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------

%===============================================================================
\section{Computational framework}
%===============================================================================
\subsection{Exporting the library}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap36}
\protect\makebox[0ex][r]{\NWtarget{nuweb19}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"lib/py/mapper.py"@\nobreak\ {\footnotesize 19 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Mapping functions and primitive objects """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Generate a simplicial decomposition ot the $[0,1]^d$ domain\nobreak\ {\footnotesize \NWlink{nuweb2}{2}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Scaled simplicial decomposition ot the $[0,1]^d$ domain\nobreak\ {\footnotesize \NWlink{nuweb3a}{3a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Create a dictionary with key the point location\nobreak\ {\footnotesize \NWlink{nuweb3c}{3c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Primitive mapping function\nobreak\ {\footnotesize \NWlink{nuweb3b}{3b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Basic tests of mapper module\nobreak\ {\footnotesize \NWlink{nuweb20c}{20c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Circle centered in the origin\nobreak\ {\footnotesize \NWlink{nuweb5a}{5a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Disk centered in the origin\nobreak\ {\footnotesize \NWlink{nuweb5b}{5b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Ring centered in the origin\nobreak\ {\footnotesize \NWlink{nuweb5c}{5c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Spherical surface of given radius\nobreak\ {\footnotesize \NWlink{nuweb6b}{6b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Cylinder surface with $z$ axis\nobreak\ {\footnotesize \NWlink{nuweb6a}{6a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Toroidal surface of given radiuses\nobreak\ {\footnotesize \NWlink{nuweb7a}{7a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Half-toroidal surface of given radiuses\nobreak\ {\footnotesize \NWlink{nuweb7b}{7b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Solid box of given extreme vectors\nobreak\ {\footnotesize \NWlink{nuweb8a}{8a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Solid Sphere of given radius\nobreak\ {\footnotesize \NWlink{nuweb8b}{8b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Solid cylinder of given radius and height\nobreak\ {\footnotesize \NWlink{nuweb8c}{8c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Solid torus of given radiuses\nobreak\ {\footnotesize \NWlink{nuweb9b}{9b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Solid pizza of given radiuses\nobreak\ {\footnotesize \NWlink{nuweb9c}{9c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Hollow cylinder of given radiuses and height\nobreak\ {\footnotesize \NWlink{nuweb8d}{8d}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Hollow sphere of given radiuses\nobreak\ {\footnotesize \NWlink{nuweb9a}{9a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Translation matrices\nobreak\ {\footnotesize \NWlink{nuweb11a}{11a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Scaling matrices\nobreak\ {\footnotesize \NWlink{nuweb11b}{11b}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Rotation matrices\nobreak\ {\footnotesize \NWlink{nuweb11c}{11c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Embedding and projecting a geometric model\nobreak\ {\footnotesize \NWlink{nuweb4}{4}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Apply an affine transformation to a LAR model\nobreak\ {\footnotesize \NWlink{nuweb10}{10}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Traversal of a scene multigraph\nobreak\ {\footnotesize \NWlink{nuweb17a}{17a}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------
%===============================================================================
\subsection{Examples}
%===============================================================================

\paragraph{3D rotation about a general axis}
The approach used by \texttt{lar-cc} to specify a general 3D rotation is shown in the following example,
by passing the rotation function \texttt{r} the components \texttt{a,b,c} of the unit vector \texttt{axis} scaled by the rotation \texttt{angle}. 

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap37}
\protect\makebox[0ex][r]{\NWtarget{nuweb20a}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test02.py"@\nobreak\ {\footnotesize 20a }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" General 3D rotation of a toroidal surface """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@model = checkModel(larToroidal([0.2,1])())@\\
\mbox{}\verb@angle = PI/2; axis = UNITVECT([1,1,0])@\\
\mbox{}\verb@a,b,c = SCALARVECTPROD([ angle, axis ])@\\
\mbox{}\verb@model = larApply(r(a,b,c))(model)@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------


\paragraph{3D elementary rotation of a 2D circle}
A simpler specification is needed when the 3D rotation is about a coordinate axis. In this case the rotation angle can be directly given as the unique non-zero parameter of the the rotation function \texttt{r}. The rotation axis (in this case the $x$ one) is specified by the non-zero (angle) position.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap38}
\protect\makebox[0ex][r]{\NWtarget{nuweb20b}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test03.py"@\nobreak\ {\footnotesize 20b }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Elementary 3D rotation of a 2D circle """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@model = checkModel(larCircle(1)())@\\
\mbox{}\verb@model = larEmbed(1)(model)@\\
\mbox{}\verb@model = larApply(r(PI/2,0,0))(model)@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------




%===============================================================================
\subsection{Tests about domain}
%===============================================================================

\paragraph{Mapping domains}
The generations of mapping domains of different dimension (1D, 2D, 3D) is shown below.
	
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap39}
\protect\makebox[0ex][r]{\NWtarget{nuweb20c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Basic tests of mapper module\nobreak\ {\footnotesize 20c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@if __name__=="__main__":@\\
\mbox{}\verb@   V,EV = larDomain([5])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,EV))))@\\
\mbox{}\verb@   V,EV = larIntervals([24])([2*PI])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,EV))))@\\
\mbox{}\verb@      @\\
\mbox{}\verb@   V,FV = larDomain([5,3])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,FV))))@\\
\mbox{}\verb@   V,FV = larIntervals([36,3])([2*PI,1.])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,FV))))@\\
\mbox{}\verb@      @\\
\mbox{}\verb@   V,CV = larDomain([5,3,1])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,CV))))@\\
\mbox{}\verb@   V,CV = larIntervals([36,2,3])([2*PI,1.,1.])@\\
\mbox{}\verb@   VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,CV))))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Testing some primitive object generators}
The various model generators given in Section~\ref{sec:generators} are tested here, including LAR 2D circle, disk, and ring, as well as the 3D cylinder, sphere, and toroidal surfaces, and the solid objects ball, rod, crown, pizza, and torus.

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap40}
\protect\makebox[0ex][r]{\NWtarget{nuweb21}{\rule{0ex}{0ex}}\hspace{1em}}\verb@"test/py/mapper/test01.py"@\nobreak\ {\footnotesize 21 }$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" Circumference of unit radius """@\\
\mbox{}\verb@@\hbox{$\langle\,$Initial import of modules\nobreak\ {\footnotesize \NWlink{nuweb22c}{22c}}$\,\rangle$}\verb@@\\
\mbox{}\verb@from mapper import *@\\
\mbox{}\verb@model = larCircle(1)()@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(model)))@\\
\mbox{}\verb@model = larDisk(1)([36,4])@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(model)))@\\
\mbox{}\verb@model = larRing(.9, 1.)([36,2])@\\
\mbox{}\verb@VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS(model)))@\\
\mbox{}\verb@model = larCylinder(.5,2.)([32,1])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larSphere(1,PI/6,PI/4)([6,12])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larBall(1)()@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larRod(.25,2.)([32,1])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larToroidal(0.5,2)()@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larCrown(0.125,1)([8,48])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larPizza(0.05,1,PI/3)([8,48])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larTorus(0.5,1)()@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larBox([-1,-1,-1],[1,1,1])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larHollowCyl(0.8,1,1,angle=PI/4)([12,2,2])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@model = larHollowSphere(0.8,1,PI/6,PI/4)([6,12,2])@\\
\mbox{}\verb@VIEW(STRUCT(MKPOLS(model)))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-2ex}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Volumetric utilities}


\paragraph{Limits of a LAR Model}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap41}
\protect\makebox[0ex][r]{\NWtarget{nuweb22a}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Model limits\nobreak\ {\footnotesize 22a}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larLimits (model):@\\
\mbox{}\verb@   if isinstance(model,tuple): @\\
\mbox{}\verb@      V,CV = model@\\
\mbox{}\verb@      verts = scipy.asarray(V)@\\
\mbox{}\verb@   else: verts = model.verts@\\
\mbox{}\verb@   return scipy.amin(verts,axis=0).tolist(), scipy.amax(verts,axis=0).tolist()@\\
\mbox{}\verb@   @\\
\mbox{}\verb@assert larLimits(larSphere()()) == ([-1.0, -1.0, -1.0], [1.0, 1.0, 1.0])@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

\paragraph{Alignment}
%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap42}
\protect\makebox[0ex][r]{\NWtarget{nuweb22b}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Alignment primitive\nobreak\ {\footnotesize 22b}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@def larAlign (args):@\\
\mbox{}\verb@   def larAlign0 (args,pols):@\\
\mbox{}\verb@      pol1, pol2 = pols@\\
\mbox{}\verb@      box1, box2 = (larLimits(pol1), larLimits(pol2))@\\
\mbox{}\verb@      print "box1, box2 =",(box1, box2)@\\
\mbox{}\verb@      @\\
\mbox{}\verb@   return larAlign0@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%===============================================================================
\appendix
\section{Utility functions}
%===============================================================================



def FLATTEN( pol )
	temp = Plasm.shrink(pol,True)
	hpcList = []
	for I in range(len(temp.childs)):			
		g,vmat, hmat = temp.childs[I].g,temp.childs[I].vmat, temp.childs[I].hmat
		g.embed(vmat. dim)
		g.transform(vmat, hmat)
		hpcList += [Hpc(g)]
	return hpcList
	
VIEW(STRUCT( FLATTEN(pol) ))


%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap43}
\protect\makebox[0ex][r]{\NWtarget{nuweb22c}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Initial import of modules\nobreak\ {\footnotesize 22c}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@from pyplasm import *@\\
\mbox{}\verb@from scipy import *@\\
\mbox{}\verb@import os,sys@\\
\mbox{}\verb@@\\
\mbox{}\verb@""" import modules from larcc/lib """@\\
\mbox{}\verb@sys.path.insert(0, 'lib/py/')@\\
\mbox{}\verb@@\hbox{$\langle\,$Import the module\nobreak\ ({\footnotesize \NWtarget{nuweb22d}{22d}\label{scrap44}
 }\mbox{}\verb@lar2psm@ ) {\footnotesize \NWlink{nuweb23e}{23e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Import the module\nobreak\ ({\footnotesize \NWtarget{nuweb23a}{23a}\label{scrap45}
 }\mbox{}\verb@simplexn@ ) {\footnotesize \NWlink{nuweb23e}{23e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Import the module\nobreak\ ({\footnotesize \NWtarget{nuweb23b}{23b}\label{scrap46}
 }\mbox{}\verb@larcc@ ) {\footnotesize \NWlink{nuweb23e}{23e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Import the module\nobreak\ ({\footnotesize \NWtarget{nuweb23c}{23c}\label{scrap47}
 }\mbox{}\verb@largrid@ ) {\footnotesize \NWlink{nuweb23e}{23e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,$Import the module\nobreak\ ({\footnotesize \NWtarget{nuweb23d}{23d}\label{scrap48}
 }\mbox{}\verb@boolean2@ ) {\footnotesize \NWlink{nuweb23e}{23e}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb18a}{18a}\NWlink{nuweb18b}{b}\NWlink{nuweb18c}{c}\NWlink{nuweb19}{, 19}\NWlink{nuweb20a}{, 20a}\NWlink{nuweb20b}{b}\NWlink{nuweb21}{, 21}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\begin{flushleft} \small \label{scrap49}
\protect\makebox[0ex][r]{\NWtarget{nuweb23e}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Import the module\nobreak\ {\footnotesize 23e}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@import @@1\verb@@\\
\mbox{}\verb@from @@1\verb@ import *@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22c}{22c}.
\end{list}
\end{flushleft}
%-------------------------------------------------------------------------------


\subsection{Numeric utilities}

A small set of utilityy functions is used to transform a point representation as array of coordinates into a string of fixed format to be used as point key into python dictionaries.

%------------------------------------------------------------------
\begin{flushleft} \small \label{scrap50}
\protect\makebox[0ex][r]{\NWtarget{nuweb23f}{\rule{0ex}{0ex}}\hspace{1em}}$\langle\,$Symbolic utility to represent points as strings\nobreak\ {\footnotesize 23f}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@""" TODO: @\\
\mbox{}\verb@use Decimal (http://docs.python.org/2/library/decimal.html) @\\
\mbox{}\verb@"""@\\
\mbox{}\verb@ROUND_ZERO = 1E-07@\\
\mbox{}\verb@def round_or_zero (x,prec=7):@\\
\mbox{}\verb@   """@\\
\mbox{}\verb@   Decision procedure to approximate a small number to zero.@\\
\mbox{}\verb@   Return either the input number or zero.@\\
\mbox{}\verb@   """@\\
\mbox{}\verb@   def myround(x):@\\
\mbox{}\verb@      return eval(('%.'+str(prec)+'f') % round(x,prec))@\\
\mbox{}\verb@   xx = myround(x)@\\
\mbox{}\verb@   if abs(xx) < ROUND_ZERO: return 0.0@\\
\mbox{}\verb@   else: return xx@\\
\mbox{}\verb@@\\
\mbox{}\verb@def prepKey (args): return "["+", ".join(args)+"]"@\\
\mbox{}\verb@@\\
\mbox{}\verb@def fixedPrec(value):@\\
\mbox{}\verb@   if abs(value - int(value))<ROUND_ZERO: value = int(value)@\\
\mbox{}\verb@   out = ('%0.7f'% value).rstrip('0')@\\
\mbox{}\verb@   if out == '-0.': out = '0.'@\\
\mbox{}\verb@   return out@\\
\mbox{}\verb@   @\\
\mbox{}\verb@def vcode (vect): @\\
\mbox{}\verb@   """@\\
\mbox{}\verb@   To generate a string representation of a number array.@\\
\mbox{}\verb@   Used to generate the vertex keys in PointSet dictionary, and other @\\
\mbox{}\verb@   similar operations.@\\
\mbox{}\verb@   """@\\
\mbox{}\verb@   return prepKey(AA(fixedPrec)(vect))@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1ex}
\footnotesize\addtolength{\baselineskip}{-1ex}
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.
\end{list}
\end{flushleft}
%------------------------------------------------------------------


\bibliographystyle{amsalpha}
\bibliography{mapper}

\end{document}
