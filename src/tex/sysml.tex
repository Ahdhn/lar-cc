\documentclass[11pt,oneside]{article}	%use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}		%Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}		%...ora4paperora5paperor...
%\geometry{landscape}		%Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}		%Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}				%Usepdf,png,jpg,orepsÃŸwithpdflatex;useepsinDVImode
								%TeXwillautomaticallyconverteps-->pdfinpdflatex		
\usepackage{amssymb}
\usepackage[colorlinks]{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{Modeling Geometry with Assemblies in SysML
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
%\author{TheAuthor}
%\date{}							%Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\begin{abstract}
In this module a preliminary concept implementation is provided for the possible introduction of a novel kind of 3D diagram in SysML. Such ``Assembly" Diagram in used to specify an operable description of the 3D geometry of a system part.
\end{abstract}

\tableofcontents

%===============================================================================
\section{Introduction}
%===============================================================================
%-------------------------------------------------------------------------------
\subsection{bbbbbbbb}
%-------------------------------------------------------------------------------
%===============================================================================
\section{Implementation}
%===============================================================================
%-------------------------------------------------------------------------------
\subsection{Diagram initialization}
%-------------------------------------------------------------------------------

\paragraph{Uniform cell sizing}

A cuboidal 3-complex is generated by the script below, where the cells have uniform dimension on each coordinate direction. 

%-------------------------------------------------------------------------------
@D Diagram initialization
@{""" Diagram initialization """
def assemblyDiagramInit(shape):
	print "\n shape =",shape
	# shape must be 3D, i.e. a python array with 3 indices
	assert len(shape) == 3
	diagram = larCuboids(shape)
	return diagram
@}
%-------------------------------------------------------------------------------

\paragraph{Non-uniform cell sizing}

The parameter \texttt{quoteList} is used here to generate the new vertices of the \texttt{diagram}, previously generated with uniform spacing between the cell vertices in every coordinate direction.
Each \texttt{pattern} in \texttt{quoteList} is a list of positive numbers, each corresponding to the size of the corresponding "coordinate stripe".

%-------------------------------------------------------------------------------
@D Diagram initialization (non-uniform sizing)
@{""" Diagram initialization """
def assemblyDiagramInit (shape):
	def assemblyDiagram (quoteList):
		print "\n shape =",shape
		# shape and quoteList must be 3D, i.e. a python array with 3 indices
		assert (len(shape) == 3) and (len(quoteList) == 3)
		coordList = [list(cumsum([0]+pattern)) for pattern in quoteList]
		verts = CART(coordList)
		_,CV = larCuboids(shape)
		return verts,CV
	return assemblyDiagram
@}
%-------------------------------------------------------------------------------


\paragraph{Diagram scaling to cuboid of given size}
The \texttt{size} parameter is the array of lateral dimensions to which to scale the 
\texttt{diagram} parameter. \texttt{size} must be an array of 3 numbers; \texttt{diagram} is
a LAR model

%-------------------------------------------------------------------------------
@D Diagram scaling to sized cuboid
@{""" Diagram scaling to given size """
def unitDiagram(diagram, size=[1,1,1]):
	V,CV = diagram
	print "\n shape =",shape
	# size must be a python array with 3 numbers
	assert (len(size) == 3) and (AND(AA(ISNUM)(size)) == True)
	V_ = array(V) / AA(float)(max(V))
	V = (V_ * size).tolist()
	diagram = V,CV
	return diagram
@}
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
\subsection{Diagram segmentation}
%-------------------------------------------------------------------------------

\paragraph{Boundary cells ($3D\to 2D$) computation}
The computations of boundary cells is executed by calling the \texttt{boundaryCells} from the \texttt{larcc} module.

%-------------------------------------------------------------------------------
@D Boundary cells ($3D\to 2D$) computation
@{def lar2boundaryFaces(CV,FV):
	""" Boundary cells computation """
	return boundaryCells(CV,FV)
@}
%-------------------------------------------------------------------------------

\paragraph{Interior partitions ($3D\to 2D$) computation}
The indices of the boundary 2-cells are returned in \texttt{boundarychain2D}, and subtracted from the set $\{0,1,\ldots,|E|-1\}$ in order to return the indices of the \texttt{interiorCells}.
%-------------------------------------------------------------------------------
@D Interior partitions ($3D\to 2D$) computation
@{def lar2InteriorFaces(CV,FV):
	""" Boundary cells computation """
	boundarychain2D = boundaryCells(CV,FV)
	totalChain2D = range(len(FV))
	interiorCells = set(totalChain2D).difference(boundarychain2D)
	return interiorCells
@}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\subsection{Subdiagram mapping}
%-------------------------------------------------------------------------------

The aim of this section is to allow for separate development of subdiagrams of a geometric diagram.
When satisfied with the current design situation,  the developer may map a whole diagram into a single 3D cell of the upper-level diagram --- in the following called the \emph{master} diagram.
Of course, such nesting may happen several times within a (father) master, producing a hierarchical decomposition (of any depth) of the geometry diagrams.


\paragraph{Task decomposition}
The procedure to map a diagram to a sub diagram is described below in a top-down manner,
decomposing the task into an ordered set of subtasks.


The \texttt{diagram2cell} functions below works as follows.  Its job is to map the LAR model \texttt{diagram} (semantically a 3-array of cuboidal blocks) onto the 3D-cell of the \texttt{master} LAR model (another 3-array of cuboidal blocks), indexed by the integer \texttt{cell} parameter. In few words: mapping \texttt{diagram} onto the given \texttt{cell} of \texttt{master}.

First, the matrix \texttt{mat}of this 3D-window to 3D-viewport transformation is computed, by invoking \texttt{diagram2cellMatrix}. Then, the \texttt(mat) transformation is applied to \texttt{vertices}.
Then both such LAR models are passed as parameters of the \texttt{vertexSieve} function, that returns a single vertex list \texttt{V}, two (reindexed) lists \texttt{CV1} and \texttt{CV2}, and the number \texttt{n12} of common vertices.


We can look at their common incidence matrix as shown in Figure~\ref{}.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.4\linewidth]{images/merge} 
   \caption{Structure of the characteristic matrix $M(CV)$ afre the merge of two LAR models, and identification of the common vertices.}
   \label{fig:example}
\end{figure}

%-------------------------------------------------------------------------------
@D Subdiagram to diagram mapping
@{
@< 3D window to viewport transformation @>

def diagram2cell(diagram,master,cell):
	mat = diagram2cellMatrix(diagram)(master,cell)
	diagram =larApply(mat)(diagram)	
	(V1,CV1),(V2,CV2) = master,diagram
	n1,n2 = len(V1), len(V2)
	
	# identification of common vertices
	V, CV1, CV2, n12 = vertexSieve(master,diagram)
	commonRange = range(n1-n12, n1)
	newRange = range(n1,n1-n12+n2)
	
	# addition of incident vertices into the adjacents of theCell
	def checkInclusion(V,theCell,newRange):
		theVerts = [V[v] for v in theCell]
		theMin, theMax = min(theVerts), max(theVerts)
		theCell += [v for v in newRange if (
			theMin[0] <= V[v][0] and theMin[1] <= V[v][1] and theMin[2] <= V[v][2] 
			and 
			V[v][0] <= theMax[0] and V[v][1] <= theMax[1] and V[v][2] <= theMax[2] 
			)]
		return theCell
	
	# addition of new vertices into the adjacents of cell c
	CV1 = [checkInclusion(V,c,newRange) 
			if set(c).intersection(commonRange) != set() else c
			 for c in CV1]
	
	# masterBoundaryFaces = boundaryOfChain(CV,FV)([cell])
	# diagramBoundaryFaces = lar2boundaryFaces(CV,FV)
	CV = [c for k,c in enumerate(CV1) if k != cell] + CV2
	
	master = V, CV
	return master
@}
%-------------------------------------------------------------------------------


\paragraph{3D window to viewport transformation}
%-------------------------------------------------------------------------------
@D 3D window to viewport transformation
@{""" 3D window to viewport transformation """
def diagram2cellMatrix(diagram):
	def diagramToCellMatrix0(master,cell):
		wdw = min(diagram[0]) + max(diagram[0])			# window3D
		cV = [master[0][v] for v in master[1][cell]]
		vpt = min(cV) + max(cV)								# viewport3D
		print "\n window3D =",wdw
		print "\n viewport3D =",vpt
		
		mat = zeros((4,4))
		mat[0,0] = (vpt[3]-vpt[0])/(wdw[3]-wdw[0])
		mat[0,3] = vpt[0] - mat[0,0]*wdw[0]
		mat[1,1] = (vpt[4]-vpt[1])/(wdw[4]-wdw[1])
		mat[1,3] = vpt[1] - mat[1,1]*wdw[1]
		mat[2,2] = (vpt[5]-vpt[2])/(wdw[5]-wdw[2])
		mat[2,3] = vpt[2] - mat[2,2]*wdw[2]
		mat[3,3] = 1
		print "\n mat =",mat
		return mat
	return diagramToCellMatrix0
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
%===============================================================================
\section{Topological consistency}
%===============================================================================
%-------------------------------------------------------------------------------

When a 3D diagram is generated as a Cartesian product of 1D complexes, it is relatively easy to 
compute its cells of any dimension. For this purpose, see the the module \texttt{largrid}
and/or the function \texttt{gridSkeletons(shape)}, that returns the list of skeletons 
generated by the cellular complex of a given \texttt{shape}.

Two different strategies may be used to guarantee the correctness of topology after
local refinements, that provide a replacement of single cells with subdivided complexes. Such two 
strategies are 
discussed and developed in the next two subsections.

%-------------------------------------------------------------------------------
\subsection{Decomposition of the whole space}
%-------------------------------------------------------------------------------
As already coped with in module \texttt{larcc}, the facets, i.e.~the ($d-1$)-faces, 
of a cellular $d$-complex may be easily computed using the product of the sparse 
characteristic matrix $M_d$ times its transpose $M_d^t$. It is easy to see that 
each element $a_{ij}$ of 
\[
A_d = M_d\, M_d^t = (a_{ij})
\] 
provides the number of common vertices between the $d$-face $\gamma_i$ and the 
$d$-face $\gamma_j$. When this number is greater or equal than $d$, there is a common
$(d-1)$-face shared between $\gamma_i$ and $\gamma_j$.

In order to guarantee that all $(d-1)$-faces can be discovered by this method, a 
cellular decomposition of the whole $\E^d$ must be maintained, including both \emph{solid} cells,
i.e.~the decomposition of the interior space, and \emph{empty} cells, corresponding to a 
decomposition of the exterior space.

\paragraph{Exterior space of a block diagram}

%-------------------------------------------------------------------------------
@D Exterior space of a block diagram
@{""" Exterior space of a block diagram """
def exteriorCells(diagram):
	V,CV = diagram
	minVert, maxVert = min(V), max(V)
	d = len(V[0])
	outchain = [[] for k in range(2*d)]
	for k,v in enumerate(V):
		for h in range(d):
			if v[h] == minVert[h]: outchain[h] += [k]
			if v[h] == maxVert[h]: outchain[h+d] += [k]
	return outchain
@}
%-------------------------------------------------------------------------------

The aim of computing che chain of exterior cells is associated to the computation of 
of the $(d-1)$-skeleton, in turn needed for the computation of the boundary and coboundary operators.
Look to Section~\ref{sec:exterior} for a worked example.



%-------------------------------------------------------------------------------
\subsection{Promoting local upgrades in all dimensions}
%-------------------------------------------------------------------------------



%===============================================================================
\section{Library export}
%===============================================================================
%-------------------------------------------------------------------------------
\subsection{Exporting the library}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O larlib/larlib/sysml.py
@{""" sysml library """
from larlib import *
DRAW = COMP([VIEW,STRUCT,MKPOLS])

@< To compute the boundary (d-1)-chain of a given d-chain @>
@< Diagram initialization (non-uniform sizing) @>
@< Boundary cells ($3D\to 2D$) computation @>
@< Interior partitions ($3D\to 2D$) computation @>
@< Diagram scaling to sized cuboid @>
@< Drawing numbers of cells @>
@< Subdiagram to diagram mapping @>
@< Exterior space of a block diagram @>
@< Place vertices of two LAR models in a common space @>
@}
%-------------------------------------------------------------------------------

%===============================================================================
\section{Tests}
%===============================================================================
%-------------------------------------------------------------------------------
\subsection{Diagram initialization}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/sysml/test01.py
@{""" testing initial steps of Assembly Diagram construction """
from larlib import *

shape = [1,2,2]
sizePatterns = [[1],[2,1],[0.8,0.2]]
diagram = assemblyDiagramInit(shape)(sizePatterns)
print "\n diagram =",diagram
VIEW(SKEL_1(STRUCT(MKPOLS(diagram))))

VV,EV,FV,CV = gridSkeletons(shape)
boundaryFaces = lar2boundaryFaces(CV,FV)
interiorFaces = list(set(range(len(FV))).difference(boundaryFaces))
print "\n boundary faces =",boundaryFaces
print "\n interior faces =",interiorFaces
diagram1 = unitDiagram(diagram)
VIEW(SKEL_1(STRUCT(MKPOLS(diagram1))))

hpc = SKEL_1(STRUCT(MKPOLS(diagram1)))
V = diagram1[0]
hpc = cellNumbering((V,FV),hpc)(interiorFaces,YELLOW,.5)
VIEW(hpc)
hpc = cellNumbering((V,EV),hpc)([f for f in interiorFaces],GREEN,.4)
VIEW(hpc)
hpc = cellNumbering((V,VV),hpc)(range(len(VV)),RED,.3)
VIEW(hpc)

@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{Diagram merging}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/sysml/test02.py
@{""" definition and merging of two diagrams into a single diagram """
from larlib import *

master = assemblyDiagramInit([2,2,2])([[.4,.6],[.4,.6],[.4,.6]])
diagram = assemblyDiagramInit([3,3,3])([[.4,.2,.4],[.4,.2,.4],[.4,.2,.4]])
VIEW(SKEL_1(STRUCT([DRAW(master),T(2)(1),DRAW(diagram)])))

hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),WHITE,.5)
VIEW(hpc)

master = diagram2cell(diagram,master,7)
VIEW(SKEL_1(STRUCT( MKPOLS(master) )))

@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{Diagram visualization}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
@O test/py/sysml/test03.py
@{""" definition and merging of two diagrams into a single diagram """
from larlib import *

master = assemblyDiagramInit([2,2,2])([[.4,.6],[.4,.6],[.4,.6]])
diagram = assemblyDiagramInit([3,3,3])([[.4,.2,.4],[.4,.2,.4],[.4,.2,.4]])

VV,EV,FV,CV = gridSkeletons([2,2,2])
V,CV = master
hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(CV)),CYAN,.5)
VIEW(hpc)

master = diagram2cell(diagram,master,7)
VIEW(SKEL_1(STRUCT( MKPOLS(master) )))

VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS(larFacets(master))))

masterBoundaryFaces = boundaryOfChain(CV,FV)([7])
diagramBoundaryFaces = lar2boundaryFaces(CV,FV)
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/mastermerged} 
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/masterfacets} 
   \caption{Example of a geometry diagram merged in a master diagram}
   \label{fig:mastermerged}
\end{figure}

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig2} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig4} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig5} 

   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig6} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig7} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig8} 

   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig9} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig10} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig11} 

   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig12} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig13} 
   \includegraphics[height=0.3\linewidth,width=0.3\linewidth]{images/fig14} 

   \caption{The construction process of the \texttt{master} block diagram built by the example \texttt{test/py/sysml/test4.py} of Section~\ref{sec:master}.}
   \label{fig:master}
\end{figure}

%-------------------------------------------------------------------------------
\subsection{progressive refinement of a block diagram}
\label{sec:master}
%-------------------------------------------------------------------------------

In this example, a step-by step generation of a simple apartment is produced, using 
\texttt{assemblyDiagramInit} to produce a block diagram of given \texttt{shape} and 
\texttt{size}, the \texttt{cellNumbering} function to generate an \emph{hpc} value
with the numbers of 3-cells in the current "master" diagram, the \texttt{diagram2cell}
function to map and merge a \texttt{diagram} into a \texttt{cell} of the \texttt{master}.

The construction process is visualised in Figure~\ref{fig:master}.

Remember that in \texttt{lar-cc} the numbering of cells in a model is 0-based (like
in python). Conversely, in \texttt{pyplasm} the numbering of cells (for example of 
vertex indices in \texttt{MKPOL}) is 1-based, like in Fortran or MATLAB.   

%-------------------------------------------------------------------------------
@O test/py/sysml/test04.py
@{""" progressive refinement of a block diagram """
from larlib import *

master = assemblyDiagramInit([5,5,2])([[.3,3.2,.1,5,.3],[.3,4,.1,2.9,.3],[.3,2.7]])
V,CV = master
hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(CV)),CYAN,2)
VIEW(hpc)

toRemove = [13,33,17,37]
master = V,[cell for k,cell in enumerate(CV) if not (k in toRemove)]
DRAW(master)

hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)

toMerge = 29
cell = MKPOL([master[0],[[v+1 for v in  master[1][toMerge]]],None])
VIEW(STRUCT([hpc,cell]))

diagram = assemblyDiagramInit([3,1,2])([[2,1,2],[.3],[2.2,.5]])
master = diagram2cell(diagram,master,toMerge)
hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)

toRemove = [47]
master = master[0], [cell for k,cell in enumerate(master[1]) if not (k in toRemove)]
DRAW(master)

hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)

toMerge = 34
cell = MKPOL([master[0],[[v+1 for v in  master[1][toMerge]]],None])
VIEW(STRUCT([hpc,cell]))

diagram = assemblyDiagramInit([5,1,3])([[1.5,0.9,.2,.9,1.5],[.3],[1,1.4,.3]])
master = diagram2cell(diagram,master,toMerge)
hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)

toRemove = [53,59]
master = master[0], [cell for k,cell in enumerate(master[1]) if not (k in toRemove)]
DRAW(master)
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{Using the cochain of exterior cells}
\label{sec:exterior}
%-------------------------------------------------------------------------------

Here we develop the same example \texttt{} given above, but using also a cochain of empty cells,
in order to be able to extract the boundary and coboundary operators of the cell decompositions. 
The \texttt{exteriorChain}
of the \texttt{master} diagram is first computed after the \texttt{master} initialisation, and later updated with cells defined as empty

%-------------------------------------------------------------------------------
@O test/py/sysml/test05.py
@{""" boundary extraction of a block diagram """
from larlib import *

DRAW = COMP([VIEW,STRUCT,MKPOLS])

master = assemblyDiagramInit([5,5,2])([[.3,3.2,.1,5,.3],[.3,4,.1,2.9,.3],[.3,2.7]])
diagram1 = assemblyDiagramInit([3,1,2])([[2,1,2],[.3],[2.2,.5]])
diagram2 = assemblyDiagramInit([5,1,3])([[1.5,0.9,.2,.9,1.5],[.3],[1,1.4,.3]])

hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)
 
master = diagram2cell(diagram2,master,39)
master = diagram2cell(diagram1,master,31)

hpc = SKEL_1(STRUCT(MKPOLS(master)))
hpc = cellNumbering (master,hpc)(range(len(master[1])),CYAN,2)
VIEW(hpc)

emptyChain = [17,13,32,36,52,58,65]
solidCV = [cell for k,cell in enumerate(master[1]) if not (k in emptyChain)]
DRAW((master[0],solidCV))

exteriorCV =  [cell for k,cell in enumerate(master[1]) if k in emptyChain]
exteriorCV += exteriorCells(master)
CV = solidCV + exteriorCV
V = master[0]
FV = [f for f in larFacets((V,CV),3,len(exteriorCV))[1] if len(f) >= 4]
VIEW(EXPLODE(1.5,1.5,1.5)(MKPOLS((V,FV))))

BF = boundaryCells(solidCV,FV)
boundaryFaces = [FV[face] for face in BF]
B_Rep = V,boundaryFaces
VIEW(EXPLODE(1.1,1.1,1.1)(MKPOLS(B_Rep)))
VIEW(STRUCT(MKPOLS(B_Rep)))

@< Transform the LAR boundary model in a triangle model @>
@}
%-------------------------------------------------------------------------------

\paragraph{Transform the LAR boundary model in a triangles model}
The transformation from a boundary representation made by general 2D convex faces to a set of triangle faces is provided below.

%-------------------------------------------------------------------------------
@D Transform the LAR boundary model in a triangle model
@{
verts, triangles = quads2tria(B_Rep)
B_Rep = V,boundaryFaces
VIEW(EXPLODE(1.1,1.1,1.1)(MKPOLS((verts, triangles))))
VIEW(STRUCT(MKPOLS((verts, triangles))))
@}
@}
%-------------------------------------------------------------------------------


%===============================================================================
\appendix
\section{Utilities}
%===============================================================================

%-------------------------------------------------------------------------------
@D To compute the boundary (d-1)-chain of a given d-chain
@{
def boundaryOfChain(cells,facets):
	csrBoundaryMat = boundary(cells,facets)
	csrChain = zeros((len(cells),1))
	def boundaryOfChain0(chain):
		for cell in chain:  csrChain[cell,0]=1.0
		csrBoundaryChain = matrixProduct(csrBoundaryMat, csrChain)
		boundaryCells = [k for k,val in enumerate(csrBoundaryChain.tolist()) 
							if val == [1.0]]
		return boundaryCells
	return boundaryOfChain0
@}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\subsection{Initial import of modules}
%-------------------------------------------------------------------------------

\paragraph{Initial import of modules}

%-------------------------------------------------------------------------------
@D Initial import of modules
@{""" Initial import of modules """
from lar2psm import *
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{Reordering of vertex coordinates}
%-------------------------------------------------------------------------------

A global reordering of vertex coordinates is executed as the first step of the Boolean algorithm, in order to eliminate the duplicate vertices, by substituting duplicate vertex copies (coming from two close points) with a single instance. 

Two dictionaries are created, then merged in a single dictionary, and finally split into three subsets of (vertex,index) pairs, with the aim of rebuilding the input representations, by making use of a novel and more useful vertex indexing.

The union set of vertices is finally reordered using the three subsets of vertices belonging (a) only to the first argument, (b) only to the second argument and (c) to both, respectively denoted as $V_1, V_2, V_{12}$. A top-down description of this initial computational step is provided by the set of macros discussed in this section.

%-------------------------------------------------------------------------------
@D Place vertices of two LAR models in a common space
@{""" Place vertices of two LAR models in a common space """
@< Initial indexing of vertex positions @>
@< Merge two dictionaries with keys the point locations @>
@< Filter the common dictionary into three subsets @>
@< Compute an inverted index to reorder the vertices of arguments @>
@< Return the single reordered pointset and the two $d$-cell arrays @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsubsection{Re-indexing of vertices}
%-------------------------------------------------------------------------------

\paragraph{Initial indexing of vertex positions}
The input LAR models are located in a common space by (implicitly) joining \texttt{V1} and \texttt{V2} in a same array, and (explicitly) shifting the vertex indices in \texttt{CV2} by the length of \texttt{V1}.
%-------------------------------------------------------------------------------
@D Initial indexing of vertex positions
@{from collections import defaultdict, OrderedDict

def vertexSieve(model1, model2):
	V1,CV1 = model1; V2,CV2 = model2
	n = len(V1); m = len(V2)
	def shift(CV, n): 
		return [[v+n for v in cell]for cell in CV]
	CV2 = shift(CV2,n)
@}
%-------------------------------------------------------------------------------

\paragraph{Merge two dictionaries with point location as keys}
Since currently \texttt{CV1} and \texttt{CV2} point to a set of vertices larger than their initial sets 
\texttt{V1} and \texttt{V2}, we index the set $\texttt{V1} \cup \texttt{V2}$ using a Python \texttt{defaultdict} dictionary, in order to avoid errors of "missing key". As dictionary keys, we use the string representation of the vertex position vector provided by the \texttt{vcode} function given in the Appendix.
%-------------------------------------------------------------------------------
@D Merge two dictionaries with keys the point locations
@{
	vdict1 = defaultdict(list)
	for k,v in enumerate(V1): vdict1[vcode(v)].append(k) 
	vdict2 = defaultdict(list)
	for k,v in enumerate(V2): vdict2[vcode(v)].append(k+n) 
	
	vertdict = defaultdict(list)
	for point in vdict1.keys(): vertdict[point] += vdict1[point]
	for point in vdict2.keys(): vertdict[point] += vdict2[point]
@}
%-------------------------------------------------------------------------------

\paragraph{Example of string coding of a vertex position}
The position vector of a point of real coordinates is provided by the function \texttt{vcode}.
An example of coding is given below. The \emph{precision} of the string representation can be tuned at will.
{\small
\begin{verbatim}
>>> vcode([-0.011660381062724849, 0.297350056848685860])
'[-0.0116604, 0.2973501]'
\end{verbatim}}



\paragraph{Filter the common dictionary into three subsets}
\texttt{Vertdict}, dictionary of vertices, uses as key stye position vectors of vertices coded as string, and as values the list of integer indices of vertices on the given position. If the point position belongs either to the first or to second argument only, it is stored in \texttt{case1} or \texttt{case2} lists respectively. If the position (\texttt{item.key}) is shared between two vertices, it is stored in \texttt{case12}.
The variables \texttt{n1}, \texttt{n2}, and \texttt{n12} remember the number of vertices respectively stored in each repository.
%-------------------------------------------------------------------------------
@D Filter the common dictionary into three subsets
@{
	case1, case12, case2 = [],[],[]
	for item in vertdict.items():
		key,val = item
		if len(val)==2:  case12 += [item]
		elif val[0] < n: case1 += [item]
		else: case2 += [item]
	n1 = len(case1); n2 = len(case12); n3 = len(case2)
@}
%-------------------------------------------------------------------------------

\paragraph{Compute an inverted index to reorder the vertices of Boolean arguments}
The new indices of vertices are computed according with their position within the storage repositories \texttt{case1}, \texttt{case2}, and \texttt{case12}. Notice that every \texttt{item[1]} stored in \texttt{case1} or \texttt{case2} is a list with only one integer member. Two such values are conversely stored in each \texttt{item[1]} within \texttt{case12}.
%-------------------------------------------------------------------------------
@D Compute an inverted index to reorder the vertices of arguments
@{
	invertedindex = list(0 for k in range(n+m))
	for k,item in enumerate(case1):
		invertedindex[item[1][0]] = k
	for k,item in enumerate(case12):
		invertedindex[item[1][0]] = k+n1
		invertedindex[item[1][1]] = k+n1
	for k,item in enumerate(case2):
		invertedindex[item[1][0]] = k+n1+n2
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsubsection{Re-indexing of d-cells}
%-------------------------------------------------------------------------------

\paragraph{Return the single reordered pointset and the two $d$-cell arrays}
We are now finally ready to return two reordered LAR models defined over the same set \texttt{V} of vertices, and where (a) the vertex array \texttt{V} can be written as the union of three disjoint sets of points $C_1,C_{12},C_2$; (b) the $d$-cell array \texttt{CV1} is indexed over $C_1\cup C_{12}$; (b) the $d$-cell array \texttt{CV2} is indexed over $C_{12}\cup C_{2}$. 

The \texttt{vertexSieve} function will return the new reordered vertex set $V = (V_1 \cup V_2) \setminus (V_1 \cap V_2)$, the two renumbered $s$-cell sets \texttt{CV1} and \texttt{CV2}, and the size \texttt{len(case12)} of $V_1 \cap V_2$.
%-------------------------------------------------------------------------------
@D Return the single reordered pointset and the two $d$-cell arrays
@{
	V = [eval(p[0]) for p in case1] + [eval(p[0]) for p in case12] + [eval(
				p[0]) for p in case2]
	CV1 = [sorted([invertedindex[v] for v in cell]) for cell in CV1]
	CV2 = [sorted([invertedindex[v] for v in cell]) for cell in CV2]
	return V, CV1, CV2, len(case12)
@}
%-------------------------------------------------------------------------------





\bibliographystyle{amsalpha}
\bibliography{sysml}

\end{document}
