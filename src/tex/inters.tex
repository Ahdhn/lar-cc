\documentclass[11pt,oneside]{article}    %use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}        %Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}        %...ora4paperora5paperor...
%\geometry{landscape}        %Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}        %Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}                %Usepdf,png,jpg,orepsÃŸwithpdflatex;useepsinDVImode
                                %TeXwillautomaticallyconverteps-->pdfinpdflatex        
\usepackage{amssymb}
\usepackage[colorlinks]{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{Accelerated intersection of geometric objects
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
\author{Alberto Paoluzzi}
%\date{}                            %Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\begin{abstract}
This module contains the first experiments of a parallel implementation of the intersection of (multidimensional) geometric objects. The first installment is being oriented to the intersection of line segment in the 2D plane. A generalization of the algorithm, based on the classification of the containment boxes of the geometric values, will follow quickly.
\end{abstract}

\tableofcontents

%===============================================================================
\section{Introduction}
%===============================================================================

An easily parallelizable implementation of the accelerated intersection of geometric objects is given in this module. Our first aim is to implement a specialized version for simplices, that generalizes the $nD$-trees of points (that are 0-simplices), to $(d-1)$-dimensional simplices in $d$-space, starting with the intersection of line segments in the plane. Our plan is to follow with an implementation for intersection of general convex sets.


%===============================================================================
\section{Implementation}
%===============================================================================

The first implementation of this module concerns the computation of the intersection points among a set of line segment in the 2D plane. The containment boxes of the input segments are iteratively classified against the 1-dimensional centroid of smaller and smaller buckets of data. 

At the end of the classification, where the same geometric object may be inserted in several different buckets, a \emph{brute-force} intersection is applied to each final subset. Finally, the duplicated intersection points are removed, and a 1-dimensional LAR data structure is generated, with 1-cells given by the split line segments. 

A complete LAR of the plane partition generated by the arrangment of lines is then computed by: (a) generating the maximal 2-connected components of such 1-dimensional graph; and (b) by traversing in counter-clockwise order the generated subgraphs to report the 2-dimensional cells of the plane partition.

The splitting algorithm may be easily parallelized, since both during their generation and at the end of this one, the various buckets of data can be dispatched to different processors for independent computation, followed by elimination of duplicates. In particular, a standard \emph{map-reduce} software infrastructure may be used for this parallelization purpose.


\subsection{Construction of independent buckets}
%===============================================================================


\paragraph{Containment boxes}

Given as input a list \texttt{randomLineArray} of pairs of 2D points, the function \texttt{containmentBoxes} returns, in the same order, the list of \emph{containment boxes} of the input lines. A \emph{containment box} of a geometric object of dimension $d$ is defined as the minimal $d$-cuboid, equioriented with the reference frame, that contains the object. For a 2D line it is given by the tuple $(x1,y1,x2,y2)$, where $(x1,y1)$ is the point of minimal coordinates, and $(x2,y2)$ is the point of maximal  coordinates.

%-------------------------------------------------------------------------------
@D Containment boxes
@{""" Containment boxes """
def containmentBoxes(randomLineArray):
    boxes = [eval(vcode([min(x1,x2),min(y1,y2),max(x1,x2),max(y1,y2)]))
            for ((x1,y1),(x2,y2)) in randomLineArray]
    return boxes
@}
%-------------------------------------------------------------------------------



\paragraph{Splitting the input above and below a threshold}
%-------------------------------------------------------------------------------
@D Splitting the input above and below a threshold
@{""" Splitting the input above and below a threshold """
def splitOnThreshold(boxes,subset,xy='x'):
    theBoxes = [boxes[k] for k in subset]
    threshold = centroid(theBoxes,xy)
    if xy=='x': a=0;b=2;
    elif xy=='y': a=1;b=3;
    below,above = [],[]
    for k in subset:
        if boxes[k][a] <= threshold: below += [k]
    for k in subset:
        if boxes[k][b] >= threshold: above += [k]
    return below,above
@}
%-------------------------------------------------------------------------------


\paragraph{Iterative splitting of box buckets}
%-------------------------------------------------------------------------------
@D Iterative splitting of box buckets
@{""" Iterative splitting of box buckets """
def boxBuckets(boxes):
    bucket = range(len(boxes))
    splittingStack = [bucket]
    finalBuckets = []
    while splittingStack != []:
        bucket = splittingStack.pop()
        below,above = splitOnThreshold(boxes,bucket,'x')
        below1,above1 = splitOnThreshold(boxes,above,'y')
        below2,above2 = splitOnThreshold(boxes,below,'y')
        
        if (len(below1)<4 and len(above1)<4) or len(set(bucket).difference(below1))<7 \
            or len(set(bucket).difference(above1))<7: 
            finalBuckets.append(below1)
            finalBuckets.append(above1)
        else: 
            splittingStack.append(below1)
            splittingStack.append(above1)
            
        if (len(below2)<4 and len(above2)<4) or len(set(bucket).difference(below2))<7 \
            or len(set(bucket).difference(above2))<7:  
            finalBuckets.append(below2)
            finalBuckets.append(above2)
        else: 
            splittingStack.append(below2)
            splittingStack.append(above2)
    return list(set(AA(tuple)(finalBuckets)))
@}
%-------------------------------------------------------------------------------


\subsection{Brute force intersection within the buckets}
%===============================================================================




\paragraph{Intersection of two line segments}
%-------------------------------------------------------------------------------
@D Intersection of two line segments
@{""" Intersection of two line segments """
def segmentIntersect(pointStorage):
    def segmentIntersect0(segment1):
        p1,p2 = segment1
        line1 = '['+ vcode(p1) +','+ vcode(p2) +']'
        (x1,y1),(x2,y2) = p1,p2
        #B1,B2,B3,B4 = eval(vcode([min(x1,x2),min(y1,y2),max(x1,x2),max(y1,y2)]))
        def segmentIntersect1(segment2):
            p3,p4 = segment2
            line2 = '['+ vcode(p3) +','+ vcode(p4) +']'
            (x3,y3),(x4,y4) = p3,p4
            #b1,b2,b3,b4 = eval(vcode([min(x3,x4),min(y3,y4),max(x3,x4),max(y3,y4)]))
            #if ((B1<=b1<=B3) or (B1<=b3<=B3)) and ((B2<=b2<=B4) or (B2<=b4<=B4)):
            if True:
                m23 = mat([p2,p3])
                m14 = mat([p1,p4])
                m = m23 - m14
                v3 = mat([p3])
                v1 = mat([p1])
                v = v3-v1
                a=m[0,0]; b=m[0,1]; c=m[1,0]; d=m[1,1];
                det = a*d-b*c
                if det != 0:
                    m_inv = mat([[d,-b],[-c,a]])*(1./det)
                    alpha, beta = (v*m_inv).tolist()[0]
                    #alpha, beta = (v*m.I).tolist()[0]
                    if 0<=alpha<=1 and 0<=beta<=1:
                        pointStorage[line1] += [alpha]
                        pointStorage[line2] += [beta]
                        return list(array(p1)+alpha*(array(p2)-array(p1)))
            return None
        return segmentIntersect1
    return segmentIntersect0
@}
%-------------------------------------------------------------------------------


\paragraph{Brute force bucket intersection}
%-------------------------------------------------------------------------------
@D Brute force bucket intersection
@{""" Brute force bucket intersection """
def lineBucketIntersect(lines,pointStorage):
    intersect0 = segmentIntersect(pointStorage)
    intersectionPoints = []
    n = len(lines)
    for k,line in enumerate(lines):
        intersect1 = intersect0(line)
        for h in range(k+1,n):
            line1 = lines[h]
            point = intersect1(line1)
            if point != None: 
                intersectionPoints.append(eval(vcode(point)))
    return intersectionPoints
@}
%-------------------------------------------------------------------------------


\paragraph{Accelerate intersection of lines}
%-------------------------------------------------------------------------------
@D Accelerate intersection of lines
@{""" Accelerate intersection of lines """
def lineIntersection(lineArray):

    from collections import defaultdict
    pointStorage = defaultdict(list)
    for line in lineArray:
        p1,p2 = line
        key = '['+ vcode(p1) +','+ vcode(p2) +']'
        pointStorage[key] = []

    boxes = containmentBoxes(lineArray)
    buckets = boxBuckets(boxes)
    intersectionPoints = set()
    for bucket in buckets:
        lines = [lineArray[k] for k in bucket]
        pointBucket = lineBucketIntersect(lines,pointStorage)
        intersectionPoints = intersectionPoints.union(AA(tuple)(pointBucket))

    frags = AA(eval)(pointStorage.keys())
    params = AA(COMP([sorted,list,set,tuple,eval,vcode]))(pointStorage.values())
        
    return intersectionPoints,params,frags  ### GOOD: 1, WRONG: 2 !!!
@}
%-------------------------------------------------------------------------------


\subsection{Generation of LAR representation of split segments}
%===============================================================================
The function \texttt{lines2lar} is used to generate a 1-dimensional LAR complex from
an array of lines, i.e.~of pairs of 2D points. For every \emph{line} in \texttt{frags}
is computed an \emph{ordered} list \texttt{outline} of \emph{symbolic} intersection points, including 
the first and last vertex of the line, and every interior point generated by the list \texttt{params[k]}.

Then, for every symbolic representation \texttt{key} of a point in \texttt{outline}, a 
dictionary vertex is either created or retrieved, and a corresponding edge is orderly created, using the index of the point.
At the same time, the vertices created in this way are accumulated within the \texttt{V} array.
Finally, each edge in EV is extended to contain a second vertex index using the subsequent edge.  

The third stage finalizes the vertex set of the output LAR, by identifying the closest vertices, i.e.~those at distance
less or equal to the current resolution, set to \texttt{10**(-PRECISION)}, by searching via the \texttt{scipy.spatialKDTree} the pairs of vertices at less than this distance.

A fourth stage identifies the possibly duplicated edges. Some of these could appear, e.g., when importing a set of adjacent boxes from some drawing program, to generate an array of lines, to be mutually intersected and transformed into a LAR data structure.

\paragraph{Create the LAR of fragmented lines}
%-------------------------------------------------------------------------------
@D Create the LAR of fragmented lines
@{""" Create the LAR of fragmented lines """
from scipy import spatial

def lines2lar(lineArray):
    _,params,frags = lineIntersection(lineArray)
    vertDict = dict()
    index,defaultValue,V,EV = -1,-1,[],[]
    
    for k,(p1,p2) in enumerate(frags):
        outline = [vcode(p1)]
        if params[k] != []:
            for alpha in params[k]:
                if alpha != 0.0 and alpha != 1.0:
                    p = list(array(p1)+alpha*(array(p2)-array(p1)))
                    outline += [vcode(p)]
        outline += [vcode(p2)]
    
        edge = []
        for key in outline:
            if vertDict.get(key,defaultValue) == defaultValue:
                index += 1
                vertDict[key] = index
                edge += [index]
                V += [eval(key)]
            else:
                edge += [vertDict[key]]
            EV.extend([[edge[k],edge[k+1]] for k,v in enumerate(edge[:-1])])
    
    # identification of close vertices
    closePairs = scipy.spatial.KDTree(V).query_pairs(10**(-PRECISION))
    if closePairs != []:
        EV_ = []
        for v1,v2 in EV:
            for v,w in closePairs:
                if v1 == w: v1 = v
                elif v2 == w: v2 = v
            EV_ += [[v1,v2]]
        EV = EV_
        print "\nclosePairs =",closePairs

    # Remove double edges
    EV = list(set(AA(tuple)(AA(sorted)(EV))))

    return V,EV
@}
%-------------------------------------------------------------------------------

\subsection{Biconnected components of a 1-complex}
%===============================================================================

An implementation of the Hopcroft-Tarjan algorithm~\cite{Hopcroft:1973:AEA:362248.362272} for computation of the biconnected components of a graph is given here.



\paragraph{Biconnected components}
%-------------------------------------------------------------------------------
@D Biconnected components
@{""" Biconnected components """
@< Adjacency lists of 1-complex vertices @>
@< Main procedure for biconnected components @>
@< Hopcroft-Tarjan algorithm @>
@< Output of biconnected components @>
@}
%-------------------------------------------------------------------------------



\paragraph{Adjacency lists of 1-complex vertices}
%-------------------------------------------------------------------------------
@D Adjacency lists of 1-complex vertices
@{""" Adjacency lists of 1-complex vertices """
def vertices2vertices(model):
    V,EV = model
    csrEV = csrCreate(EV)
    csrVE = csrTranspose(csrEV)
    csrVV = matrixProduct(csrVE,csrEV)    
    cooVV = csrVV.tocoo()
    data,rows,cols = AA(list)([cooVV.data, cooVV.row, cooVV.col])
    triples = zip(data,rows,cols)
    VV = [[] for k in range(len(V))]
    for datum,row,col in triples:
        if row != col: VV[col] += [row]
    return AA(sorted)(VV)
@}
%-------------------------------------------------------------------------------


\paragraph{Main procedure for biconnected components}
%-------------------------------------------------------------------------------
@D Main procedure for biconnected components
@{""" Main procedure for biconnected components """
def biconnectedComponent(model):
    W,_ = model
    V = range(len(W))
    count = 0
    stack,out = [],[]
    visited = [None for v in V]
    parent = [None for v in V]
    d = [None for v in V]
    low = [None for v in V]
    for u in V: visited[u] = False
    for u in V: parent[u] = []
    VV = vertices2vertices(model)
    for u in V: 
        if not visited[u]: 
            DFV_visit( VV,out,count,visited,parent,d,low,stack, u )
    return W,[component for component in out if len(component) > 1]
@}
%-------------------------------------------------------------------------------


\paragraph{Hopcroft-Tarjan algorithm}
%-------------------------------------------------------------------------------
@D Hopcroft-Tarjan algorithm
@{""" Hopcroft-Tarjan algorithm """
def DFV_visit( VV,out,count,visited,parent,d,low,stack,u ):
    visited[u] = True
    count += 1
    d[u] = count
    low[u] = d[u]
    for v in VV[u]:
        if not visited[v]:
            stack += [(u,v)]
            parent[v] = u
            DFV_visit( VV,out,count,visited,parent,d,low,stack, v )
            if low[v] >= d[u]:
                out += [outputComp(stack,u,v)]
            low[u] = min( low[u], low[v] )
        else:
            if not (parent[u]==v) and (d[v] < d[u]):
                stack += [(u,v)]
                low[u] = min( low[u], d[v] )
@}
%-------------------------------------------------------------------------------


\paragraph{Output of biconnected components}
%-------------------------------------------------------------------------------
@D Output of biconnected components
@{""" Output of biconnected components """
def outputComp(stack,u,v):
    out = []
    while True:
        e = stack.pop()
        out += [list(e)]
        if e == (u,v): break
    return list(set(AA(tuple)(AA(sorted)(out))))
@}
%-------------------------------------------------------------------------------


\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/biconnected1} 
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/biconnected2} 

   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/biconnected3} 
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/biconnected4} 
   \caption{Two random line arrangements, and the biconnected components extracted by their LAR 1-complexes.}
   \label{fig:biconnected}
\end{figure}


\subsection{2D cells from biconnected components}
%===============================================================================

It is very easy,  using the LAR representation of topology, to compute the 2-cells of the plane partitions~(see Figures~\ref{fig:biconnected}b and~\ref{fig:biconnected}c) induced by the biconnected components extracted from a graph (1-complex).

In particular, let us consider the CSR (Compressed Sparse Row) representation of the characteristic matrix $M_1$, here usually denoted as \texttt{EV}, in order to remark that we represent the edges on the rows, and the vertices on the columns of the matrix. As such it is a binary matrix. So, we can readily reconstruct the topology of 2-cells by associating to each non-zero (sparse) matrix element $\texttt{angle\_EV}(h,k)$ the angle in radians that the edge $e_h$ forms with the orizontal line, when it incides on the vertex $v_k$. 

Of course, if $e_h = (v_{k_1},v_{k_2})$, then it will be 
\[
\texttt{angle\_EV}(h,k_2) = \texttt{angle\_EV}(h,k_1)+\pi = -\texttt{angle\_EV}(h,k_1)
\]

Therefore, the columns of $\texttt{angle\_EV}$, i.e.~the rows of $\texttt{angle\_VE} := \texttt{angle\_EV}^t$,
after being sorted on their angles $\alpha$, and associated with the angle differences $\Delta\alpha$, will provide a basis of elementary $1-cochains$ that evaluate to zero for each closed 1-cochain, i.e. for every cycle supported by the linear space of 1-chains on the given line arrangment.


\paragraph{Slope of edges}

\paragraph{Circular ordering of edges around vertices}
%-------------------------------------------------------------------------------
@D Slope of edges
@{""" Circular ordering of edges around vertices """
def edgeSlopeOrdering(model):
    V,EV = model
    from bool1 import invertRelation
    VE,VE_angle = invertRelation(EV),[]
    for v,ve in enumerate(VE):
        ve_angle = []
        if ve != []:
            for edge in ve:
                v0,v1 = EV[edge]
                if v == v0:     x,y = list(array(V[v1]) - array(V[v0]))
                elif v == v1:    x,y = list(array(V[v0]) - array(V[v1]))
                angle = math.atan2(y,x)
                ve_angle += [180*angle/PI]
        pairs = sorted(zip(ve_angle,ve))
        #VE_angle += [TRANS(pairs)[1]]
        VE_angle += [[pair[1] for pair in pairs]]
    return VE_angle
@}
%-------------------------------------------------------------------------------


\paragraph{Ordered incidence relationship vertices to edges}

As we have seen, the \texttt{VE\_angle} list of lists reports, for every vertex in \texttt{V}, the list of incident edges, \emph{counterclockwise ordered} around the vertex. Therefore the \texttt{ordered\_csrVE} function, given below, returns the ``compressed sparse row'' matrix, row-indexed by vertices and column-indexed by edges, and such that in position $(v,e)$ contains the index $\ell$ of the next edge (after $e$, say) in the counterclockwise ordering of edges around $v$.

%-------------------------------------------------------------------------------
@D Ordered incidence relationship of vertices and edges
@{""" Ordered incidence relationship of vertices and edges """
def ordered_csrVE(VE_angle):
    triples = []
    for v,ve in enumerate(VE_angle):
        n = len(ve)
        for k,edge in enumerate(ve):
            triples += [[v, ve[k], ve[ (k+1)%n ]]]
    csrVE = triples2mat(triples,shape="csr")
    return csrVE
@}
%-------------------------------------------------------------------------------


\paragraph{Faces from biconnected components}
Since edges in the plane partition induced by a line arrangement are $(d-1)$-cells, they are located on the boundary of \emph{two} $d$-cells (faces) of the partition. Hence, the traversal algorithm of the data structure storing the relevant information may be driven by signing the two extremes (vertices) of each edge as either already visited or not.


%-------------------------------------------------------------------------------
@D Faces from biconnected components
@{""" Faces from biconnected components """

def firstSearch(visited):
    for edge,vertices in enumerate(visited):
        for v,vertex in enumerate(vertices):
            if visited[edge,v] == 0.0:
                visited[edge,v] = 1.0
                return edge,v
    return -1,-1

def facesFromComponents(model):
    V,EV = model
    FV = []
    VE_angle = edgeSlopeOrdering(model)
    csrEV = ordered_csrVE(VE_angle).T
    visited = zeros((len(EV),2))
    edge,v = firstSearch(visited)
    vertex = EV[edge][v]
    fv = []
    while True:
        if (edge,v) == (-1,-1):
            return [face for face in FV if face != None]
        elif (fv == []) or (fv[0] != vertex):
            
            fv += [vertex]
            nextEdge = csrEV[edge,vertex]
            v0,v1 = EV[nextEdge]
            
            try:
                vertex, = set([v0,v1]).difference([vertex])
            except ValueError:
                print 'ValueError: too many values to unpack'
                break
                
            if v0==vertex: pos=0
            elif v1==vertex: pos=1
                        
            if visited[nextEdge, pos] == 0:
                visited[nextEdge, pos] = 1
                edge = nextEdge                
        else:
            FV += [fv]
            fv = []
            edge,v = firstSearch(visited)
            vertex = EV[edge][v]
        #print "fv =",fv
        #print "edge,vertex =",edge,vertex
    return [face for face in FV if face != None]
@}
%-------------------------------------------------------------------------------

\paragraph{Txample}
The \emph{ordered} \texttt{csrVE} (vertex-edge) matrix generated by the example of file \texttt{test/py/inters/test07.py} is shown in dense format in the example script below.
Let us notice the each non-zero element $\texttt{csrVE}(k,h)$ stores the index of the previous edge 
inciding on the vertex $v_k$ \emph{before} the edge $e_h$. The traversal of the data structure is made accordingly, in order to extract the vertices of all the faces (minimal edge cycles) generated by a line arrangement in the plane.

%-------------------------------------------------------------------------------
@D Example of VE matrix with nextEdge indices @{
csr2DenseMatrix(csrVE)
>>> array([
    [12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11,  0,  0,  0], 
    [ 1,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0], 
    [ 0, 14,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0], 
    [ 0,  0,  6,  5,  0,  2,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0], 
    [ 0,  0,  0, 10,  0,  0,  0,  0,  0,  3,  9,  0,  0,  0,  0,  0], 
    [ 0,  0,  0,  0, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4], 
    [ 0,  0,  0,  0, 12,  4,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0], 
    [ 0,  0,  0,  0,  0,  0,  7,  8,  6,  0,  0,  0,  0,  0,  0,  0], 
    [ 0,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0], 
    [ 0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  8,  0,  0,  0,  0,  0], 
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0], 
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13,  0, 14, 11,  0], 
    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15,  0, 13]])
@}
%-------------------------------------------------------------------------------



\paragraph{Transformation of an array of lines in a 2D LAR complex}

The whole transformation of an array of lines into a two-dimensional \texttt{LAR} complex is executed by the function \texttt{larFromLines}. The function returns the model triple \texttt{V,FV,EV}. The last element in \texttt{FV} is the \emph{ordered} boundary chain.


%-------------------------------------------------------------------------------
@D Transformation of an array of lines in a 2D LAR complex @{
""" Transformation of an array of lines in a 2D LAR complex """
from bool1 import larRemoveVertices
from hospital import surfIntegration

def larFromLines(lines):
    V,EV = lines2lar(lines)
    V,EVs = biconnectedComponent((V,EV))
    EV = list(set(AA(tuple)(sorted(AA(sorted)(CAT(EVs)))))) 
    V,EV = larRemoveVertices(V,EV)
    FV = facesFromComponents((V,EV))
    areas = surfIntegration((V,FV,EV))
    boundaryArea = max(areas)
    interiorFaces = [FV[f] for f,area in enumerate(areas) if area!=boundaryArea]
    boundaryFace = FV[areas.index(boundaryArea)]
    return V,interiorFaces+[boundaryFace],EV
@}
%-------------------------------------------------------------------------------


%===============================================================================
\section{Exporting the module}
%===============================================================================

%-------------------------------------------------------------------------------
@O lib/py/inters.py
@{""" Module for pipelined intersection of geometric objects """
from pyplasm import *
""" import modules from larcc/lib """
import sys
sys.path.insert(0, 'lib/py/')
from larcc import *
DEBUG = True

@< Coding utilities @>
@< Generation of random lines @>
@< Containment boxes @>
@< Splitting the input above and below a threshold @>
@< Box metadata computation @>
@< Iterative splitting of box buckets @>
@< Intersection of two line segments @>
@< Brute force bucket intersection @>
@< Accelerate intersection of lines @>
@< Create the LAR of fragmented lines @>
@< Biconnected components @>
@< Slope of edges @>
@< Ordered incidence relationship of vertices and edges @>
@< Faces from biconnected components @>
@< SVG input parsing and transformation @>
@< Transformation of an array of lines in a 2D LAR complex @>
@}
%-------------------------------------------------------------------------------


%===============================================================================
\section{Examples}
%===============================================================================




\paragraph{Generation of random line segments and their boxes}
%-------------------------------------------------------------------------------
@O test/py/inters/test01.py
@{""" Generation of random line segments and their boxes """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *

randomLineArray = randomLines(200,0.3)
VIEW(STRUCT(AA(POLYLINE)(randomLineArray)))

boxes = containmentBoxes(randomLineArray)
rects= AA(box2rect)(boxes)
cyan = COLOR(CYAN)(STRUCT(AA(POLYLINE)(randomLineArray)))
yellow = COLOR(YELLOW)(STRUCT(AA(POLYLINE)(rects)))
VIEW(STRUCT([cyan,yellow]))
@}
%-------------------------------------------------------------------------------


\paragraph{Split segment array in four independent buckets}
%-------------------------------------------------------------------------------
@O test/py/inters/test02.py
@{""" Split segment array in four independent buckets """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *

randomLineArray = randomLines(200,0.3)
VIEW(STRUCT(AA(POLYLINE)(randomLineArray)))
boxes = containmentBoxes(randomLineArray)
bucket = range(len(boxes))
below,above = splitOnThreshold(boxes,bucket,'x')
below1,above1 = splitOnThreshold(boxes,above,'y')
below2,above2 = splitOnThreshold(boxes,below,'y')

cyan = COLOR(CYAN)(STRUCT(AA(POLYLINE)(randomLineArray[k] for k in below1)))
yellow = COLOR(YELLOW)(STRUCT(AA(POLYLINE)(randomLineArray[k] for k in above1)))
red = COLOR(RED)(STRUCT(AA(POLYLINE)(randomLineArray[k] for k in below2)))
green = COLOR(GREEN)(STRUCT(AA(POLYLINE)(randomLineArray[k] for k in above2)))

VIEW(STRUCT([cyan,yellow,red,green]))
@}
%-------------------------------------------------------------------------------



\paragraph{Generation and random coloring of independent line buckets}
%-------------------------------------------------------------------------------
@O test/py/inters/test03.py
@{""" Generation and random coloring of independent line buckets """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *

lines = randomLines(200,0.3)
VIEW(STRUCT(AA(POLYLINE)(lines)))

boxes = containmentBoxes(lines)
buckets = boxBuckets(boxes)

colors = [CYAN, MAGENTA, WHITE, RED, YELLOW, GRAY, GREEN, ORANGE, BLACK, BLUE, PURPLE, BROWN]
sets = [COLOR(colors[k%12])(STRUCT(AA(POLYLINE)([lines[h] 
            for h in bucket]))) for k,bucket in enumerate(buckets)]

VIEW(STRUCT(sets))
@}
%-------------------------------------------------------------------------------


\paragraph{Construction of \texttt{LAR = (V,EV)} of random line arrangement}
%-------------------------------------------------------------------------------
@O test/py/inters/test04.py
@{""" LAR of random line arrangement """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *

lines = randomLines(400,0.2)
VIEW(STRUCT(AA(POLYLINE)(lines)))

intersectionPoints,params,frags = lineIntersection(lines)

marker = CIRCLE(.005)([4,1])
markers = STRUCT(CONS(AA(T([1,2]))(intersectionPoints))(marker))
VIEW(STRUCT(AA(POLYLINE)(lines)+[COLOR(RED)(markers)]))

V,EV = lines2lar(lines)
marker = CIRCLE(.01)([4,1])
markers = STRUCT(CONS(AA(T([1,2]))(V))(marker))
#markers = STRUCT(CONS(AA(T([1,2]))(intersectionPoints))(marker))
polylines = STRUCT(MKPOLS((V,EV)))
VIEW(STRUCT([polylines]+[COLOR(MAGENTA)(markers)]))
@}
%-------------------------------------------------------------------------------


\paragraph{Splitting of othogonal lines}
%-------------------------------------------------------------------------------
@O test/py/inters/test05.py
@{""" LAR from splitting of othogonal lines """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *
@< Orthogonal example @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@D Orthogonal example @{
lines = [[[0,0],[6,0]], [[0,4],[10,4]], [[0,0],[0,4]], [[3,0],[3,4]], 
[[6,0],[6, 8]], [[3,2],[6,2]], [[10,0],[10,8]], [[0,8],[10,8]]]

VIEW(EXPLODE(1.2,1.2,1)(AA(POLYLINE)(lines)))

V,EV = lines2lar(lines)
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,EV))))
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.25\linewidth,width=0.325\linewidth]{images/ortho1} 
   \includegraphics[height=0.25\linewidth,width=0.325\linewidth]{images/ortho2} 
   \includegraphics[height=0.25\linewidth,width=0.325\linewidth]{images/ortho3} 
   \caption{Splitting of orthogonal lines: (a) exploded input; (a) exploded output; (c) biconnected components.}
   \label{fig:ortho}
\end{figure}



\paragraph{Random coloring of the generated 1-complex LAR}
%-------------------------------------------------------------------------------
@O test/py/inters/test06.py
@{""" Random coloring of the generated 1-complex """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *

lines = randomLines(400,0.2)
VIEW(STRUCT(AA(POLYLINE)(lines)))

V,EV = lines2lar(lines)
colors = [CYAN, MAGENTA, WHITE, RED, YELLOW, GRAY, GREEN, ORANGE, BLACK, BLUE, PURPLE, BROWN]
sets = [COLOR(colors[k%12])(POLYLINE([V[e[0]],V[e[1]]])) for k,e in enumerate(EV)]

VIEW(STRUCT(sets))
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.49\linewidth]{images/colored1} 
   \includegraphics[width=0.49\linewidth]{images/colored2} 
   \caption{Splitting of intersecting lines: (a) random input; (a) splitted and colored LAR output.}
   \label{fig:ortho}
\end{figure}



\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/lineintersect1} 
   \includegraphics[height=0.49\linewidth,width=0.49\linewidth]{images/lineintersect2} 
   \caption{The intersection of 5000 random lines in the unit interval, with \texttt{scaling} parameter equal to \texttt{0.1}}
   \label{fig:example}
\end{figure}


    

\paragraph{Biconnected components from orthogonal LAR model}
%-------------------------------------------------------------------------------
@O test/py/inters/test07.py
@{""" Biconnected components from orthogonal LAR model """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *
from bool1 import larRemoveVertices
colors = [CYAN, MAGENTA, WHITE, RED, YELLOW, GREEN, ORANGE, BLACK, BLUE, PURPLE]

@< Orthogonal example @>
model = V,EV
V,EVs = biconnectedComponent(model)
HPCs = [STRUCT(MKPOLS((V,EV))) for EV in EVs]

sets = [COLOR(colors[k%10])(hpc) for k,hpc in enumerate(HPCs)]
VIEW(STRUCT(sets))
VIEW(STRUCT(MKPOLS((V,CAT(EVs)))))

#V,EV = larRemoveVertices(V,CAT(EVs))
@}
%-------------------------------------------------------------------------------


\paragraph{2-complex from orthogonal line segments}
%-------------------------------------------------------------------------------
@O test/py/inters/test08.py
@{""" 2-complex from orthogonal line segments """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *
colors = [CYAN, MAGENTA, WHITE, RED, YELLOW, GREEN, ORANGE, BLACK, BLUE, PURPLE]

@< Orthogonal example @>
model = V,EV
V,EVs = biconnectedComponent(model)
HPCs = [STRUCT(MKPOLS((V,EV))) for EV in EVs]

sets = [COLOR(colors[k%10])(hpc) for k,hpc in enumerate(HPCs)]
VIEW(STRUCT(sets))

EV = sorted(CAT(EVs))
VIEW(STRUCT(MKPOLS((V,EV))))

FV = facesFromComponents((V,EV))

from hospital import surfIntegration
areas = surfIntegration((V,FV,EV))
boundaryArea = max(areas)
FV = [FV[f] for f,area in enumerate(areas) if area!=boundaryArea]
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV+EV)) + AA(MK)(V)))
@}
%-------------------------------------------------------------------------------

    

\paragraph{Biconnected components from random LAR model}
%-------------------------------------------------------------------------------
@O test/py/inters/test09.py
@{""" Biconnected components from orthogonal LAR model """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *
from bool1 import larRemoveVertices
from hospital import surfIntegration
from iot3d import polyline2lar
colors = [CYAN, MAGENTA, YELLOW, RED, GREEN, ORANGE, PURPLE, WHITE, BLACK, BLUE]

lines = randomLines(800,0.2)
V,EV = lines2lar(lines)
model = V,EV

V,EVs = biconnectedComponent(model)
HPCs = [STRUCT(MKPOLS((V,EV))) for EV in EVs]
sets = [COLOR(colors[k%10])(hpc) for k,hpc in enumerate(HPCs)]
VIEW(STRUCT(sets))

EV = CAT(EVs)
V,EV = larRemoveVertices(V,EV)
FV = facesFromComponents((V,EV))
from hospital import surfIntegration
areas = surfIntegration((V,FV,EV))
boundaryArea = max(areas)
FV = [FV[f] for f,area in enumerate(areas) if area!=boundaryArea]
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV+EV)) + AA(MK)(V)))

from bool1 import larRemoveVertices
V,EV = larRemoveVertices(V,EV)
VV = AA(LIST)(range(len(V)))
submodel = STRUCT(MKPOLS((V,EV)))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV],submodel,0.015))
@}
%-------------------------------------------------------------------------------


\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/illustrator1} 
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/illustrator2} 
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/illustrator3} 
   \caption{\texttt{LAR} complex generation from \texttt{SVG} file. (a) the input set of lines; (b) imported in \texttt{pyplasm} environment; (c) the extracted \emph{regularized} 2-complex, drawn exploded.}
   \label{fig:ortho}
\end{figure}




\paragraph{SVG input parsing and transformation}

We postulate here that the input file \texttt{test/py/inters/test.svg} should contain only \texttt{<line>} primitives, so we skip any other content. Such primitives are parsed by matching against regular expressions, and their \texttt{x1,y1,x2,y2} attributes are extracted and stored into the \texttt{lines} variable.
An isomorphic window-viewport transformation is then performed, to transform the data within the standard unit 2D square $[0,1]^2$.
The input vertices are finally set to a fixed resolution, using the \texttt{vcode} function. 

%-------------------------------------------------------------------------------
@D SVG input parsing and transformation
@{""" SVG input parsing and transformation """
from larcc import *
import re # regular expression

def svg2lines(filename):

    lines = [line.strip() for line in open(filename) if re.match("<line ",line)!=None]   
    for line in lines: print line
        
    out = ""    
    for line in lines:
        #searchObj = re.search( r'([0-9]*\.[0-9]*)(.*?)([0-9]*\.[0-9]*)(.*?)([0-9]*\.[0-9]*)(.*?)([0-9]*\.[0-9]*)', line)
        searchObj = re.search( r'(<line )(.+)(" x1=")(.+)(" y1=")(.+)(" x2=")(.+)(" y2=")(.+)("/>)', line)
        if searchObj:
            #out += "[["+searchObj.group(1)+","+searchObj.group(3)+"], ["+searchObj.group(5)+","+searchObj.group(7)+"]],"
            out += "[["+searchObj.group(4)+","+searchObj.group(6)+"], ["+searchObj.group(8)+","+searchObj.group(10)+"]],"
    
    lines = list(eval(out))
    
    # window-viewport transformation
    xs,ys = TRANS(CAT(lines))
    box = [min(xs), min(ys), max(xs), max(ys)]
    
    # viewport aspect-ratio checking, setting a computed-viewport 'b'
    b = [None for k in range(4)]
    if (box[2]-box[0])/(box[3]-box[1]) > 1:  
        b[0]=0; b[2]=1; bm=(box[3]-box[1])/(box[2]-box[0]); b[1]=.5-bm/2; b[3]=.5+bm/2
    else: 
        b[1]=0; b[3]=1; bm=(box[2]-box[0])/(box[3]-box[1]); b[0]=.5-bm/2; b[2]=.5+bm/2
    
    # isomorphic 'box -> b' transform to standard unit square
    lines = [[[ 
    ((x1-box[0])*(b[2]-b[0]))/(box[2]-box[0]) , 
    ((y1-box[1])*(b[3]-b[1]))/(box[1]-box[3]) + 1], [
    ((x2-box[0])*(b[2]-b[0]))/(box[2]-box[0]), 
    ((y2-box[1])*(b[3]-b[1]))/(box[1]-box[3]) + 1]]  
          for [[x1,y1],[x2,y2]] in lines]
    
    # line vertices set to fixed resolution
    lines = eval("".join(['['+ vcode(p1) +','+ vcode(p2) +'], ' for p1,p2 in lines]))
    return lines
@}
%-------------------------------------------------------------------------------


\paragraph{2-complex extraction from svg file}
The input \texttt{lines} arrangments produces a 1-dimensional complex stored into the \texttt{LAR} model \texttt{V,EV}. Then the \emph{dangling edges} are removed from \texttt{EV\_},
and the whole data set is renumbered, in order to remove the unused vertices, using the \texttt{larRemoveVertices} function.
Finally the 2-cells are computed and stored in \texttt{FV}, and the positive areas of every 2cells are computed, so allowing for identify and removal of the exterior face, 
corresponding to the boundary of the complex.
The polygonal boundary of the complex is finally drawn.

%-------------------------------------------------------------------------------
@O test/py/inters/test10.py
@{""" Biconnected components from orthogonal LAR model """
import sys
sys.path.insert(0, 'lib/py/')
from inters import *
from iot3d import polyline2lar

filename = "test/py/inters/test1.svg"
lines = svg2lines(filename)
VIEW(STRUCT(AA(POLYLINE)(lines)))
    
V,FV,EV = larFromLines(lines)

VV = AA(LIST)(range(len(V)))
submodel = STRUCT(MKPOLS((V,EV)))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV[:-1]],submodel,0.10))

VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV[:-1]+EV)) + AA(MK)(V)))

verts,faces,edges = polyline2lar([[ V[v] for v in FV[-1] ]])
VIEW(STRUCT(MKPOLS((verts,edges))))
@}
%-------------------------------------------------------------------------------


\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.2425\linewidth,width=0.2425\linewidth]{images/svg1} 
   \includegraphics[height=0.2425\linewidth,width=0.2425\linewidth]{images/svg2} 
   \includegraphics[height=0.2425\linewidth,width=0.2425\linewidth]{images/svg3} 
   \includegraphics[height=0.2425\linewidth,width=0.2425\linewidth]{images/svg4} 
   \caption{\texttt{LAR} complex generation from \texttt{SVG} file. (a) the input set of lines parsed from an \texttt{SVG} file; (b) the intersection of lines; (c) the extracted \emph{regularized} 2-complex, drawn exploded; (d) the boundary \texttt{LAR}.}
   \label{fig:ortho}
\end{figure}


\appendix
%===============================================================================
\section{Code utilities}
%===============================================================================

\paragraph{Coding utilities}

Some utility fuctions used by the module are collected in this appendix. Their macro names can be seen in the below script.

%-------------------------------------------------------------------------------
@D Coding utilities
@{""" Coding utilities """
@< Generation of a random point @>
@< Generation of a random line segment @>
@< Transformation of a 2D box into a closed polyline @>
@< Computation of the 1D centroid of a list of 2D boxes @>
@}
%-------------------------------------------------------------------------------


\paragraph{Generation of random lines}
The function \texttt{randomLines} returns the array \texttt{randomLineArray} with a given number of lines generated within the unit 2D interval. The \texttt{scaling} parameter is used to scale every such line, generated by two randow points, that could be possibly located to far from each other, even at the distance of the diagonal of the unit square.

The arrays \texttt{xs} and \texttt{ys}, that contain the $x$ and $y$ coordinates of line points, are used to compute the minimal translation \texttt{v} needed to transport the entire set of data within the positive quadrant of the 2D plane. 

%-------------------------------------------------------------------------------
@D Generation of random lines
@{""" Generation of random lines """
def randomLines(numberOfLines=200,scaling=0.3):
    randomLineArray = [redge(scaling) for k in range(numberOfLines)]
    [xs,ys] = TRANS(CAT(randomLineArray))
    xmin, ymin = min(xs), min(ys)
    v = array([-xmin,-ymin])
    randomLineArray = [[list(v1+v), list(v2+v)] for v1,v2 in randomLineArray]
    return randomLineArray
@}
%-------------------------------------------------------------------------------


\paragraph{Generation of a random point}
A single random point, codified in floating point format, and with a fixed (quite small) number of digits, is returned by the \texttt{rpoint()} function, with no input parameters.
%-------------------------------------------------------------------------------
@D Generation of a random point
@{""" Generation of a random point """
def rpoint():
    return eval( vcode([ random.random(), random.random() ]) )
@}
%-------------------------------------------------------------------------------
    
\paragraph{Generation of a random line segment}
A single random segment, scaled about its centroid by the \texttt{scaling} parameter, is returned by the \texttt{redge()} function, as a tuple ot two random points in the unit square.
%-------------------------------------------------------------------------------
@D Generation of a random line segment
@{""" Generation of a random line segment """
def redge(scaling):
    v1,v2 = array(rpoint()), array(rpoint())
    c = (v1+v2)/2
    pos = rpoint()
    v1 = (v1-c)*scaling + pos
    v2 = (v2-c)*scaling + pos
    return tuple(eval(vcode(v1))), tuple(eval(vcode(v2)))
@}
%-------------------------------------------------------------------------------
    
\paragraph{Transformation of a 2D box into a closed polyline}
The transformation of a 2D box into a closed rectangular polyline, given as an ordered sequwncw of 2D points, is produced by the function \texttt{box2rect}
%-------------------------------------------------------------------------------
@D Transformation of a 2D box into a closed polyline
@{""" Transformation of a 2D box into a closed polyline """    
def box2rect(box):
    x1,y1,x2,y2 = box
    verts = [[x1,y1],[x2,y1],[x2,y2],[x1,y2],[x1,y1]]
    return verts
@}
%-------------------------------------------------------------------------------
    
\paragraph{Computation of the 1D centroid of a list of 2D boxes}
The 1D \texttt{centroid} of a list of 2D boxes is computed by the function given below.
The direction of computation (either $x$ or $y$) is chosen depending on the value of the \texttt{xy} parameter. 
%-------------------------------------------------------------------------------
@D Computation of the 1D centroid of a list of 2D boxes
@{""" Computation of the 1D centroid of a list of 2D boxes """    
def centroid(boxes,xy='x'):
    delta,n = 0,len(boxes)
    if xy=='x': a=0; b=2
    elif xy=='y': a=1; b=3
    for box in boxes:
        delta += (box[a] + box[b])/2
    return delta/n
@}
%-------------------------------------------------------------------------------


\bibliographystyle{amsalpha}
\bibliography{inters}

\end{document}
