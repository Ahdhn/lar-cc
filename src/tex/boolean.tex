\documentclass[11pt,oneside]{article}    %use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}        %Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}        %...ora4paperora5paperor...
%\geometry{landscape}        %Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}        %Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}                %Usepdf,png,jpg,orepswithpdflatex;useepsinDVImode
                                %TeXwillautomaticallyconverteps-->pdfinpdflatex        
\usepackage{amssymb}
\usepackage[colorlinks]{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{Boolean chains
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
\author{Alberto Paoluzzi}
%\date{}                            %Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\begin{abstract}
A novel algorithm for computation of Boolean operations between cellular complexes is given in this module.
It is based on bucketing of possibly interacting geometry using a box-extension of kd-trees, normally used for  point proximity queries. 
Such kd-tree representation of containment boxes of cells, allow us to compute a number of independent buckets of data to be used for local intersection, followed by elimination of duplicated data.
Actually we reduce the intersection of boundaries in 3D to the independent intersections of the buckets of (transformed) faces with the 2D subspace $z=0$, in order to reconstruct each splitted facet of boolean arguments, suitably transformed ther together with the bucket of indent facets.
A final tagging of cells as either belonging or not to each operand follows, allowing for fast extraction of Boolean results between any pair of chains (subsets of cells).
This Boolean algorithm can be considered of a \emph{Map-Reduce} kind, and hence suitable of a distributed implementation over big datasets. The actual engineered implementation will follow the present prototype, using some distributed NoSQL database, like MongoDB or Riak. 
\end{abstract}

\tableofcontents

%===============================================================================
\section{Introduction}
%===============================================================================


%===============================================================================
\section{Preview of the algorithm}
%===============================================================================

The whole Boolean algorithm is composed by four stages in sequence, denoted in the following as \emph{Unification}, \emph{Bucketing}, \emph{Intersection}, and \emph{Reconstruction}. The algorithm described here is both multidimensional and variadic. Multidimensional means that the arguments are solid in Euclidean space of dimension $d$, with $d$ small integer.
The \emph{arity}  of a function or operation is the number of arguments or operands the function or operation accepts. 
In computer science, a function accepting a variable number of arguments is called \emph{variadic}.

\subsection{Unification}
%===============================================================================

In this first step the boundaries of the $n$ Boolean arguments are computed and merged together as a set of chains defined in the discrete set $\texttt{V}$ made by the union of their vertices, and possibly by a discrete set of points generated by intersection of cells of complementary dimension, i.e. whose dimensions add up to the dimension of the ambient space.
Actually, only the (\emph{oriented}) boundaries \texttt{V,FV$_i$} $(1\leq i\leq n)$ of the varius arguments are retained here, and used by the following steps of the algorithm.

\subsection{Bucketing}
%===============================================================================

The bounding boxes of facets \texttt{FV$_i$} are computed, and their \emph{box-kd-tree} is worked-out, so providing a group of buckets of close cells, that can be elaborated independently, and possibly in parallel, to compute the intersections of the boundary cells. 

\subsection{Intersection}
%===============================================================================

For each facet $f$ of one of Boolean arguments, the subset $F(f)$ of incident or intersecting facets of boundaries of the other arguments were computed in the previous \emph{bucketing} step. So, each $F$ is transformed by the affine map that sends $f$ into the $z=0$ subspace, and there is intersected with this subspace, generating a subset $E(f)$ of coplanar edges.
This one is projected in 2D, and the \emph{regularized} cellular 2-complex $G(f)$ induced by it is computed, and mapped back to the original space position and orientation of $f$ (providing a partition of it induced by the other boundaries).

\subsection{Reconstruction}
%===============================================================================

Like for in the reconstruction of 2D solid cells using the angular ordering of edges around the vertices, the coincident edges are identified in 3D , and used to sort the incident faces sing vhe falues of solid angles given with one reference face.
The 3D space partition induced by $\cup_f G(f)$ is finally reconstructed, possibly in parallel, by traversing the adjacent sets of facets on the boundary of each solid cell.



%===============================================================================
\section{Implementation}
%===============================================================================

\subsection{Box-kd-tree}
%===============================================================================


\paragraph{Remove subsets from bucket list}
%-------------------------------------------------------------------------------
@D Remove subsets from bucket list @{
""" Remove subsets from bucket list """
def removeSubsets(buckets):
    n = len(buckets)
    A = zeros((n,n))
    for i,bucket in enumerate(buckets):
        for j,bucket1 in enumerate(buckets):
            if set(bucket).issubset(set(bucket1)):
                A[i,j] = 1
    B = AA(sum)(A.tolist())
    out = [bucket for i,bucket in enumerate(buckets) if B[i]==1]
    return out
@}
%-------------------------------------------------------------------------------
    


\paragraph{Iterate the splitting until \texttt{splittingStack} is empty}
%-------------------------------------------------------------------------------
@D Iterate the splitting until splittingStack is empty
@{""" Iterate the splitting until \texttt{splittingStack} is empty """
def boxTest(boxes,h,k):
    if len(boxes[0])==4:
        B1,B2,B3,B4 = boxes[k]
        b1,b2,b3,b4 = boxes[h]
        return not (b3<B1 or B3<b1 or b4<B2 or B4<b2)
    else:
        B1,B2,B3,B4,B5,B6,_ = boxes[k]
        b1,b2,b3,b4,b5,b6,_ = boxes[h]
        return not (b4<B1 or B4<b1 or b5<B2 or B5<b2 or b6<B3 or B6<b3)
        
def boxBuckets3d(boxes):
    bucket = range(len(boxes))
    splittingStack = [bucket]
    finalBuckets = []
    while splittingStack != []:
        bucket = splittingStack.pop()
        below,above = inters.splitOnThreshold(boxes,bucket,1)
        below1,above1 = inters.splitOnThreshold(boxes,above,2)
        below2,above2 = inters.splitOnThreshold(boxes,below,2) 
               
        below11,above11 = inters.splitOnThreshold(boxes,above1,3)
        below21,above21 = inters.splitOnThreshold(boxes,below1,3)        
        below12,above12 = inters.splitOnThreshold(boxes,above2,3)
        below22,above22 = inters.splitOnThreshold(boxes,below2,3)  
              
        inters.splitting(above1,below11,above11, finalBuckets,splittingStack)
        inters.splitting(below1,below21,above21, finalBuckets,splittingStack)
        inters.splitting(above2,below12,above12, finalBuckets,splittingStack)
        inters.splitting(below2,below22,above22, finalBuckets,splittingStack)
        
        finalBuckets = list(set(AA(tuple)(finalBuckets)))
    parts = inters.geomPartitionate(boxes,finalBuckets)
    parts = [[h for h in part if boxTest(boxes,h,k)] for k,part in enumerate(parts)]
    return AA(sorted)(parts)
@}
%-------------------------------------------------------------------------------


\subsection{Merging the boundaries}
%===============================================================================

\subsection{Elementary splitting}
%===============================================================================

In this section we implement the splitting of $(d-1)$-faces, stored in \texttt{FV}, induced by the buckets of $(d-1)$-faces, stored in \texttt{parts}, and one-to-one associated to them. Of course, (a) both such arrays have the same number of elements, and (b) whereas \texttt{FV} contains the indices of incident vertices for each face, \texttt{parts}  contains the indices of adjacent faces for each face, with the further constraint that $i \not\in \texttt{parts}(i)$.
    
\paragraph{Submanifold mapping computation}
The $4\times 4$ (affine) scipy matrix \texttt{transform} of type \texttt{mat} is computed by the function \texttt{submanifoldMapping}, using as input the array \texttt{pivotFace} that contains the vertices of the so-called \emph{pivot} face, i.e.~of the face to be mapped to the coordinate subspace $z=0$ (in 3D).

%-------------------------------------------------------------------------------
@D Submanifold mapping computation
@{""" Submanifold mapping computation """
def submanifoldMapping(pivotFace):
    tx,ty,tz = pivotFace[0]
    transl = mat([[1,0,0,-tx],[0,1,0,-ty],[0,0,1,-tz],[0,0,0,1]])
    facet = [ VECTDIFF([v,pivotFace[0]]) for v in pivotFace ]
    m = faceTransformations(facet)
    mapping = mat([[m[0,0],m[0,1],m[0,2],0],[m[1,0],m[1,1],m[1,2],0],[m[2,0],
                    m[2,1],m[2,2],0],[0,0,0,1]])
    transform = mapping * transl
    return transform

def submanifoldMapping(pivotFace):
    tx,ty,tz = pivotFace[0]
    transl = mat([[1,0,0,-tx],[0,1,0,-ty],[0,0,1,-tz],[0,0,0,1]])
    facet = [ VECTDIFF([v,pivotFace[0]]) for v in pivotFace ]
    normal = UNITVECT(COVECTOR(facet)[1:])
    a = normal
    b = [0,0,1]
    axis = UNITVECT(VECTPROD([a,b]))
    angle = math.atan2(VECTNORM(cross(a,b)), dot(a,b))    
    
    # general 3D rotation (Rodrigues' rotation formula)    
    m = scipy.identity(4)
    cos = COS(angle); sin = SIN(angle)
    I = scipy.identity(3) ; u = axis
    Ux = scipy.array([
        [0,        -u[2],      u[1]],
        [u[2],        0,     -u[0]],
        [-u[1],     u[0],         0]])
    UU = scipy.array([
        [u[0]*u[0],    u[0]*u[1],    u[0]*u[2]],
        [u[1]*u[0],    u[1]*u[1],    u[1]*u[2]],
        [u[2]*u[0],    u[2]*u[1],    u[2]*u[2]]])
    m[:3,:3] = cos*I + sin*Ux + (1.0-cos)*UU
    
    mapping = mat(m)
    transform = mapping * transl
    return transform
@}
%-------------------------------------------------------------------------------

\paragraph{Helper functions for spacePartition}

%-------------------------------------------------------------------------------
@D Helper functions for spacePartition
@{""" Helper functions for spacePartition """
import larcc
def submodel(V,FV,EV):
    lenV = len(V)
    VV = AA(LIST)(range(lenV))
    FE = larcc.crossRelation0(lenV,FV,EV)
    def submodel0(f,F):
        fE = list(set(FE[f] + CAT([FE[g] for g in F])))
        fF = [f]+F
        return fF,fE
    return submodel0

def meetZero( sW, (w1,w2) ):
    testValue = sW[w1][2] * sW[w2][2]
    if testValue > 10**-4: 
        return False
    else: return True

def segmentIntersection(p1,p2):
    (x1,y1,z1),(x2,y2,z2) = p1,p2
    if abs(z1-z2) != 0.0:
        alpha = z1/(z1-z2)
        x = x1+alpha*(x2-x1)
        y = y1+alpha*(y2-y1)
        return x,y,0.0
    else: return None
@}
%-------------------------------------------------------------------------------



\paragraph{Computation of affine face transformations}
The faces in every $\texttt{parts}(i)$ must be affinely transformed into the subspace $x_d=0$, in order to compute the intersection of its elements with this subspace, that are submanifolds of dimension $d-2$. 

A much better solution would be to compute a LU factorization of the the first columns of the U upper triangular or trapezoidal matrix ... see \href{http://stackoverflow.com/questions/15638650/is-there-a-standard-solution-for-gauss-elimination-in-python}{gauss-elimination-in-python}

%-------------------------------------------------------------------------------
@D Computation of affine face transformations
@{""" Computation of affine face transformations """
from numpy import array
from scipy.linalg import lu
from scipy.linalg.basic import det

def COVECTOR(points):
    pointdim = len(points[0])
    plane = Planef.bestFittingPlane(pointdim,
                    [item for sublist in points for item in sublist])
    return [plane.get(I) for I in range(0,pointdim+1)]

def faceTransformations(facet):
    #print "\nfacet =",facet
    covector = COVECTOR(facet)
    #print "\ncovector =",covector
    translVector = facet[0]
    #print "translVector =",translVector
    # translation 
    newFacet = [ VECTDIFF([v,translVector]) for v in facet ]
    #print "newFacet =",newFacet
    # linear transformation: boundaryFacet -> standard (d-1)-simplex
    if isclose(0.,covector[1]) and isclose(0.,covector[2]): ## x and y components ! (hpc format)
        m = mat(np.eye(3))
    else:
        d = len(facet[0])
        #print "d =",d
        m = mat( newFacet[1:d] + [covector[1:]] )
        #print "m =",m
        if abs(det(m))<0.0001:
            for k in range(len(facet)-2):
                m = mat( newFacet[1+k+1:d+k+1] + [covector[1:]] )
                #print "\nm =",m
                if abs(det(m))>0.0001: break
    transformMat = m.T.I
    #print "transformMat =",transformMat
    # transformation in the subspace x_d = 0
    out = (transformMat * (mat(newFacet).T)).T.tolist()
    #print "out =",out
    return transformMat
@}
%-------------------------------------------------------------------------------
    
\paragraph{Sorting of points along a line}

Parametric sorting of aligned points along the array \texttt{line}. 

%-------------------------------------------------------------------------------
@D Sorting of points along a line
@{""" Sorting of points along a line """
def computeSegments(line):
    p0 = line[0]
    p1 = line[1]
    p1_p0 = VECTDIFF([p1,p0])
    h = sorted([(X_k,k) for k,X_k in enumerate(p1_p0) if X_k!=0.0], reverse=True)[0][1]
    params = [(p[h]-p0[h])/p1_p0[h] for p in line]
    sortedPoints = TRANS(sorted(zip(params,line)))[1]
    segments = TRANS([sortedPoints[:-1],sortedPoints[1:]])
    return segments
@}
%-------------------------------------------------------------------------------

\paragraph{Remove intersection points external to a submanifold face}
When computing the LAR of each submanifold face embedded in $z=0$ hyperplane, it is necessary
to remove every vertex that was generated, outside the considered input face, by intersection of (incident) edges. This would produce spurious topology, i.e.~cells that do not find adjacents cells incident to their boundaries.
The LAR model \texttt{z,fz,ez} contains the 2-complex generated by decomposition of the $f$ face, possibly including some external parts.
Conversely, the \texttt{w,fw,ew} LAR model contains the original face before the decomposition, mapped to the $x_3=0$ submanifold.

%-------------------------------------------------------------------------------
@D Remove intersection points external to a submanifold face
@{""" Remove intersection points external to a submanifold face """
import boundary,inters

def veryClose(edge,p):
    ((x1,y1),(x2,y2)),(x0,y0) = edge,p
    distance = ABS((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1) / VECTNORM(VECTDIFF([(x1,y1),(x2,y2)]))
    if distance <= 0.00001: return True
    return False
    
def removeExternals(M,V,EV,fe,fv, z,fz,ez):
    w,fw,ew = struct2lar(Struct([larApply(M)((V,[fv],[EV[e] for e in fe]))])) # part mapped to 2D
    newEdges = boundary.larOffset2D(([v[:-1] for v in w],fw,ew),offset=0.0001)

    #w,fw,ew,_ = inters.larFromLines(newEdges)
    w,ew = bruteForceIntersect(newEdges)
    w,polygons,ew = triangulation.larPair2Triple((w,ew))
    fw = AA(list)(AA(set)(AA(CAT)(polygons)))

    pol = w,ew
    out = []
    classify = triangulation.pointInPolygonClassification(pol)
    for k,point in enumerate(z):
        if classify(point)=="p_out":  out += [k]

    # verify all v in out w.r.t. pol[0]
    trueOut = []
    w = pol[0]
    for k in out: 
        p = z[k]
        onBoundary = False
        for u,v in pol[1]:
            if veryClose((w[u],w[v]),p):
                onBoundary = True
                z[k] = p
        if not onBoundary: trueOut += [k]
    
    fw = [f for f in fz if not any([v in trueOut for v in f])]  # trueOut
    ew = [e for e in ez if not any([v in trueOut for v in e])]  # trueOut
    return z,fw,ew
        
#VIEW(STRUCT(AA(MK)([z[k] for k in set(range(len(z))).difference(out)])))
#VIEW(STRUCT(AA(MK)(z)))
#VIEW(EXPLODE(1.2,1.2,1)(AA(COLOR(CYAN))(MKPOLS((z,ez)))+AA(COLOR(YELLOW))(MKPOLS((w,ew)))))
@}
%-------------------------------------------------------------------------------

\paragraph{Polygon on steroid}
In order to make robust the point-in-polygon containment test (at least w.r.t.~the interior/exterior dicotomy), it is nececessary to grow the target polygon towards its exterior, in order to nullify the numerical uncertainty of containment of points very close to the polygon boundary.
The input polygon is supposed to be a LAR model \texttt{V,EV}, and may be non convex and even contain internal holes. The output is a grown polygon \texttt{W,EW}, with one-to-one mapping of edges. The algorithm, linear in the number of (oriented) edges, may be decomposed in a sequence of $O(n)$ steps, where $n$ is the number of edges.
%-------------------------------------------------------------------------------
@D Polygon on steroid
@{""" Polygon on steroid: growing a general polygon towards its exterior """
def polygonOnSteroid(model):
    V,EV = model
    # computation of (oriented) polygon cycles
    
    # computation of (external) straight lines
    
    # intersection of adjacent lines
    
    # output of grown model
@}
%-------------------------------------------------------------------------------

\paragraph{Space partitioning via submanifold mapping}

the function \texttt{spacePartition}, given in the below script, takes as input a \emph{non-valid} (with the meaning used in solid modeling field --- see~\cite{Requicha:1980:RRS:356827.356833}) \texttt{LAR} model of dimension $d-1$, i.e.~a triple \texttt{(V,FV,EV)}, and an array \texttt{parts} indexed on faces, and containing the subsets of faces with greatest probability of intersecting each indexing face, respectively. The \texttt{spacePartition} function returns the \emph{valid} \texttt{LAR} boundary model \texttt{(W,FW,EW)} of the space partition induced by \texttt{FV}.
 
%-------------------------------------------------------------------------------
@D Space partitioning via submanifold mapping
@{""" Space partitioning via submanifold mapping """
import larcc,inters,triangulation
from larcc import *

def lineExtend(epsilon):
	def lineExtend1(line):
		((x1,y1),(x2,y2)) = line
		def x(a): return x1 + a*(x2-x1)
		def y(a): return y1 + a*(y2-y1)
		return ((x(-epsilon),y(-epsilon)),(x(1+epsilon),y(1+epsilon)))
	return lineExtend1

def spacePartition(V,FV,EV, parts):
    VV = AA(LIST)(range(len(V)))
    FE = larcc.crossRelation(FV,EV,VV)
    submodel0 = submodel(V,FV,EV)
    out = []
    def isClose(a,b): return abs(a-b)<10**-5
    
    """ input: face index f; candidate incident faces F[f]; """
    for f,F in enumerate(parts):
        print "\n\nf,F =",f,F
        """ Selection of the LAR submodel S(f) := (V,FV,EV)(f) restricted to [f]+F[f] """    
        fF,fE = submodel0(f,F)
        sbModel = Struct([(V,[FV[g] for g in fF],[EV[h] for h in fE])])
        sV,sFV,sEV = struct2lar(sbModel)
        #VIEW(STRUCT(MKPOLS((sV,sFV+sEV)) + [COLOR(RED)(STRUCT(MKPOLS((V,[FV[f]]))))]))
        
        """ Computation of submanifold map M moving f to z=0 """
        pivotFace = [V[v] for v in FV[f]]
        M = submanifoldMapping(pivotFace)  # submanifold transformation
        
        """ Transformation of S(f) by M, giving S = (sW,sEW) := M(S(f)) """
        sW,sFW,sEW = larApply(M)((sV,sFV,sEV))
        
        red = COLOR(RED)(STRUCT(MKPOLS(larApply(M)((V,[FV[f]])))))
        #VIEW(STRUCT(MKPOLS((sW,sFW+sEW)) + [red]))
        
        """ filtering of EW edges traversing z=0, giving EZ edges and incident faces FZEZ """
        sFE = larcc.crossRelation0(len(V),sFW,sEW)    
        alledges = list(set([ e for k,face in enumerate(sFW)  for e in sFE[k] 
                    if meetZero(sW, sEW[e]) ]))
        edgesPerFace = [ [e for e in sFE[k] if meetZero(sW, sEW[e])] 
                    for k,face in enumerate(sFW) ]
        edges = list(set(CAT(edgesPerFace)))
        
        wires = [sEW[e] for e in edges]
        #VIEW(STRUCT(MKPOLS((sW,wires)) + [red]))
        
        """ for each face in FZEZ, computation of the aligned set of points p(z=0) """
        
        edges2D = [[w1,w2] for w1,w2 in wires if (isClose(0,sW[w1][2]) and isClose(0,sW[w2][2]))]
        lines2d = [[sW[u][:-1],sW[v][:-1]] for u,v in edges2D] + computeCrossingLines(
                    edges,sW,sFW,sEW,sFE)
                    
        lines2D = AA(lineExtend(0.0001))(lines2d)
        #lines2D = AA(AA(COMP([eval,vcode(0.0000000000001)])))(lines2d)          

        #VIEW(STRUCT(AA(POLYLINE)(lines2D) ))#+ [red]))
        
        u,fu,eu,_ = inters.larFromLines(lines2D)
        u,polygons,eu = triangulation.larPair2Triple((u,eu))
        fu = AA(list)(AA(set)(AA(CAT)(polygons)))
        
        z,fz,ez = u,fu,eu
        
        #Remove external vertices 
        z,fz,ez = removeExternals(M,V,EV,FE[f],FV[f], u,fu,eu)  # BUG !!!!  <<<<<<<<<<
        #VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((z,fz+ez))))
        
        
        w,fw,ew = larApply(M.I)(([v+[0.0] for v in z],fz,ez))
        #VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((w,fw+ew))))
        out += [Struct([(w,fw,ew)])]
    return struct2lar(Struct(out))
@}
%-------------------------------------------------------------------------------

\paragraph{Compute face intersections with z=0}
%-------------------------------------------------------------------------------
@D Compute face intersections with z=0
@{""" Compute face intersections with z=0 """
def computeCrossingLines(edges,sW,sFW,sEW,sFE):
	crossEdges = []
	def isClose(a,b): return abs(a-b)<10**-5
	for e in edges:
		z1,z2 = sW[sEW[e][0]][2], sW[sEW[e][1]][2]
		cross = False
		if isClose(z1,z2):	cross=False
		elif z1*z2 < 0:		cross=True
		elif isClose(0.,z1*z2): cross=True
		else: cross = False
		if cross: crossEdges += [e]	
	if crossEdges != []:
		#VIEW(STRUCT(MKPOLS((sW,[sEW[e] for e in crossEdges]))))
		sEF = invertRelation(sFE)
		crossFaces = list(set(CAT([sEF[e] for e in crossEdges])))
		#VIEW(STRUCT(MKPOLS((sW,[sFW[f] for f in crossFaces]+[sEW[e] for e in crossEdges]))))
		#VIEW(STRUCT(MKPOLS((sW,[sEW[e] for e in crossEdges]))))
		edgeCrossSets = [list(set(crossEdges).intersection(sFE[f])) for f in crossFaces]		
		
		def points2lines(pointSet):
			#	preconditions:
			#	1.	len(pointSet) > 2;
			#	2.	2D points in pointSet are aligned.
			pointSet = list(set(AA(tuple)(AA(eval)(AA(vcode(6))(pointSet)))))
			# postcondition: pointSet has even length
			if len(pointSet) == 2: return [pointSet]
			lines = []
			p1,p2 = pointSet[:2]
			# TODO: multiple lines
			return lines

		pointSets2d = []
		for Set in edgeCrossSets:
			pts2d = []
			for edge in Set:
				v1,v2 = [sW[v] for v in sEW[edge]]
				[x1,y1,z1], [x2,y2,z2] = v1, v2
				u = z1/(z1-z2)
				p2d = x1 + u*(x2-x1), y1 + u*(y2-y1)
				pts2d += [p2d]
			pointSets2d += [pts2d]

		crossingLines = []
		for pointSet in pointSets2d:
			if len(pointSet)==2:
				crossingLines += [pointSet]
			else:
				crossingLines += points2lines(pointSet)

		return crossingLines
	else: return []
@}
%-------------------------------------------------------------------------------


\paragraph{Brute-force intersection of 2D lines}
%-------------------------------------------------------------------------------
@D Brute-force intersection of 2D lines
@{""" Brute-force intersection of 2D lines """
def bruteForceIntersect(lines):
	n = len(lines)
	#transform data
	lines = [[eval(vcode(4)(p)) for p in line] for line in lines]
	#end transform
	verts = list(set([tuple(v) for line in lines for v in line]))
	vertdict = OrderedDict([(key,k) for k,key in enumerate(verts)])
	EV = [[vertdict[tuple(p)] for p in line] for line in lines]
	pairs = [(h,k) for h in range(n) for k in range(h+1,n)]
	linepairs = [[lines[h],lines[k]] for h,k in pairs]
	# prepare data for line pairs
	linedata = [[ax,ay,bx,by,cx,cy,dx,dy] 
		for [[(ax,ay),(bx,by)],[(cx,cy),(dx,dy)]] in linepairs]
	# assemble intersection determinants
	determinants = [ det(mat([[ax-bx,dx-cx], [ay-by,dy-cy]])) 
		for [ax,ay,bx,by,cx,cy,dx,dy] in linedata]
	# parameter pairs by Cramer's rule (for oriented edges of f face)
	alpha = [det(mat([[dx-bx,dx-cx],[dy-by,dy-cy]]))/D  if abs(D)>.00001 else 0 
		for D,(ax,ay,bx,by,cx,cy,dx,dy) in zip(determinants,linedata)]
	beta = [det(mat([[ax-bx,dx-bx],[ay-by,dy-by]]))/D  if abs(D)>.00001 else 0 
		for D,(ax,ay,bx,by,cx,cy,dx,dy) in zip(determinants,linedata)]
	# intersection points
	vdata,edata = defaultdict(list),defaultdict(list)
	newverts = [ tuple(AA(COMP([tuple,eval,vcode(4)]))([ 
		(a*mat(p1)+(1-a)*mat(p2)).tolist()[0], 
		[a,b,h,k] ]))
		for (a,b,(h,k)),[[p1,p2],[q1,q2]] in zip(zip(alpha,beta,pairs),linepairs) 
		if 0<=a<=1 and 0<=b<=1 ]
	for vert,datum in newverts:
	   vdata[vert] += [datum]
	for k,(key,datum) in enumerate(vdata.items()):
		for a,b,edge1,edge2 in datum:
			edata[int(edge1)] += [a]
			edata[int(edge2)] += [b]
	edgeParameters = [sorted(set(edge)) for k,edge in edata.items()]
	points = [[(a*mat(verts[p])+(1-a)*mat(verts[q])).tolist()[0] 
			for a in params] for params,(p,q) in zip(edgeParameters,EV)]
	m = len(vertdict)
	for point in CAT(points):
		vertex = tuple(eval(vcode(4)(point)))
		if not vertex in vertdict:
			vertdict[vertex] = m
			m += 1
	edgeVerts = [[vertdict[tuple(eval(vcode(4)(point)))] for point in edge] 
		for edge in points]
	V = AA(list)(vertdict.keys())
	edges = [[[v,part[k+1]] for k,v in enumerate(part[:-1])] for part in edgeVerts]
	EV = sorted(set(AA(tuple)(AA(sorted)(CAT(edges)))))
	return V,EV
@}
%-------------------------------------------------------------------------------



\subsection{Circular ordering of faces around edges}



\paragraph{3D boundary triangulation of the space partition}
The function \texttt{boundaryTriangu\-la\-tion} given below is used to guarantee that there is a unique (simple) facet incident to an edge and contained in one LAR facet. More clearly, the Boolean decompositions generated by LAR allow for non convex cells, and in particular for nonconvex boundary facets of $d$-cells. This fact may induce errors in the computation of circularly sorted faces around edges. Conversely, by decomposing the faces into triangles, such ordering problems cannot appear.  
We also note that whereas every $(d-1)$-facet is made by coherently oriented triangles, it is not possible to give---a priori---a coherently orientation to all the facets, since the object interior and exterior are not defined (for now).

%-------------------------------------------------------------------------------
@D 3D boundary triangulation of the space partition 
@{""" 3D boundary triangulation of the space partition """

def orientTriangle(pointTriple):
    v1 = array(pointTriple[1])-pointTriple[0]
    v2 = array(pointTriple[2])-pointTriple[0]
    if cross(v1,v2)[2] < 0: return REVERSE(pointTriple)
    else: return pointTriple
    
from copy import copy
from scipy import spatial

def boundaryTriangulation(V,FV,EV,FE):
    triangleSet = []  
        
    def mapVerts(inverseMap):
        def mapVerts0(mappedVerts):
            return (inverseMap * (mat(mappedVerts).T)).T.tolist()
        return mapVerts0
        
    for f,face in enumerate(FV):
        triangledFace = []
        EW = [EV[e] for e in FE[f]]
        pivotFace = [V[v] for v in face]
        vertdict = dict([(w,v) for v,w in enumerate(face)])
        EW = [[vertdict[w] for w in edge] for edge in EW]
        transform = submanifoldMapping(pivotFace)
        mappedVerts = (transform * (mat([p+[1.0] for p in pivotFace]).T)).T.tolist()
        verts2D = [point[:-2] for point in mappedVerts] 
              
        # Construction of CDT (Constrained Delaunay Triangulation) for LAR face
        model = (verts2D,[range(len(verts2D))],EW)
        struct = Struct([model])
        U,EU = triangulation.structBoundaryModel(struct)
        W,FW,EW,polygons = inters.larFromLines([[U[u],U[v]] for u,v in EU])

        def filtering(polygons):
            if len(polygons)>1 and max(AA(len)(polygons))==1:
                poly = sorted(CAT(polygons),key=len,reverse=True)
                poly = [poly[0] for comp in poly[1:] if set(comp).issubset(set(poly[0]))]
                return [poly]
            else: return polygons

        thePolygons = filtering(polygons)
        setsOfTriangles = triangulation.polygons2TriangleSet(W,thePolygons)
        if setsOfTriangles != []:
            trias = [[p+[1],q+[1],r+[1]] for p,q,r in setsOfTriangles[0]]
            
            inverseMap = transform.I
            trias = AA(mapVerts(inverseMap))(trias)
            triangledFace += [[v[:-1] for v in triangle] for triangle in trias]
            triangleSet += [triangledFace]
    return triangleSet

def triangleIndices(triangleSet,W):
    tree = spatial.cKDTree(W)
    TV,FT,t = [],[],-1
    for face in triangleSet:
        ft = []
        for triangle in face:
            vertices = tree.query(triangle,1)[1].tolist()
            t += 1
            TV += [vertices]
            ft += [t]
        FT += [ft]
    #VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((W,TV))))
    return TV,FT
@}
%-------------------------------------------------------------------------------




\paragraph{Computation of incidence between edges and 3D triangles}
%-------------------------------------------------------------------------------
@D Computation of incidence between edges and 3D triangles @{
def edgesTriangles(EF, FW, TW, EW):
    ET = [None for k in range(len(EF))]
    for e,edgeFaces in enumerate(EF):
        ET[e] = []
        for f in edgeFaces:
            for t in TW[f]:
                if set(EW[e]).intersection(t)==set(EW[e]):
                    ET[e] += [t]
    return ET
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/3Dtriangulation} 
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/3Dtriangulation2} 
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/3Dtriangulation3} 
   \caption{The triangulated boundaries of the space partition induced by two cubes (one is variously translated).}
   \label{fig:3Dtriangulation}
\end{figure}

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/edgeTriangles1} 
   \includegraphics[height=0.325\linewidth,width=0.325\linewidth]{images/edgeTriangles} 
   \caption{The triangles around an edge: \texttt{VIEW(STRUCT(MKPOLS((W,ET[35]))))}.}
   \label{fig:3Dtriangulation}
\end{figure}

\paragraph{Example}

{\small
\begin{verbatim}
In [2]: ET[35]
Out[2]: [[19, 7, 8], [6, 8, 7], [8, 7, 16], [4, 7, 8]]

In [3]: EF[35]
Out[3]: [4, 10, 11, 14]

In [4]: [FW[f] for f in  EF[35]]
Out[4]: [(19, 7, 8, 12), (6, 10, 8, 7), (12, 8, 7, 16, 1, 2), (4, 5, 6, 7, 8, 9)]

In [5]: EW[35]
Out[5]: (7, 8)
\end{verbatim}}



\paragraph{Slope of edges}

The \texttt{faceSlopeOrdering} function, given in the script below, return the list \texttt{EF\_angle} of lists of faces incident to the model edges, counterclockwise ordered with respect to the orientation of the edge. Let us remember that the edges are naturally oriented from the vertex of lesser index to that of greater index.

%-------------------------------------------------------------------------------
@D Slope of edges
@{""" Circular ordering of faces around edges """

def planeProjection(normals):
    V = mat(normals)
    if all(V[:,0]==0): V = np.delete(V, 0, 1)
    elif all(V[:,1]==0): V = np.delete(V, 1, 1)
    elif all(V[:,2]==0): V = np.delete(V, 2, 1)
    return V

def faceSlopeOrdering(model,FE):
    V,FV,EV = model
    #VIEW(COLOR(YELLOW)(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,EV)))))
    triangleSet = boundaryTriangulation(V,FV,EV,FE) # corrected with non-contractible faces
    #VIEW(EXPLODE(1.2,1.2,1.2)(AA(JOIN)( AA(POLYLINE)(CAT(triangleSet)) )))
    #VIEW(EXPLODE(1.2,1.2,1.2)( AA(POLYLINE)(AA(lambda tri: tri+[tri[0]])(CAT(triangleSet))) ))
    TV,FT = triangleIndices(triangleSet,V) 
    VV = AA(LIST)(range(len(V)))
    TE = crossRelation(TV,EV,VV)
    ET,ET_angle = invertRelation(TE),[]
    #import pdb; pdb.set_trace()
    for e,et in enumerate(ET):
        if et != []:
            v1,v2 = EV[e]
            v1v2 = set([v1,v2])
            et_angle = []
            t0 = et[0]
            tverts = [v1,v2] + list(set(TV[t0]).difference(v1v2))
            e3 = UNITVECT(VECTDIFF([ V[tverts[1]], V[tverts[0]] ]))
            e1 = UNITVECT(VECTDIFF([ V[tverts[2]], V[tverts[0]] ]))
            e2 = cross(array(e1),e3).tolist()
            basis = mat([e1,e2,e3]).T
            transform = basis.I
            normals = []
            Tvs = []
            for triangle in et:
                verts = TV[triangle]
                vertSet = set(verts).difference(v1v2)
                tvs = [v1,v2] + list(vertSet)
                Tvs += [tvs]
                w1 = UNITVECT(VECTDIFF([ V[tvs[2]], V[tvs[0]] ]))
                w2 = (transform * mat([w1]).T).T
                w3 = cross(array([0,0,1]),w2).tolist()[0]
                normals += [w3]
            normals = mat(normals)
            for k,t in enumerate(et):
                angle = math.atan2(normals[k,1],normals[k,0])
                et_angle += [angle]
            pairs = sorted(zip(et_angle,et,Tvs))
            sortedTrias = [pair[1] for pair in pairs]
            triasVerts = [pair[2] for pair in pairs]
            ET_angle += [sortedTrias]
    EF_angle = ET_to_EF_incidence(TV,FV,FT, ET_angle)
    return EF_angle, ET,TV,FT
@}
%-------------------------------------------------------------------------------



\paragraph{Edge-triangles to Edge-faces incidence}

In the function \texttt{ET\_to\_EF\_incidence} below, we convert the Edge-triangles incidence table \texttt{ET\_angle} to a Edge-faces incidence table \texttt{EF\_angle}. The input data to the algoritm are the relations \texttt{TW,FW}, and, of course, the incidence \texttt{ET\_angle}. It works by computing two translationa tables \texttt{tableFT} and \texttt{tableTF} from face indices to triangle indices and viceversa. Of course, \texttt{assert( len(EF\_angle) == 2*len(FW) )} must be \texttt{True}.

%-------------------------------------------------------------------------------
@D Edge-triangles to Edge-faces incidence
@{""" Edge-triangles to Edge-faces incidence """
def ET_to_EF_incidence(TW,FW,FT, ET_angle):
    tableFT = FT
    tableTF = invertRelation(tableFT)
    EF_angle = [[tableTF[t][0] for t in triangles] for triangles in ET_angle]
    #assert( len(EF_angle) == 2*len(FW) )
    return EF_angle
@}
%-------------------------------------------------------------------------------


\paragraph{Cells from $(d-1)$-dimensional LAR model}
Since faces in the space partition induced by overlaping 3-coverings are $(d-1)$-cells, they are located on the boundary of \emph{two} $d$-cells of the partition. Hence, the traversal algorithm of the data structure storing the relevant information may be driven by signing the two cofaces of each face as being either already visited or not.


\subsection{Progressive reconstruction of 3-cell boundaries}

The input to this stage is a 2-complex embedded in 3D, with 2-cells non necessarily convex. The output is the 3-space partition defined by the cellular 3-complex, whose 2-skeleton is the inpiut complex. In other words, we mu reconstruct the 3-cells induced by the 2-cells of the input complex. This is done reconstructing the 3-cells stepwise. Each 3-cell reconstruction is done starting from one \texttt{face} two-dimensional previously taken into account no more than one single time, so that every 2-face is used at most exacly twice. An example of use of the functions implemented in this section is given in example \texttt{test12.py}

\paragraph{Edge cycles associated to a closed chain of edges}

The problem here is to conserve in the new \texttt{cycles} the same orientation of the previous ones,
passed through the \texttt{orientedEdges} variable. We can formalize the problem as follows. Let call \texttt{pcycles} (for ``previous cycles'') and \texttt{fcycle} (for ``face cycle'') the algorithm input. the output is the \emph{coherently oriented} \texttt{outcycles}. First, an orientation is given to \texttt{fcycle}; then this one is compared with the \texttt{pcycles} orientation, and it is possibly reversed, in order to get them coherently oriented. Finally, the direct sum of \texttt{pcycles} and \texttt{fcycle} is executed, giving the \texttt{outcycles}.

%-------------------------------------------------------------------------------
@D Cycles orientation
@{""" Cycles orientation """
import triangulation
def cyclesOrient(pcycles,fcycle,EV):
    if set(AA(ABS)(pcycles)).difference(fcycle)==set(): return []
    ofcycle,_ = triangulation.boundaryCycles(fcycle,EV) # oriented 
    ofcycle = ofcycle[0] # oriented 
    if type(pcycles[0])==list: opcycle = CAT(pcycles)
    else: opcycle = pcycles
    int = set(opcycle).intersection(ofcycle)
    if int != set(): 
        ofcycle = reverseOrientation(ofcycle)
    outChain = [e for e in ofcycle if not (-e in opcycle)] 
    outChain += [e for e in opcycle if not (-e in ofcycle)] 
    return outChain

if __name__ == "__main__":
    pcycles = [[-19, 13, 22, 23]]
    fcycle = [30, 20, 18, 2, 26, 19]
    #cyclesOrientation(pcycles,fcycle)
@}
%-------------------------------------------------------------------------------

\paragraph{3-cell traversal}
The following script contains a completely reviewed and rewritten version of the extraction of 3-cells from its 2-skeleton embedded in 3D. The number of boundary edges of general LAR 2-faces is given by \texttt{len(EF\_angle)} or by \texttt{len(ET)}. The array \texttt{len(EV)} has length \texttt{len(EF\_angle)} + the number of added edges due to the triangulation of original faces. The added edges are not returned inside \texttt{FE} and \texttt{EF\_angle}.
%-------------------------------------------------------------------------------
@D 3-cell traversal
@{

@}
%-------------------------------------------------------------------------------


\paragraph{The 3-cell traversal algorithm}
Initially, the list of counterclockwise ordered faces around the oriented edges are computed, and stored as indexed by edges in the \texttt{EF\_angle} list of lists. This information is stored in the compressed sparse row matrix \texttt{csrEF}, whose element $(e,f)$ provides the \emph{next} face index  incident on edge $e$, after $f$. 

Also, a list of list of zeros is stored in the \texttt{visitedFE} variable, in order to memorize the visited pairs $(f,e)$ by writing one in their corresponding positions. The \texttt{firstSearch} function will so retrieve the first non visited pair, in order to start the extraction of a new 3-cell. The \texttt{cv} variable accumulates the vertex indices of the current 3-cell. When the 3-cell is completely extracted (how-to test?), will be stored as a new row in the \texttt{CV} relation. 

The test for completeness of the extraction is done by computing the current boundary of the cell as a set of edges of faces, by python \texttt{XOR} of the edges of every accumulated face-edge relation. When this set it becomes empty, the 3-cell extraction is completed.
%-------------------------------------------------------------------------------
@D Cells from $(d-1)$-dimensional LAR model
@{""" Cells from $(d-1)$-dimensional LAR model """

def facesFromComponents(model,FE,EF_angle):
    import triangulation

    accumulated = []
    def viewStep (CF,CV,CE,COE,accumulated):
        VV = AA(LIST)(range(len(V)))
        edges = list(set(CE[-1]).difference(accumulated))
        accumulated = CE[-1]
        submodel = STRUCT(MKPOLS((V,[EV[k] for k in edges])))
        #VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV],submodel,1))

    # initialization
    V,FV,EV = model
    visitedCell = [[ None, None ] for k in range(len(FV)) ]
    face = 0
    boundaryLoop,_ = triangulation.boundaryCycles(FE[face],EV)
    boundaryLoop = boundaryLoop[0]
    firstEdge = boundaryLoop[0]
    #import pdb; pdb.set_trace()
    cf,coe = getSolidCell(FE,face,visitedCell,boundaryLoop,EV,EF_angle,V,FV)
    for face,edge in zip(cf,coe):
        if visitedCell[face][0]==None: visitedCell[face][0] = edge
        else: visitedCell[face][1] = edge
    cv,ce = set(),set()
    cv = cv.union(CAT([FV[f] for f in cf]))
    ce = ce.union(CAT([FE[f] for f in cf]))
    CF,CV,CE,COE = [cf],[list(cv)],[list(ce)],[coe]
    viewStep (CF,CV,CE,COE,accumulated)
    
    # main loop
    #import pdb; pdb.set_trace()
    while True:
        face, edge = startCell(visitedCell,FE,EV)
        if face == -1: break
        boundaryLoop,_ = triangulation.boundaryCycles(FE[face],EV)
        boundaryLoop = boundaryLoop[0]
        if edge not in boundaryLoop:
            boundaryLoop = reverseOrientation(boundaryLoop)
        cf,coe = getSolidCell(FE,face,visitedCell,boundaryLoop,EV,EF_angle,V,FV)
        CF += [cf]
        COE += [coe]
        for face,edge in zip(cf,coe):
            if visitedCell[face][0]==None: visitedCell[face][0] = edge
            else: visitedCell[face][1] = edge
            
        cv,ce = set(),set()
        cv = cv.union(CAT([FV[f] for f in cf]))
        ce = ce.union(CAT([FE[f] for f in cf]))
        CV += [list(cv)]
        CE += [list(ce)]
        viewStep (CF,CV,CE,COE,accumulated)
    return V,CV,FV,EV,CF,CE,COE
@}
%-------------------------------------------------------------------------------
    

\paragraph{Start a new 3-cell}
The function \texttt{startCell} below is used to begin the extraction of a new 3-cell (after the first one was already extracted). Therefore its aim is to choose as first face one already previously extracted, in order to begin the current boundary with one cycle coherently oriented. This will is implemented by looking for a ``\texttt{face}'' position stored in \texttt{visitedCell} with just one \texttt{None} value in its row.

%-------------------------------------------------------------------------------
@D Start a new 3-cell
@{""" Start a new 3-cell """
def startCell(visitedCell,FE,EV):
    if len([term for cell in visitedCell for term in cell if term==None])==1: return -1,-1
    for face in range(len(visitedCell)):
        if len([term for term in visitedCell[face] if term==None])==1:
            edge = visitedCell[face][0]
            break
        else: pass  #TODO: implement search for isolated shells
        face,edge = -1,-1
    return face,edge
@}
%-------------------------------------------------------------------------------

\paragraph{Face orientations storage}

In order to correctly accomplish the extraction of 3-cells from the 2-complex partition of the arguments' space, it is necessary to use twice every 2-face, belonging with opposite orientations to the boundaries of two adjacent 3-cells. The array \texttt{faceOrientations}, initializated to $n\times 2$ zeros, with $n$ equal to the number of 2-cells, is so used to store the orientations of faces considered as 2-cycles of edges. 

In particular, the orientation of the 2-face is equivalent to the embedded orientation of one of its edges, corresponding either to the intrinsic orientation of this one, or to its opposite orientation. Hence, every time a face is used during the extraction of a 3-cell, (the elementary 1-chain of) one of its oriented edges is stored in \texttt{faceOrientations}, to remember its orientation, and eventually reverse the orientation of the face the next time it is used again. At the very end of the extraction algorithm, all the faces must be used twice, with opposite orientations. 

%-------------------------------------------------------------------------------
@D Face orientations storage
@{""" Face orientations storage """
import triangulation

def reverseOrientation(chain):
    return REVERSE([-cell for cell in chain])

def faceOrientation(boundaryLoop,face,FE,EV,cf):
    theBoundary = set(AA(ABS)(boundaryLoop))
    if theBoundary.intersection(FE[face])==set() and theBoundary.difference(FE[face])!=set(): ##BOH!!
        coboundaryFaces = [f for f in cf if set(FE[f]).intersection(theBoundary)!=set()]
        face = coboundaryFaces[0]            
    faceLoop,_ = triangulation.boundaryCycles(FE[face],EV)
    faceLoop = faceLoop[0]
    commonEdges = set(faceLoop).intersection(boundaryLoop)
    if commonEdges == set() or commonEdges == {0}: 
        faceLoop = reverseOrientation(faceLoop)
        commonEdges = set(faceLoop).intersection(boundaryLoop)
    theEdge = list(commonEdges)[0]
    #if theEdge==0: theEdge = list(commonEdges)[1]
    return -theEdge,face
@}
%-------------------------------------------------------------------------------

\paragraph{Get single solid cell}

%-------------------------------------------------------------------------------
@D Get single solid cell
@{""" Get single solid cell """
def getSolidCell(FE,face,visitedCell,boundaryLoop,EV,EF_angle,V,FV):

    def orientFace(face,boundaryLoop): 
        for e in boundaryLoop:
            if ABS(e) in FE[face]: return -e

    coe = [orientFace(face,boundaryLoop)]
    cf = [face] 
    #import pdb; pdb.set_trace()
    while boundaryLoop != []:
        edge,face = faceOrientation(boundaryLoop,face,FE,EV,cf)
        if edge > 0: edgeFaces = EF_angle[edge]
        elif edge < 0: edgeFaces = REVERSE(EF_angle[-edge])
        e = ABS(edge)
        n = len(edgeFaces)
        ind = (edgeFaces.index(face)+1)%n
        nextFace = edgeFaces[ind]
        coe += [-orientFace(nextFace,boundaryLoop)]
        boundaryLoop = cyclesOrient(boundaryLoop,FE[nextFace],EV)
        cf += [nextFace] 
        face = nextFace
        #VIEW(STRUCT( MKPOLS((V,[EV[h] for f in cf for h in FE[f]])) )) #add EV!
    return cf,coe
@}
%-------------------------------------------------------------------------------

\paragraph{Double check the faces boundaries made of edges}
Let us notice that a sistematic use of the \texttt{FE} relation to compute the edges on the boundary of a face is \emph{not} reliable when the faces are non-convex (WHY ??). A better solution is to double-check the result \texttt{FE[f]} when \texttt{len(FE[f]) > len(FV[f])}, in order to filter out the spurious edges ...
The function below works with the precondition that vertices in \texttt{FV[f]} are spatially ordered along the face boundary.

%-------------------------------------------------------------------------------
@D Double check the faces boundaries made of edges
@{""" Double check the faces boundaries made of edges """
def doubleCheckFaceBoundaries(FE,V,FV,EV):
    FEout = []
    for f,face in enumerate(FE):
        n = len(FV[f])
        if len(FE[f]) > n:
            # contains both edges coded 0 and 1 ... (how to solve?)
            FEout += [list(set(face).difference([0]))]
        else:
            FEout += [face]
    return FEout
@}
%-------------------------------------------------------------------------------


\subsubsection{Main procedure of arrangement partitioning}

%-------------------------------------------------------------------------------
@D Main procedure of arrangement partitioning
@{""" Main procedure of arrangement partitioning """
import inters,triangulation

@< Double check the faces boundaries made of edges @>

def thePartition(W,FW,EW):
    quadArray = [[W[v] for v in face] for face in FW]
    parts = boxBuckets3d(containmentBoxes(quadArray))
    Z,FZ,EZ = spacePartition(W,FW,EW, parts)
    Z,FZ,EZ = inters.larSimplify((Z,FZ,EZ),radius=0.0001)
    model = Z,FZ,EZ

    ZZ = AA(LIST)(range(len(Z)))
    submodel = STRUCT(MKPOLS((Z,EZ)))
    VIEW(larModelNumbering(1,1,1)(Z,[ZZ,EZ,FZ],submodel,0.6)) 

    ZZ = AA(LIST)(range(len(Z)))
    FE = crossRelation(FZ,EZ,ZZ) ## to be double checked !!
    EF_angle, ET,TV,FT = faceSlopeOrdering(model,FE)
    
    V,CV,FV,EV,CF,CE,COE = facesFromComponents((Z,FZ,EZ),FE,EF_angle)
    return V,CV,FV,EV,CF,CE,COE,FE
@}
%-------------------------------------------------------------------------------


\subsection{Signed (co)boundary operator with non-contractible 2-cells}

In this section we construct the matrix of the \emph{signed} (i.e.~oriented) boundary operator---with elements in $\{-1,0,1\}$---in order to traverse efficiently the partial boundary of the (coherently oriented) 3-cells to be reconstructed from a 2-skeleton embedded in 3D.

We start computing the 2-boundary / 2-coboundary using a triangulation of general LAR faces.  The original LAR edges are uncoupled from those added by the triangulation algorithm. 
For the  generation of the boundary triangulation matrix we do not not use any geometric embedding (i.e.~sign of determinants induced by vertex positions) but the standard sign rules of abstract simplicial complexes.

In particular, the 2-boundary matrix in the more general LAR cell setting is a contraction of a block-decomposition of the 2-boundary matrix built for the triangulated space.  We cannot test for the 3-case because I do not have (for now :-) a tetrahedral CDT to apply to LAR 3-cells, but the method should extend naturally to higher dimensions.

\paragraph{Extend LAR edges with a given (2D) triangulation}

The function \texttt{extendEV} below extends the LAR edges, contained within the \texttt{EV} array, with the new arcs introduced by a given (2D) triangulation. The \texttt{TV} array contains, for each triangle, the list of its three vertex indices. The \texttt{ET} array, gives, for each triangle in the original edge array, the indices of incident triangles, already computed by the triangulation algorithm, invoked (please see the \texttt{test/py/boolean/test16.py} example) by the \texttt{faceSlopeOrdering} function.
The function return the new array of edges, as lists of vertex indices. The first $n$ pairs are the original edges; the following ones are those added bu the triangulation. The dictionary \texttt{EVdict} is used to construct the returned output.

%-------------------------------------------------------------------------------
@D Extend LAR edges with a given (2D) triangulation
@{""" Extend LAR edges with a given (2D) triangulation """
from collections import OrderedDict

def extendEV(EV,ET,TV):
    EVdict = OrderedDict([(edge,k) for k,edge in enumerate(EV)])
    n = len(EV)-1
    for e,(u,w) in enumerate(EV):
        for t in ET[e]:
            v1,v2,v3 = TV[t]
            v = list({v1,v2,v3}.difference([u,w]))[0]
            if u<v: newEdge = (u,v)
            
            else: newEdge = (v,u)
            if not newEdge in EVdict: 
                n += 1
                EVdict[newEdge]=n
                
            if w<v: newEdge = (w,v)
            else: newEdge = (v,w)
            if not newEdge in EVdict: 
                n += 1
                EVdict[newEdge]=n
    return EVdict.keys()
@}
%-------------------------------------------------------------------------------


\paragraph{Signed boundary operator for a general LAR 2-complex}

The function \texttt{larSignedBoundary} is our current implementation for the construction of the $p\times q$ matrix of the signed (i.e.~oriented) boundary operator of the general LAR 2-complex in \texttt{larModel}, starting from the $n\times m$ signed matrix of the LAR triangulation in \texttt{triaModel}. The \texttt{FT} array provides, for each original LAR face, the list of triangle indices (to be used, for example, in \texttt{TV}) of its triangulation.

The \texttt{output} matrix is actually computed by  first constructing the \emph{unsigned} \texttt{boundary} operator, and then by updating its values by those provided by the contraction of the \texttt{input} columns corresponding to the subset of triangles associated to each original face.

No actual sum is necessary for the contraction of a set of \texttt{input} column to a single \texttt{output} column, because the nonzero elements corresponding to original edges are always located on different \texttt{input} rows.  Conversely, the \texttt{input} rows corresponding to the edges added by the triangulation, located in the lower block of the \texttt{input} matrix, contain both one -1 term and one +1 term, that mutually cancel, so that their whole block can be implicitly removed from the \texttt{output} matrix.

%-------------------------------------------------------------------------------
@D Signed boundary operator for a general LAR 2-complex
@{""" Signed boundary operator for a general LAR 2-complex """
def larSignedBoundary(larModel,triaModel,FT):
    inputOp = signedSimplicialBoundary(*triaModel)
    outputOp = larBoundary(*larModel)
    (n,m),(p,q) = inputOp.shape, outputOp.shape
    
    for h in range(p):   # for each LAR face
        for k,triangles in enumerate(FT):
            val = [inputOp[h,t] for t in triangles if inputOp[h,t]!=0.0]
            if val!=[]: outputOp[h,k] = val[0]
    return outputOp
@}
%-------------------------------------------------------------------------------



\paragraph{Generation of signed boundary operator of a general LAR complex}

A complete example of computation of the signed boundary operator of a general LAR complex is given in the \texttt{test/py/boolean/test16.py}. Notice that the last two faces in \texttt{FV} are not contractible to a point, and contain two boundary cycles (island with a lake). The LAR model is the one generated by the \texttt{test/py/boolean/test15.py} example (see).

%-------------------------------------------------------------------------------
@O test/py/boolean/test16.py
@{""" Generation of signed boundary operator of a general LAR complex """
from larlib import *

V = [[0.25,0.25,-5e-05],[0.25,0.75,-5e-05],[0.75,0.75,-5e-05],[0.75,0.25,-5e-05],[
1.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,0.0],[0.0,1.0,0.0],[0.25,0.25,1.0],[0.25,0.25,
2.0],[0.25,0.75,2.0],[0.25,0.75,1.0],[0.25,0.75,-1.0],[0.25,0.25,-1.0],[0.75,0.75,
-1.0],[0.75,0.25,-1.0],[0.75,0.25,1.0],[0.75,0.75,1.0],[1.0,0.0,1.0],[0.0,0.0,
1.0],[1.0,1.0,1.0],[0.0,1.0,1.0],[0.75,0.75,2.0],[0.75,0.25,2.0]]

FV = [(2,3,16,17),(6,7,20,21),(12,13,14,15),(0,1,8,11),(1,2,11,17),(0,1,12,13),
(4,6,18,20),(5,7,19,21),(0,3,13,15),(0,3,8,16),(0,1,2,3),(10,11,17,22),(2,3,14,
15),(8,9,16,23),(8,11,16,17),(1,2,12,14),(16,17,22,23),(4,5,18,19),(8,9,10,11),(
9,10,22,23),(0,1,2,3,4,5,6,7),(8, 11,16,17,18,19,20,21)]

EV =[(3,15),(7,21),(10,11),(4,18),(12,13),(5,19),(8,9),(18,19),(22,23),(0,3),(1,11),
(16,17),(0,8),(6,7),(20,21),(3,16),(10,22),(18,20),(19,21),(1,2),(12,14),(4,5),(
8,11),(13,15),(16,23),(14,15),(11,17),(17,22),(2,14),(2,17),(0,1),(9,10),(8,16),
(4,6),(1,12),(5,7),(0,13),( 9,23),(6,20),(2,3)]

VV = AA(LIST)(range(len(V)))
submodel = SKEL_1(STRUCT(MKPOLS((V,EV))))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV],submodel,0.6))

FE = crossRelation(FV,EV,VV)
EF_angle, ET,TV,FT = faceSlopeOrdering((V,FV,EV),FE)
EW = extendEV(EV,ET,TV)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,TV))))
            
submodel = SKEL_1(STRUCT(MKPOLS((V,EW))))
VIEW(larModelNumbering(1,1,1)(V,[VV,EW,TV],submodel,0.6))

triaModel, larModel = (TV,EW), (FV,EV)
op = larSignedBoundary(larModel,triaModel,FT)
@}
%-------------------------------------------------------------------------------

\paragraph{The output matrix}
The output matrix of the signed boundary operator follows.

%-------------------------------------------------------------------------------
@D Matrix of the signed boundary operator for a general LAR 2-complex
@{""" (see test/py/boolean/test16) """
[[ 0  0  0  0  0  0  0  0  1  0  0  0  1  0  0  0  0  0  0  0  0  0]
 [ 0  1  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0]
 [ 0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0]
 [ 0  0  1  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  1  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  1  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  1]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  1  0  0]
 [ 0  0  0  0  0  0  0  0  1  1 -1  0  0  0  0  0  0  0  0  0  1  0]
 [ 0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 1  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  1  0  0  0  0  1]
 [ 0  0  0 -1  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0]
 [ 0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1]
 [ 1  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  1  0  0]
 [ 0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1]
 [ 0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  1]
 [ 0  0  0  0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0 -1  0]
 [ 0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  1  0]
 [ 0  0  0 -1  0  0  0  0  0  0  0  0  0  0  1  0  0  0 -1  0  0 -1]
 [ 0  0  1  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0 -1  0  0  0  0  0]
 [ 0  0 -1  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0 -1  0  0  0  0  0  0  1  0  0  1  0  0  0  0  0  0 -1]
 [ 0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0]
 [-1  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  1  0  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0 -1  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  0]
 [ 0  0  0  0  0  0  0  0  0 -1  0  0  0 -1 -1  0  0  0  0  0  0  1]
 [ 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0]
 [ 0  0  0  0  0  1  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  1  0]
 [ 0  0  0  0  0 -1  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0 -1  0  0]
 [ 0 -1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 1  0  0  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  0  0 -1  0]]
 @}
%-------------------------------------------------------------------------------


\subsection{Boolean chains}
%===============================================================================

%===============================================================================
\section{Esporting the Library}
%===============================================================================

%-------------------------------------------------------------------------------
@O larlib/larlib/boolean.py
@{""" Module for Boolean computations between geometric objects """
from larlib import *
import inters,triangulation
from copy import copy
DEBUG = False

@< Coding utilities @>
@< Remove subsets from bucket list @>
@< Iterate the splitting until splittingStack is empty @>
@< Computation of affine face transformations @>
@< Submanifold mapping computation @>
@< Helper functions for spacePartition @>
@< Sorting of points along a line @>
@< Remove intersection points external to a submanifold face @>
@< Compute face intersections with z=0 @>
@< Brute-force intersection of 2D lines @>
@< Space partitioning via submanifold mapping @>
@< 3D boundary triangulation of the space partition @>
@< Computation of incidence between edges and 3D triangles @>
@< Slope of edges @>
@< Edge-triangles to Edge-faces incidence @>
@< 3-cell traversal @>
@< Cells from $(d-1)$-dimensional LAR model @>
@< Cycles orientation @>
@< Start a new 3-cell @>
@< Face orientations storage @>
@< Extend LAR edges with a given (2D) triangulation @>
@< Signed boundary operator for a general LAR 2-complex @>
@< Get single solid cell @>
@< Main procedure of arrangement partitioning @>
@< First steps of the Merge algorithm @>
@< Next steps of the Merge algorithm @>
@< Final steps of the Merge algorithm @>
@}
%-------------------------------------------------------------------------------
    
%===============================================================================
\section{Test examples}
%===============================================================================

\subsection{Random triangles}
%===============================================================================


\paragraph{Generation of random triangles and their boxes}
%-------------------------------------------------------------------------------
@O test/py/boolean/test01.py
@{""" Generation of random triangles and their boxes """
from larlib import *
glass = MATERIAL([1,0,0,0.1,  0,1,0,0.1,  0,0,1,0.1, 0,0,0,0.1, 100])

randomTriaArray = randomTriangles(10,0.99)
VIEW(STRUCT(AA(MKPOL)([[verts, [[1,2,3]], None] for verts in randomTriaArray])))

boxes = containmentBoxes(randomTriaArray)
hexas = AA(box2exa)(boxes)
cyan = COLOR(CYAN)(STRUCT(AA(MKPOL)([[verts, [[1,2,3]], None] for verts in randomTriaArray])))
yellow = STRUCT(AA(glass)(AA(MKPOL)([hex for hex,qualifier in hexas])))
VIEW(STRUCT([cyan,yellow]))
@}
%-------------------------------------------------------------------------------


\paragraph{Generation of random quadrilaterals and their boxes}
%-------------------------------------------------------------------------------
@O test/py/boolean/test02.py
@{""" Generation of random quadrilaterals and their boxes """
from larlib import *
glass = MATERIAL([1,0,0,0.1,  0,1,0,0.1,  0,0,1,0.1, 0,0,0,0.1, 100])

randomQuadArray = randomQuads(10,1)
VIEW(STRUCT(AA(MKPOL)([[verts, [[1,2,3,4]], None] for verts in randomQuadArray])))

boxes = containmentBoxes(randomQuadArray)
hexas = AA(box2exa)(boxes)
cyan = COLOR(CYAN)(STRUCT(AA(MKPOL)([[verts, [[1,2,3,4]], None] for verts in randomQuadArray])))
yellow = STRUCT(AA(glass)(AA(MKPOL)([hex for hex,qualifier in hexas])))
VIEW(STRUCT([cyan,yellow]))
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.2\linewidth,width=0.2425\linewidth]{images/fork1} 
   \includegraphics[height=0.2\linewidth,width=0.2425\linewidth]{images/fork2} 
   \includegraphics[height=0.2\linewidth,width=0.2425\linewidth]{images/fork3} 
   \includegraphics[height=0.2\linewidth,width=0.2425\linewidth]{images/fork4} 
   \caption{\texttt{LAR} complex from two polygons. (a) the input polygons; (b) the intersection of boundary lines; (c) the extracted \emph{regularized} 2-complex; (d) the boundary \texttt{LAR}.}
   \label{fig:ortho}
\end{figure}

%-------------------------------------------------------------------------------
@O test/py/boolean/test03.py
@{""" Boolean complex generated by boundaries of two complexes """
from larlib import *
glass = MATERIAL([1,0,0,0.1,  0,1,0,0.1,  0,0,1,0.1, 0,0,0,0.1, 100])

V1 = [[3,0],[11,0],[13,10],[10,11],[8,11],[6,11],[4,11],[1,10],[4,3],[6,4],
        [8,4],[10,3]]
FV1 = [[0,1,8,9,10,11],[1,2,11],[3,10,11],[4,5,9,10],[6,8,9],[0,7,8]]
EV1 = [[0,1],[0,7],[0,8],[1,2],[1,11],[2,11],[3,10],[3,11],[4,5],[4,10],[5,
        9],[6,8],[6,9],[7,8],[8,9],[9,10],[10,11]]
BE1 = boundaryCells(FV1,EV1)
lines1 = [[V1[v] for v in EV1[edge]] for edge in BE1]

V2 = [[0,3],[14,2],[14,5],[14,7],[14,11],[0,8],[3,7],[3,5]]
FV2 = [[0,5,6,7],[0,1,7],[4,5,6],[2,3,6,7]]
EV2 = [[0,1],[0,5],[0,7],[1,7],[2,3],[2,7],[3,6],[4,5],[4,6],[5,6],[6,7]]
BE2 = boundaryCells(FV2,EV2)
lines2 = [[V2[v] for v in EV2[edge]] for edge in BE2]

VIEW(STRUCT([ glass(STRUCT(MKPOLS((V1,FV1)))), glass(STRUCT(MKPOLS((V2,FV2)))) ]))
lines = lines1 + lines2
VIEW(STRUCT(AA(POLYLINE)(lines)))

#global precision
#PRECISION -= 2
V,FV,EV,polygons = larFromLines(lines)
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,EV))))

VV = AA(LIST)(range(len(V)))
submodel = STRUCT(MKPOLS((V,EV)))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV[:-1]],submodel,1))

polylines = [[V[v] for v in face+[face[0]]] for face in FV[:-1]]
colors = [CYAN, MAGENTA, WHITE, RED, YELLOW, GREEN, GRAY, ORANGE, BLACK, BLUE, PURPLE, BROWN]
sets = [COLOR(colors[k%12])(FAN(pol)) for k,pol in enumerate(polylines)]
VIEW(STRUCT([ T(3)(0.02)(STRUCT(AA(POLYLINE)(lines))), STRUCT(sets)]))

VIEW(EXPLODE(1.2,1.2,1)((AA(POLYLINE)(polylines))))
polylines = [ [V[v] for v in FV[-1]+[FV[-1][0]]] ]
VIEW(EXPLODE(1.2,1.2,1)((AA(POLYLINE)(polylines))))
@}
%-------------------------------------------------------------------------------



\subsection{Testing the box-kd-trees}
%===============================================================================


\paragraph{Visualizing with different colors the buckets of box-kd-tree}
%-------------------------------------------------------------------------------
@O test/py/boolean/test04.py @{
""" Visualizing with different colors the buckets of box-kd-tree """
from larlib import *

randomQuadArray = randomQuads(30,0.8)
VIEW(STRUCT(AA(MKPOL)([[verts, [[1,2,3,4]], None] for verts in randomQuadArray])))

V,[VV,EV,FV,CV] = larCuboids([2,2,1],True)
cubeGrid = Struct([(V,FV,EV)],"cubeGrid")
cubeGrids = Struct(2*[cubeGrid,s(.5,.5,.5)])
V,FV,EV = struct2lar(cubeGrids)
boxes = containmentBoxes([[V[v] for v in f] for f in FV])
VV = AA(LIST)(range(len(V)))
submodel = STRUCT(MKPOLS((V,EV)))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV],submodel,0.6)) 
parts = boxBuckets3d(boxes)
V,FV,EV = spacePartition(V,FV,EV, parts)
VV = AA(LIST)(range(len(V)))
submodel = STRUCT(MKPOLS((V,EV)))
VIEW(larModelNumbering(1,1,1)(V,[VV,EV,FV],submodel,0.6)) 


#boxes = containmentBoxes(randomQuadArray)
hexas = AA(box2exa)(boxes)
glass = MATERIAL([1,0,0,0.1,  0,1,0,0.1,  0,0,1,0.1, 0,0,0,0.1, 100])
yellow = STRUCT(AA(glass)(AA(MKPOL)([hex for hex,data in hexas])))
VIEW(STRUCT([#cyan,
    yellow]))

parts = boxBuckets3d(boxes)
for k,part in enumerate(parts):
    bunch = [glass(STRUCT( [MKPOL(hexas[h][0]) for h in part]))]
    bunch += [COLOR(RED)(MKPOL(hexas[k][0]))]
    if k==30: VIEW(STRUCT(bunch))
@}
%-------------------------------------------------------------------------------


\subsection{Intersection of geometry subsets}
%===============================================================================



\paragraph{Two unit cubes}
%-------------------------------------------------------------------------------
@D Two unit cubes 
@{""" Two unit cubes """
from larlib import *
V,[VV,EV,FV,CV] = larCuboids([2,2,2],True)
cube1 = Struct([(V,FV,EV)],"cube1")
twoCubes = Struct([cube1,t(.5,.5,.5),cube1])

glass = MATERIAL([1,0,0,0.1,  0,1,0,0.1,  0,0,1,0.1, 0,0,0,0.1, 100])

#twoCubes = Struct([cube1,t(-1,.5,1),cube1])     # other test example
#twoCubes = Struct([cube1,t(.5,.5,0),cube1])    # other test example
#twoCubes = Struct([cube1,t(.5,0,0),cube1])        # other test example

V,FV,EV = struct2lar(twoCubes)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,FV))))

quadArray = [[V[v] for v in face] for face in FV]
boxes = containmentBoxes(quadArray)
hexas = AA(box2exa)(boxes)
parts = boxBuckets3d(boxes)
@}
%-------------------------------------------------------------------------------


def POLYGONS((V,FV)):



\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.245\linewidth,width=0.243\linewidth]{images/twocubes1} 
   \includegraphics[height=0.245\linewidth,width=0.243\linewidth]{images/twocubes2} 
   \includegraphics[height=0.245\linewidth,width=0.243\linewidth]{images/twocubes3} 
   \includegraphics[height=0.245\linewidth,width=0.243\linewidth]{images/twocubes4} 
   \caption{\texttt{LAR} complex of the space decomposition generated by two cubes in special positions. (a) translation on one coordinate; (b) translation on two coordinates;  (c) translation on three coordinates; (d) non-manifold position along an edge.}
   \label{fig:twocubes}
\end{figure}


\paragraph{Face (and incident faces) transformation}
%-------------------------------------------------------------------------------
@O test/py/boolean/test05.py
@{""" non-valid -> valid solid representation of a space partition """
from larlib import *

@< Two unit cubes @>
    
W,FW,EW = spacePartition(V,FV,EV, parts)
polylines = lar2polylines((W,FW))
VIEW(EXPLODE(1.2,1.2,1.2)(AA(POLYLINE)(polylines)))

WW = AA(LIST)(range(len(W)))
submodel = STRUCT(MKPOLS((W,EW)))
VIEW(larModelNumbering(1,1,1)(W,[WW,EW,FW],submodel,0.5))
@}
%-------------------------------------------------------------------------------







\paragraph{3-cell reconstruction from LAR space partition}
%-------------------------------------------------------------------------------
@O test/py/boolean/test06.py
@{""" 3-cell reconstruction from LAR space partition """
from larlib import *
@< Two unit cubes @>
W,FW,EW = spacePartition(V,FV,EV, parts)
WW = AA(LIST)(range(len(W)))
submodel = STRUCT(MKPOLS((W,EW)))
VIEW(larModelNumbering(1,1,1)(W,[WW,EW,FW],submodel,0.6))
@}
%-------------------------------------------------------------------------------



\paragraph{2D polygon triangulation}
Here a 2D polygon is imported from an SVG file made of boundary lines, and the \texttt{V,FV,EV}
LAR model is generated. 

%-------------------------------------------------------------------------------
@O test/py/boolean/test07.py
@{""" 2D polygon triangulation """
from larlib import *
#from support import PolygonTessellator,vertex

filename = "test/svg/boolean/interior.svg"
lines = svg2lines(filename)    
V,FV,EV,polygons = larFromLines(lines)
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV[:-1]+EV)) + AA(MK)(V)))

VIEW(EXPLODE(1.2,1.2,1)(MKTRIANGLES((V,FV,EV)) ))
@}
%-------------------------------------------------------------------------------


\paragraph{From triples of points to LAR model of boundary triangulation}
    
%-------------------------------------------------------------------------------
@O test/py/boolean/test08.py @{
import sys
from larlib import *

sys.path.insert(0, 'test/py/boolean/')
from test06 import *

""" From triples of points to LAR model """
WW = AA(LIST)(range(len(W)))
FE = crossRelation(FW,EW,WW)
triangleSet = boundaryTriangulation(W,FW,EW,FE)
TW,FT = triangleIndices(triangleSet,W)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((W,TW))))
@}
%-------------------------------------------------------------------------------



\paragraph{Visualization of of incidence between edges and 3D triangles}

%-------------------------------------------------------------------------------
@O test/py/boolean/test09.py @{
""" Visualization of of incidence between edges and 3D triangles """
import sys
from larlib import *

sys.path.insert(0, 'test/py/boolean/')
from test08 import *

model = W,FW,EW
WW = AA(LIST)(range(len(W)))
FE = crossRelation(FW,EW,WW)
EF = invertRelation(FE)

triangleSet = boundaryTriangulation(W,FW,EW,FE)
TW,FT = triangleIndices(triangleSet,W)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((W,TW))))

ET = edgesTriangles(EF,FW,TW,EW)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((W,ET))))
VIEW(STRUCT(MKPOLS((W,ET[35]))))

from larlib.iot3d import polyline2lar
V,FV,EV = polyline2lar([[W[v] for v in FW[f]] for f in EF[35]] )
VIEW(STRUCT(MKPOLS((V,EV))))
@}
%-------------------------------------------------------------------------------



\paragraph{Visualization of indices of the boundary triangulation}

%-------------------------------------------------------------------------------
@O test/py/boolean/test10.py @{
""" Visualization of indices of the boundary triangulation """
from larlib import *

sys.path.insert(0, 'test/py/boolean/')
from test09 import *

model = W,FW,EW
WW = AA(LIST)(range(len(W)))
FE = crossRelation(FW,EW)
EF_angle, ET,TV = faceSlopeOrdering(model,FE)

submodel = SKEL_1(STRUCT(MKPOLS((W,CAT(TW)))))
VIEW(larModelNumbering(1,1,1)(W,[WW,EW,CAT(TW)],submodel,0.6))
@}
%-------------------------------------------------------------------------------


\paragraph{Visualization after sorted edge-faces incidence computation}

%-------------------------------------------------------------------------------
@O test/py/boolean/test11a.py @{
from larlib import *
@< testing example @(t(.5,.5,.5),r(0,0,PI/6)@) @>  
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11b.py @{
from larlib import *
@< testing example @(t(.5,.5,0),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11c.py @{
from larlib import *
@< testing example @(t(.5,0,0),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11d.py @{
from larlib import *
@< testing example @(t(0,0,0),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11e.py @{
from larlib import *
@< testing example @(s(.5,.5,.5),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11f.py @{
from larlib import *
@< testing example @(t(.25,.25,.25),s(.5,.5,.5),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11g.py @{
from larlib import *
@< testing example @(t(.25,.25,.75),s(.5,.5,.5),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@O test/py/boolean/test11h.py @{
from larlib import *
@< testing example @(t(1.5,1.5,0),r(0,0,PI/6)@) @>
@}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
@D testing example @{
""" Visualization of indices of the boundary triangulation """

V,[VV,EV,FV,CV] = larCuboids([1,1,1],True)
cubeGrid = Struct([(V,FV,EV)],"cubeGrid")
cubeGrids = Struct(2*[cubeGrid,@1])

V,FV,EV = struct2lar(cubeGrids)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,FV))))
V,CV,FV,EV,CF,CE,COE,FE = thePartition(V,FV,EV)

cellLengths = AA(len)(CF)
boundaryPosition = cellLengths.index(max(cellLengths))
BF = CF[boundaryPosition]; del CF[boundaryPosition]; del CE[boundaryPosition]
BE = list({e for f in BF for e in FE[f]})

#Volume((V,[FV[f] for f in CF[0]]))

VIEW(EXPLODE(1.2,1.2,1.2)( MKTRIANGLES((V,[FV[f] for f in BF],[EV[e] for e in BE])) ))
VIEW(EXPLODE(1.2,1.2,1.2)([ MKSOLID(V,[FV[f] for f in cell],[EV[e] for e in set(CAT([FE[f] for f in cell]))]) for cell in CF]))
VIEW(EXPLODE(1.2,1.2,1.2)([STRUCT(MKPOLS((V,[EV[e] for e in cell]))) for cell in CE]))
@}
%-------------------------------------------------------------------------------



\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11a1} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11a2} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11a3} 

   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11b1} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11b2} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11b3} 

   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11c1} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11c2} 
   \includegraphics[height=0.332\textwidth,width=0.32\textwidth]{images/test11c3} 
   \caption{Examples of 3-cell extraction of two simple Boolean 2-complex, and their boundaries. Notice the numbers of (solid) 3-cells.}
   \label{fig:example}
\end{figure}


\subsection{Polygon triangulation}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%-------------------------------------------------------------------------------
@O test/py/boolean/test13.py
@{""" Polygon triangulation and importing to LAR """

from larlib import *
from p2t import *

@< load points @>
@< input polyline visualization @>
@< CDT triangulation with poly2tri @>
@< conversion of triangulation to LAR @>
@< visualization of LAR model of triangulation @>
@< reconstruction of boundary polyline for LAR model @>
@< visualization of LAR generated boundary polyline @>
@}
%-------------------------------------------------------------------------------



\paragraph{load points}
%-------------------------------------------------------------------------------
@D load points
@{""" load points """
def load_points(file_name):
    infile = open(file_name, "r")
    points = []
    while infile:
        line = infile.readline()
        s = line.split()
        if len(s) == 0:
            break
        points.append([float(s[0]), float(s[1])])
    return points
@}
%-------------------------------------------------------------------------------


\paragraph{input polyline visualization}
%-------------------------------------------------------------------------------
@D input polyline visualization
@{""" input polyline visualization """
points = load_points("test/data/nazca_monkey.dat")
VIEW(POLYLINE(points))
@}
%-------------------------------------------------------------------------------

\paragraph{CDT triangulation with poly2tri}
%-------------------------------------------------------------------------------
@D CDT triangulation with poly2tri
@{""" CDT triangulation with poly2tri """
polyline = [Point(p[0],p[1]) for p in points]  
cdt = CDT(polyline)
triangles = cdt.triangulate()
@}
%-------------------------------------------------------------------------------
  
\paragraph{conversion of triangulation to LAR}
%-------------------------------------------------------------------------------
@D conversion of triangulation to LAR
@{""" conversion of triangulation to LAR """
trias = [ [[t.a.x,t.a.y],[t.b.x,t.b.y],[t.c.x,t.c.y]] for t in triangles ]
vdict = defaultdict(list)
for k,point in enumerate(CAT(trias)): 
    vdict[vcode(4)(point)] += [k]
vdict = OrderedDict(zip(vdict.keys(),range(len(vdict.keys()))))
FV = [(vdict[vcode(4)(a)], vdict[vcode(4)(b)], vdict[vcode(4)(c)]) for [a,b,c] in trias] 
repeatedEdges = CAT([[[v1,v2],[v2,v3],[v3,v1]] for [v1,v2,v3] in FV])
EV = list(set(AA(tuple)(AA(sorted)(repeatedEdges))))
V = [eval(vect) for vect in vdict]
@}
%-------------------------------------------------------------------------------

\paragraph{visualization of LAR model of triangulation}
%-------------------------------------------------------------------------------
@D visualization of LAR model of triangulation
@{""" visualization of LAR model of triangulation """
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,FV))))
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,EV))))
@}
%-------------------------------------------------------------------------------

\paragraph{reconstruction of boundary polyline for LAR model}
%-------------------------------------------------------------------------------
@D reconstruction of boundary polyline for LAR model
@{""" reconstruction of boundary polyline for LAR model """
EW = boundaryCells(FV,EV)
VIEW(EXPLODE(1.2,1.2,1)(MKPOLS((V,[EV[e] for e in EW]))))
model = (V,FV,[EV[e] for e in EW])
struct = Struct([model])
@}
%-------------------------------------------------------------------------------

\paragraph{visualization of LAR generated boundary polyline}
%-------------------------------------------------------------------------------
@D visualization of LAR generated boundary polyline
@{""" visualization of LAR generated boundary polyline """
poly = boundaryModel2polylines(structBoundaryModel(struct))
VIEW(POLYLINE(poly[0][:-1]))
@}
%-------------------------------------------------------------------------------

\paragraph{Arrangements with non-contractible cells}

%-------------------------------------------------------------------------------
@O test/py/boolean/test15.py 
@{""" Arrangements with non-contractible cells """
from larlib import *

V,[VV,EV,FV,CV] = larCuboids([1,1,1],True)
cube1 = Struct([(V,FV,EV)],"cube1")
cube2 = Struct([t(.25,.25,-1),s(.5,.5,3),(V,FV,EV)],"cube2")
V,FV,EV = struct2lar(Struct([cube1,cube2]))
VIEW(STRUCT(MKPOLS((V,FV,EV))))
"""
V,CV,FV,EV,CF,CE,COE,FE = thePartition(V,FV,EV)
"""
@}
%-------------------------------------------------------------------------------


\appendix
%===============================================================================
\section{Code utilities}
%===============================================================================

\subsection{Generation of random data}

Some utility fuctions used by the module are collected in this appendix. Their macro names can be seen in the below script.

%-------------------------------------------------------------------------------
@D Coding utilities
@{""" Coding utilities """
global count
@< Generation of a random 3D point @>
@< Generation of random 3D triangles @>
@< Generation of random 3D quadrilaterals @>
@< Generation of a single random triangle @>
@< Containment boxes @>
@< Transformation of a 3D box into an hexahedron @>
@< Generation of a list of HPCs from a LAR model with non-convex faces @>
@< Utility to transform a dictionary to a function on the keys @>
@< Coherent orientation of boundary 2-faces @>
@< Generation of LAR B-rep from a LAR model with non-convex faces @>
@}
%-------------------------------------------------------------------------------


\paragraph{Generation of a list of HPCs from a LAR model with non-convex faces}

%-------------------------------------------------------------------------------
@D Generation of a list of HPCs from a LAR model with non-convex faces
@{""" Generation of a list of HPCs from a LAR model with non-convex faces """
import boundary

def MKTRIANGLES(model,color=False):
    V,FV,EV = model
    lenV = len(V)
    VV = AA(LIST)(range(len(V)))
    
    boundaryOperator = boundary.larSignedBoundary2(V,FV,EV)
    FEbasis = boundary.signedBasis(boundaryOperator)
    FE,signs = TRANS(FEbasis)
    
    if len(V[0]) == 2: V=[v+[0] for v in V]
    triangleSets = boundaryTriangulation(V,FV,EV,FE)
    triangleSet = [[(p1,p2,p3) if sign==1 else (p2,p1,p3) for p1,p2,p3 in triangleSet] 
                    for sign,triangleSet in zip(signs,triangleSets)]
    if color:
        colors = [CYAN,MAGENTA,WHITE,RED,YELLOW,GREEN,GRAY,ORANGE,BLACK,BLUE,PURPLE,BROWN]
        return [ COLOR(colors[k%12])(STRUCT([MKPOL([verts,[[1,2,3]],None]) 
            for verts in triangledFace])) for k,triangledFace in enumerate(triangleSets) ]
    else:
        return [ STRUCT([MKPOL([verts,[[1,2,3]],None]) for verts in triangledFace])
                for triangledFace in triangleSets ]
"""
def MKSOLID(*model): 
    V,FV,EV = model
    VV = AA(LIST)(range(len(V)))
    FE = larcc.crossRelation(FV,EV,VV)
    pivot = V[0]
    #VF = invertRelation(FV) 
    #faces = [face for face in FV if face not in VF[0]]
    faces = [face for face in FV]
    triangleSets = boundaryTriangulation(V,faces,EV,FE)
    return XOR([ MKPOL([face+[pivot], [range(1,len(face)+2)],None])
        for face in CAT(triangleSets) ])
"""
@}
%-------------------------------------------------------------------------------


\subsection{Generation of LAR B-rep from a general 2-skeleton in 3D}

In this section we introduce the drawing utility \texttt{BREP} to compute and display the coherently oriented boundary 2-faces of the 3-complex generated by a 2.5D LAR model, i.e. the solid complex generated via $\partial_3$ computation, starting from its 2-skeleton embedded in 3D.

\paragraph{Coherent orientation of boundary 2-faces}

To recover a correct coherent orientation of the boundary 2-faces, of a general LAR 3-complex, are not sufficient the standard informations about the intrinsic orientations of 2-cells (provided by the \texttt{FEbasis}) and the relative orientation of boundary 2-faces (provided by \texttt{signedBoundary}). It is also necessary to take into account the way each boundary 2-face is stored within the \texttt{triangleSets} variable, since this task is performed independently by an external \emph{opensource} package. This fact forced us to disassemble the triangulation, made by triplex ov vertex coordinates, and to recover how it differs from the original LAR model before the triangulation. For this purpose two dictionaries \texttt{vdict} of vertices and \texttt{edict} of edges are first reconstructed. Then the lists of triples of vertex and edge triples are recovered into \texttt{triaVerts} and \texttt{triaEdges}, respectively. Finally, every pair \texttt{(f,sign)} is coupled and compared with it symbolic triangulation, to discover if their orientations are either coherent or not. For this purpose is sufficient to compare the orientations of a single edge in both such structures. The output list \texttt{theSigns} stores the related information.

%-------------------------------------------------------------------------------
@D Coherent orientation of boundary 2-faces
@{""" Coherent orientation of boundary 2-faces """
def boundaryOrientation(V,EV,FEbasis,signedBoundary,triangleSets):            
    vdict = OrderedDict([ (vcode(3)(v),k) for k,v in enumerate(V)  ])
    edict = OrderedDict([ (edge,k) for k,edge in enumerate(EV) ])
    triaVerts = [[AA(dict2fun(vdict))(AA(vcode(3))(t)) for t in triangleSet] 
                 for triangleSet in triangleSets]
    triaEdges = []
    for triangles in triaVerts:
        tria2edgs = []
        for v0,v1,v2 in triangles:
            tris = []
            if (v0,v1) in edict: tris += [edict[(v0,v1)]]
            if (v1,v2) in edict: tris += [edict[(v1,v2)]]
            if (v2,v0) in edict: tris += [edict[(v2,v0)]]
            tria2edgs += [tris]
        triaEdges += [CAT(tria2edgs)[0] if CAT(tria2edgs)[0]!=0 else CAT(tria2edgs)[1]]
    
    orientations = zip(triaEdges,[[sign,FEbasis[f]] for f,sign in signedBoundary])
    
    tests = [set([triaEdges]).intersection((sign*array(signs)*array(edgechain)).tolist()) 
        for triaEdges,(sign,(edgechain,signs)) in orientations]
        
    theSigns = [1 if val!= set([]) else -1 for val in tests]
    return triangleSets,theSigns
@}
%-------------------------------------------------------------------------------

\paragraph{Generation of LAR B-rep from a LAR model with non-convex faces}

The \texttt{BREP} function, given below, is used to generate and display a  LAR B-rep from a LAR model with general (non-convex) faces. The input is a LAR model \texttt{V,FV,EV} of the 2-skeleton of a 3-complex. First the intrinsic orientation of 2-faces as closed 1-chains of edges is computed,  storing the computed data, i.e.~a list of pairs (edge-index, sign) in the \texttt{FEbasis} variable. Then the $\partial_3$ matrix is computed and returned in csr form into \texttt{csrBoundary3}, together with le lists of faces by 3-cell \texttt{CF}, and the coherently oriented boundary cycle within the signed 2-chain \texttt{signedBoundary}. Finally, the coherently orientated boundary triangulation is returned by the \texttt{boundaryOrientation} function.

%-------------------------------------------------------------------------------
@D Generation of LAR B-rep from a LAR model with non-convex faces
@{""" Generation of LAR B-rep from a LAR model with non-convex faces """

def BREP (model,color=False):
    # intrinsic orientation of input 2-faces
    V,FV,EV = model
    VV = AA(LIST)(range(len(V)))
    boundaryOperator = boundary.larSignedBoundary2(V,FV,EV)
    FEbasis = boundary.signedBasis(boundaryOperator)
    FE,facesigns = TRANS(FEbasis)
    
    # computation of boundary 2-faces
    csrBoundary3,CF,_ = boundary.larSignedBoundary3((V,FV,EV))
    
    signedBoundary = csrBoundary3 * (len(CF)*[[1]])  ## TODO !!
    
    cells,_ = TRANS(signedBoundary)
    fv = [FV[f] for f in cells]
    ev = [EV[e] for e in set(CAT([[e for e in FE[f]] for f in cells])) ]
    fe = larcc.crossRelation(fv,ev,VV)
    triangleSets = boundaryTriangulation(V,fv,ev,fe) 
    
    # computation of coherent orientation of boundary 2-faces
    triangleSets,theSigns = boundaryOrientation(V,EV,FEbasis,signedBoundary,triangleSets)

    # visualization of boundary
    if color:
        colors = [CYAN,MAGENTA,WHITE,RED,YELLOW,GREEN,GRAY,ORANGE,BLACK,BLUE,PURPLE,BROWN]
        return [ COLOR(colors[k%12])(
                 STRUCT([MKPOL([verts,[[3,2,1]],None]) for verts in triangledFace])
        		 if sign==-1 else 
        		 STRUCT([MKPOL([verts,[[1,2,3]],None])  for verts in triangledFace])
                 ) 
        for k,(sign,triangledFace) in enumerate(zip(theSigns,triangleSets)) ]
    else:
        return [ STRUCT([MKPOL([verts,[[3,2,1]],None])  for verts in triangledFace])
        		 if sign==-1 else 
        		 STRUCT([MKPOL([verts,[[1,2,3]],None])  for verts in triangledFace])
        for sign,triangledFace in zip(theSigns,triangleSets) ]
@}
%-------------------------------------------------------------------------------

\paragraph{Example}
The generation and visualization of the LAR B-rep (Boundary Representation) from a LAR model \texttt{V,FV,EV} with (possibly) non-convex faces follows.

%-------------------------------------------------------------------------------
@D Generation of LAR B-rep from a LAR model with non-convex faces
@{""" Generation of LAR B-rep from a LAR model with non-convex faces """
if __name__=="__main__":

    V,[VV,EV,FV,CV] = larCuboids([2,2,2],True)
    cubeGrid = Struct([(V,FV,EV)],"cubeGrid")
    cubeGrids = Struct(2*[cubeGrid,t(.5,.5,.5),r(0,0,PI/6)])

    V,FV,EV = struct2Marshal(cubeGrids)
    VIEW(EXPLODE(1.2,1.2,1.2)(BREP((V,FV,EV),color=True) ))
    VIEW(EXPLODE(1.2,1.2,1.2)(BREP((V,FV,EV)) ))
    VIEW(STRUCT(BREP((V,FV,EV)) ))
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/bool3-2} 
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/bool3-3} 
   \includegraphics[height=0.328\linewidth,width=0.328\linewidth]{images/bool3-4} 
   \caption{\texttt{BREP} of a 3-complex, starting from its 2-skeleton: (a) triangulation of \texttt{LAR} faces; (b) \texttt{LAR} boundary faces (even non-convex) in color; (c) coherently oriented 2-boundary.}
   \label{fig:example}
\end{figure}

\paragraph{Utility to transform a dictionary to a function on the keys}
%-------------------------------------------------------------------------------
@D Utility to transform a dictionary to a function on the keys
@{""" Utility to transform a dictionary to a function on the keys """
def dict2fun(d):
    def dict2fun0(k): return d[k]
    return dict2fun0 
@}
%-------------------------------------------------------------------------------

\paragraph{Generation of random triangles}
The function \texttt{randomTriangles} returns the array \texttt{randomTriaArray} with a given number of triangles generated within the unit 3D interval. The \texttt{scaling} parameter is used to scale every such triangle, generated by three randow points, that could be possibly located to far from each other, even at the distance of the diagonal of the unit cube.

The arrays \texttt{xs}, \texttt{ys} and \texttt{zs}, that contain the $x,y,z$ coordinates of triangle points, are used to compute the minimal translation \texttt{v} needed to transport the entire set of data within the positive octant of the 3D space. 

%-------------------------------------------------------------------------------
@D Generation of random 3D triangles
@{""" Generation of random triangles """
def randomTriangles(numberOfTriangles=400,scaling=0.3):
    randomTriaArray = [rtriangle(scaling) for k in range(numberOfTriangles)]
    [xs,ys,zs] = TRANS(CAT(randomTriaArray))
    xmin, ymin, zmin = min(xs), min(ys), min(zs)
    v = array([-xmin,-ymin, -zmin])
    randomTriaArray = [[list(v1+v), list(v2+v), list(v3+v)] for v1,v2,v3 in randomTriaArray]
    return randomTriaArray
@}
%-------------------------------------------------------------------------------

\paragraph{Generation of random 3D quadrilaterals}

%-------------------------------------------------------------------------------
@D Generation of random 3D quadrilaterals
@{""" Generation of random 3D quadrilaterals """
def randomQuads(numberOfQuads=400,scaling=0.3):
    randomTriaArray = [rtriangle(scaling) for k in range(numberOfQuads)]
    [xs,ys,zs] = TRANS(CAT(randomTriaArray))
    xmin, ymin, zmin = min(xs), min(ys), min(zs)
    v = array([-xmin,-ymin, -zmin])
    randomQuadArray = [AA(list)([ v1+v, v2+v, v3+v, v+v2-v1+v3 ]) for v1,v2,v3 in randomTriaArray]
    return randomQuadArray
@}
%-------------------------------------------------------------------------------


\paragraph{Generation of a random 3D point}
A single random point, codified in floating point format, and with a fixed (quite small) number of digits, is returned by the \texttt{rpoint3d()} function, with no input parameters.
%-------------------------------------------------------------------------------
@D Generation of a random 3D point
@{""" Generation of a random 3D point """
def rpoint3d():
    return eval( vcode(4)([ random.random(), random.random(), random.random() ]) )
@}
%-------------------------------------------------------------------------------
    
\paragraph{Generation of a single random triangle}
A single random triangle, scaled about its centroid by the \texttt{scaling} parameter, is returned by the \texttt{rtriangle()} function, as a tuple ot two random points in the unit square.
%-------------------------------------------------------------------------------
@D Generation of a single random triangle
@{""" Generation of a single random triangle """
def rtriangle(scaling):
    v1,v2,v3 = array(rpoint3d()), array(rpoint3d()), array(rpoint3d())
    c = (v1+v2+v3)/3
    pos = rpoint3d()
    v1 = (v1-c)*scaling + pos
    v2 = (v2-c)*scaling + pos
    v3 = (v3-c)*scaling + pos
    return tuple(eval(vcode(4)(v1))), tuple(eval(vcode(4)(v2))), tuple(eval(vcode(4)(v3)))
@}
%-------------------------------------------------------------------------------
    

\paragraph{Containment boxes}

Given as input a list \texttt{randomTriaArray} of pairs of 2D points, the function \texttt{containmentBoxes} returns, in the same order, the list of \emph{containment boxes} of the input lines. A \emph{containment box} of a geometric object of dimension $d$ is defined as the minimal $d$-cuboid, equioriented with the reference frame, that contains the object. For a 2D line it is given by the tuple $(x1,y1,x2,y2)$, where $(x1,y1)$ is the point of minimal coordinates, and $(x2,y2)$ is the point of maximal  coordinates.

%-------------------------------------------------------------------------------
@D Containment boxes
@{""" Containment boxes """
def containmentBoxes(randomPointArray,qualifier=0):
    if len(randomPointArray[0])==2:
        boxes = [eval(vcode(4)([min(x1,x2), min(y1,y2), min(z1,z2), 
                             max(x1,x2), max(y1,y2), max(z1,z2)]))+[qualifier]
                for ((x1,y1,z1),(x2,y2,z2)) in randomPointArray]
    elif len(randomPointArray[0])==3:
        boxes = [eval(vcode(4)([min(x1,x2,x3), min(y1,y2,y3), min(z1,z2,z3), 
                             max(x1,x2,x3), max(y1,y2,y3), max(z1,z2,z3)]))+[qualifier]
                for ((x1,y1,z1),(x2,y2,z2),(x3,y3,z3)) in randomPointArray]
    elif len(randomPointArray[0])==4:
        boxes = [eval(vcode(4)([min(x1,x2,x3,x4), min(y1,y2,y3,y4), min(z1,z2,z3,z4), 
                             max(x1,x2,x3,x4), max(y1,y2,y3,y4), max(z1,z2,z3,z4)]))+[qualifier]
                for ((x1,y1,z1),(x2,y2,z2),(x3,y3,z3),(x4,y4,z4)) in randomPointArray]
    return boxes

def containmentBoxes(randomPointArray,qualifier=0):
    def minmax(pointArray):
        coords = TRANS(pointArray)
        return AA(min)(coords) + AA(max)(coords)
    boxes = [eval(vcode(4)( minmax(pointArray) ))+[qualifier] for pointArray in randomPointArray]
    return boxes
@}
%-------------------------------------------------------------------------------

    
\paragraph{Transformation of a 3D box into an hexahedron}
The transformation of a 2D box into a closed rectangular polyline, given as an ordered sequwncw of 2D points, is produced by the function \texttt{box2exa}
%-------------------------------------------------------------------------------
@D Transformation of a 3D box into an hexahedron
@{""" Transformation of a 3D box into an hexahedron """    
def box2exa(box):
    x1,y1,z1,x2,y2,z2,type = box
    verts = [[x1,y1,z1], [x1,y1,z2], [x1,y2,z1], [x1,y2,z2], [x2,y1,z1], [x2,y1,z2], [x2,y2,z1], [x2,y2,z2]]
    cell = [range(1,len(verts)+1)]
    return [verts,cell,None],type

def lar2boxes(model,qualifier=0):
    V,CV = model
    boxes = []
    for k,cell in enumerate(CV):
        verts = [V[v] for v in cell]
        x1,y1,z1 = [min(coord) for coord in TRANS(verts)]
        x2,y2,z2 = [max(coord) for coord in TRANS(verts)]
        boxes += [eval(vcode(4)([min(x1,x2),min(y1,y2),min(z1,z2),max(x1,x2),max(y1,y2),max(z1,z2)]))+[(qualifier,k)]]
    return boxes
@}
%-------------------------------------------------------------------------------


\section{Boolean (Merge) procedure review}

In this added section we like to store some testing material, added while performing a deep review of the code of this module, in order to rewrite the variadic \emph{Merge} of cellular complexes, according to paper~\cite{2017arXiv170400142P}.

\subsection{First steps of the Merge algorithm}

\paragraph{First steps of the Merge algorithm}
Some functions for the computation of the sparse matrices of both the \emph{unsigned} and the \emph{signed} boundary operator $\partial_2$ are given here.
%-------------------------------------------------------------------------------
@D First steps of the Merge algorithm
@{""" First steps of the Merge algorithm """    
def partition(W,FW,EW):
    quadArray = [[W[v] for v in face] for face in FW]
    parts = boxBuckets3d(containmentBoxes(quadArray))
    Z,FZ,EZ = spacePartition(W,FW,EW, parts)
    Z,FZ,EZ = inters.larSimplify((Z,FZ,EZ),radius=0.001)
    model = Z,FZ,EZ
    return model

def UBoundary2(EV,FV):
	UB2 = (coo2Csr(brc2Coo(EV)) * coo2Csr(brc2Coo(FV)).T).tocoo()
	data,i,j = TRANS([(1,i,j) for (d,i,j) in zip(UB2.data,UB2.row,UB2.col) if d==2])
	return coo_matrix((data,(i,j))).tocsc()

def SBoundary2(EV,FV):
	SB_2 = UBoundary2(EV,FV)
	for f in range(len(FV)):
		ind = defaultdict(list)
		chain_1 = list(SB_2[:,f].tocoo().row)
		chain_0 = zeros((2,len(chain_1)),dtype=int)
		for h,e in enumerate(chain_1):
			v1 = EV[e][0]
			v2 = EV[e][1]
			chain_0[0,h] = v1
			chain_0[1,h] = v2
			ind[v1] += [h]
			ind[v2] += [h]
		# tracking of ordered 0-chains
		k = 0
		while True:
			v1,v2 = chain_0[:,k]
			k = set(ind[v2]).difference([k]).pop()
			if k == 0: break
			if chain_0[0,k] == v2:
				v1,v2 = chain_0[:,k]
			else:
				chain_0[0,k],chain_0[1,k] = chain_0[1,k],chain_0[0,k]
		# TODO: 0-chains with multiple cycles ...
		# sign computation
		sign = []
		for h,e in enumerate(chain_1):
			v1,v2 = chain_0[:,h]
			if v1 < v2:
				sign += [1]
			else:
				sign += [-1]
		# update SB_2
		for h,e in enumerate(chain_1):
			SB_2[e,f] = sign[h]
	return SB_2
@}
%-------------------------------------------------------------------------------

\subsection{Next steps of the Merge algorithm}

\paragraph{Next steps of the Merge algorithm}
Some functions for the computation of the sparse matrix of the \emph{signed} boundary operator $\partial_3$ are given here. Of course its columns provide the (oriented) boundary representation of the 3-cells.
%-------------------------------------------------------------------------------
@D Next steps of the Merge algorithm
@{""" Next steps of the Merge algorithm """  
import boundary
  
def chain2coords(chain,n):
	data,i,j = TRANS([(code,cell,0) for (cell,code) in chain])
	coordVect = coo_matrix((data,(i,j)),(n,1))
	return coordVect
	
def coords2chainDict(coords):
	return dict(boundary.coords2chain(coords))

def next(cyclicPerm):
	def next1(pivot):
		ind = cyclicPerm.index(pivot)
		nextIndex = (ind + 1) % len(cyclicPerm)
		return cyclicPerm[nextIndex]
	return next1

def prev(cyclicPerm):
	def prev1(pivot):
		ind = cyclicPerm.index(pivot)
		nextIndex = (ind - 1) % len(cyclicPerm)
		return cyclicPerm[nextIndex]
	return prev1

def Choose(marks):
	try: return marks.index(1)
	except ValueError: return marks.index(0)

def SBoundary3(W,EW,FW):
	SB_2 = SBoundary2(EW,FW)
	D,I,J = [],[],[]
	m,n = SB_2.shape
	marks = [0 for k in range(n)]
	store = [0 for k in range(n)]
	# permutation subgroups of edges
	FE = [list(SB_2[:,f].tocoo().row) for f in range(SB_2.shape[1])]
	EF_angle, ET,TW,FT = faceSlopeOrdering((W,FW,EW),FE)
	cellCount = -1

	while sum(marks) < 2*n:
		# choose f
		f = Choose(marks)
		
		# start 2-chain extraction from f seed
		if marks[f] == 0: c_2 = [(f,1)] 
		elif marks[f] == 1: c_2 = [(f,-store[f])] 	
		Stripe_2 = coo_matrix(([],([],[])),(n,1))
	
		# computation of c_2 boundary
		C_2 = chain2coords(c_2,n).tocsc() + Stripe_2
		C_1 = SB_2 * C_2

		while C_1.nnz != 0:	
			stripe = dict()
			
			# computation of coboundaries of c_2 boundary
			dict_C_1 = coords2chainDict(C_1)
			for cell,code in dict_C_1.items():
				C1 = chain2coords([(cell,code)],m)
				C2 = C1.T * SB_2
				subgroup = list(C2.tocoo().col)
				pivot = (set(subgroup).intersection(C_2.tocoo().row)).pop()
				if code == 1: 
					adj = next(EF_angle[cell])(pivot)
				elif code == -1:
					adj = prev(EF_angle[cell])(pivot)
				if SB_2[cell,adj] == SB_2[cell,pivot] :
					stripe[adj] = -1 * C_2[pivot,0]
				else:
					stripe[adj] = 1 * C_2[pivot,0]
			Stripe_2 = chain2coords(stripe.items(),n).tocsc()
			C_2 += Stripe_2
			C_1 = SB_2 * C_2
		
		cellCount += 1
		facets = list(C_2.tocoo().row)
		coeffs = list(C_2.tocoo().data)
		cells = [cellCount] * len(coeffs)
		for k,facet in enumerate(facets): 
			marks[facet] += 1
			store[facet] += coeffs[k]
		D += coeffs
		I += facets
		J += cells
	return coo_matrix((D,(I,J)),dtype=int).tocsc()
@}
%-------------------------------------------------------------------------------


\subsection{Final steps of the Merge algorithm}

In this section we include the function \texttt{Boundary3} for the computation of the signed transformation matrix $C_3\to C_2$, whose columns correspond to the signed 2-chain representation of bases 3-cells for the linear space $C_3$. It only differs from the matrix returned from \texttt{SBoundary3} for the lack of one column corresponding to the exterior cell, that can be derived by linear combination of the other columns.

\paragraph{Final steps of the Merge algorithm}
The discovering of the redundant column of \texttt{SBoundary3} is done by a simple but poverful euristics. First we compute the two extreme vertices, i.e. the \texttt{first} and the \texttt{last} of the sorted array of vertex coordinates. Then the two incident sets \texttt{fmins} and \texttt{fmaxs} of incident faces are computed. Finally moves from extreme 2-cells to extreme 3-cells. Their (combinatorial) intersection will provide the index of exterior cell, that will not imported in the output matrix.

%-------------------------------------------------------------------------------
@D Final steps of the Merge algorithm
@{""" Final steps of the Merge algorithm """  
def Boundary3(W,EW,FW):
	SB_3 = SBoundary3(W,EW,FW)
	vertDict = dict([(tuple(v),k) for k,v in enumerate(W)])
	vdict = sorted(vertDict)
	first, last = vertDict[vdict[0]], vertDict[vdict[-1]]
	WF = invertRelation(FW)
	fmins, fmaxs = set(WF[first]), set(WF[last])
	CF = [list(SB_3[:,c].tocoo().row) for c in range(SB_3.shape[1])]
	exterior = [k for k,cell in enumerate(CF) if (fmins.intersection(cell) == fmins) 
		and (fmaxs.intersection(cell) == fmaxs)][0]
	# TODO: generalize the test for the other coordinates, to treat the (very) unlikely cases that this test doesn't work
	m,n = SB_3.shape
	coo = coo_matrix(SB_3)
	triples = []
	for (d,i,j) in zip(coo.data,coo.row,coo.col):
		if j < exterior:
			triples += [(d,i,j)]
		if j > exterior:
			triples += [(d,i,j-1)]
	data,row,col = TRANS(triples)
	return csc_matrix((data,(row,col)),dtype=int)

def MKSOLID(W,FW,EW):
	SB_2 = SBoundary2(EW,FW)
	FE = [list(SB_2[:,f].tocoo().row) for f in range(SB_2.shape[1])]
	triangleSet = boundaryTriangulation(W,FW,EW,FE)
	TW,FT = triangleIndices(triangleSet,W)
	B_3 = Boundary3(W,EW,FW)
	CF = [list(B_3[:,c].tocoo().row) for c in range(B_3.shape[1])]
	CT = [CAT([FT[f] for f in cell]) for cell in CF] 
	VIEW(EXPLODE(1.5,1.5,1.5)(AA(COMP([SOLIDIFY,STRUCT,MKPOLS]))(DISTL([ W, 
		[[TW[t] for t in cell] for cell in CT] ]))))
@}
%-------------------------------------------------------------------------------


\paragraph{Test example: ``A Gentle introduction". Part 1.}
%-------------------------------------------------------------------------------
@O test/py/boolean/test00a.py
@{""" A Gentle introduction to first steps of 3D Merge algorithm. Part 1. """
from larlib import *

V,[VV,EV,FV,CV] = larCuboids([1,1,1],True)
cubeGrid = Struct([(V,FV,EV)],"cubeGrid")
#cubeGrids = Struct(2*[cubeGrid,t(.5,.0,.5),r(0,0,PI/6)])
cubeGrids = Struct(2*[cubeGrid,t(.5,.5,.5),r(0,0,PI/6)])

V,FV,EV = struct2lar(cubeGrids)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,FV))))
W,FW,EW = partition(V,FV,EV)

WW = AA(LIST)(range(len(W)))
submodel = STRUCT(MKPOLS((W,EW)))
VIEW(larModelNumbering(1,1,1)(W,[WW,EW,FW],submodel,0.6)) 

SB_2 = SBoundary2(EW,FW)
SB_2.todense()
@}
%-------------------------------------------------------------------------------


\paragraph{Test example: ``A Gentle introduction". Part 2.}
%-------------------------------------------------------------------------------
@O test/py/boolean/test00b.py
@{""" A Gentle introduction to first steps of 3D Merge algorithm. Part 2. """
from larlib import *

V,[VV,EV,FV,CV] = larCuboids([1,1,1],True)
cubeGrid = Struct([(V,FV,EV)],"cubeGrid")
#cubeGrids = Struct(2*[cubeGrid,t(.5,.0,.5),r(0,0,PI/6)])
cubeGrids = Struct(2*[cubeGrid,t(.5,.5,.5),r(0,0,PI/6)])

V,FV,EV = struct2lar(cubeGrids)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((V,FV))))
W,FW,EW = partition(V,FV,EV)

WW = AA(LIST)(range(len(W)))
submodel = STRUCT(MKPOLS((W,EW)))
VIEW(larModelNumbering(1,1,1)(W,[WW,EW,FW],submodel,0.6)) 

SB_2 = SBoundary2(EW,FW)
SB_2.todense()

FE = [list(SB_2[:,f].tocoo().row) for f in range(SB_2.shape[1])]
triangleSet = boundaryTriangulation(W,FW,EW,FE)
TW,FT = triangleIndices(triangleSet,W)
VIEW(EXPLODE(1.2,1.2,1.2)(MKPOLS((W,TW))))

SB_3 = SBoundary3(W,EW,FW)
print SB_3.todense()

@}
%-------------------------------------------------------------------------------


\bibliographystyle{amsalpha}
\bibliography{boolean}

\end{document}
