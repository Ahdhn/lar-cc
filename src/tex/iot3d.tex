\documentclass[11pt,oneside]{article}	%use"amsart"insteadof"article"forAMSLaTeXformat
\usepackage{geometry}		%Seegeometry.pdftolearnthelayoutoptions.Therearelots.
\geometry{letterpaper}		%...ora4paperora5paperor...
%\geometry{landscape}		%Activateforforrotatedpagegeometry
%\usepackage[parfill]{parskip}		%Activatetobeginparagraphswithanemptylineratherthananindent
\usepackage{graphicx}				%Usepdf,png,jpg,orepsÃŸwithpdflatex;useepsinDVImode
								%TeXwillautomaticallyconverteps-->pdfinpdflatex		
\usepackage{amssymb}
\usepackage[colorlinks]{hyperref}

%----macros begin---------------------------------------------------------------
\usepackage{color}
\usepackage{amsthm}

\def\conv{\mbox{\textrm{conv}\,}}
\def\aff{\mbox{\textrm{aff}\,}}
\def\E{\mathbb{E}}
\def\R{\mathbb{R}}
\def\Z{\mathbb{Z}}
\def\tex{\TeX}
\def\latex{\LaTeX}
\def\v#1{{\bf #1}}
\def\p#1{{\bf #1}}
\def\T#1{{\bf #1}}

\def\vet#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}
\def\mat#1{{\left(\begin{array}{cccccccccccccccccccc}#1\end{array}\right)}}

\def\lin{\mbox{\rm lin}\,}
\def\aff{\mbox{\rm aff}\,}
\def\pos{\mbox{\rm pos}\,}
\def\cone{\mbox{\rm cone}\,}
\def\conv{\mbox{\rm conv}\,}
\newcommand{\homog}[0]{\mbox{\rm homog}\,}
\newcommand{\relint}[0]{\mbox{\rm relint}\,}

%----macros end-----------------------------------------------------------------

\title{Automatic generation of simplified buildings from 2D wire-frame
\footnote{This document is part of the \emph{Linear Algebraic Representation with CoChains} (LAR-CC) framework~\cite{cclar-proj:2013:00}. \today}
}
\author{Alberto Paoluzzi}
%\date{}							%Activatetodisplayagivendateornodate

\begin{document}
\maketitle
\nonstopmode

\begin{abstract}
In this module we develop a small library of functions to generate automatically simplified models of 3D buildings starting from 2D wire-frame drawings. The generated geometries will be exported to xGeoJson, a hierarchical data format extending GeoJson, the standard for geographical web maps, with assemblies and local rectangular coordinates. 
\end{abstract}

\tableofcontents

%===============================================================================
\section{Introduction}
%===============================================================================

A simplified 2D layout of building floors may be generated by using either a simple web UI providing only two or three interactive graphics primitives (rect and polyline, in particular) or by exporting the output of a drawing program to a standard 2D graphics data format, in particular to \texttt{SVG} (Simple Vector Graphics, the vector graphics standard for the web). This information will be used to automatically generate a simplified 3D model of the building and to export its geometry and topology to an external data format called \texttt{xGeoJson}, a customised extension of GeoJson an opensource standard for geographical information.


%===============================================================================
\section{Transformation filters}
%===============================================================================

%-------------------------------------------------------------------------------
\subsection{From \texttt{svg} to \texttt{lar}}
%-------------------------------------------------------------------------------

\paragraph{\texttt{SVG} primitives to lar}
Two \texttt{SVG} primitives are currently used to define the wire-frame layout of the building floors using either a drawing application or an interactive user interface within the browser:  \texttt{rect} (for the definition of rectangles) and \texttt{polyline} (for the definition of closed polylines). 

%-------------------------------------------------------------------------------
@D transform svg primitives to basic lar format
@{""" transform svg primitives to basic lar format """
def rects2polylines(rooms): 
	return [[[x,y],[x+dx,y],[x+dx,y+dy],[x,y+dy]] for x,y,dx,dy in rooms]
	
def polyline2lar(polylines):
	index,defaultValue = -1,-1
	Vdict,FV = dict(),[]
	for k,polyline in enumerate(polylines):
		cell = []
		for vert in polyline:
			key = vcode(vert)
			if Vdict.get(key,defaultValue) == defaultValue:
				index += 1
				Vdict[key] = index
				cell += [index]
			else: 
				cell += [Vdict[key]]
		FV += [cell]
	items = TRANS(Vdict.items())
	V = TRANS(sorted(zip(items[1],AA(eval)(items[0]))))[1]
	#FV = AA(sorted)(FV)
	return V,FV
@}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
\subsection{From \texttt{lar} to \texttt{struct}}
%-------------------------------------------------------------------------------


\paragraph{Mapping of a \texttt{lar} model to a list of \texttt{lar} structures}

%-------------------------------------------------------------------------------
@D transform a lar model to a list of lar structures
@{""" transform a lar model to a list of lar structures """
def lar2Structs(model):
   V,FV = model
   return [ Struct([[[V[v] for v in cell], [range(len(cell))]]]) for cell in FV]
@}
%-------------------------------------------------------------------------------


%-------------------------------------------------------------------------------
@D transform an absolute lar model to a relative lar structure
@{""" transform an absolute lar model to a relative lar structure """
def absModel2relStruct(larPolylineModel):
   V,E = larPolylineModel
   Vnew = (array(V) - V[0]).tolist()
   return Struct([ t(*V[0]), (Vnew,E) ])
@}
%-------------------------------------------------------------------------------



%-------------------------------------------------------------------------------
\subsection{Assembling \texttt{struct}ures}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\subsection{Exporting to \texttt{xGeoJson}}
%-------------------------------------------------------------------------------

\paragraph{print a lar structure to a geoJson file}

%-------------------------------------------------------------------------------
@D print a lar structure to a geoJson file
@{""" print a lar structure to a geoJson file """
def printStruct2GeoJson(struct):
   dim = checkStruct(struct.body)
   print "\n dim =",dim
   CTM, stack = scipy.identity(dim+1), []
   print "\n CTM, stack =",CTM, stack
   scene = printTraversal(CTM, stack, struct, [], 0) 
   return scene
@}
%-------------------------------------------------------------------------------

\paragraph{Traverse a structure to print a geoJson file}

%-------------------------------------------------------------------------------
@D Traverse a structure to print a geoJson file
@{""" Traverse a structure to print a geoJson file """
def printTraversal(CTM, stack, obj, scene=[], level=0):
   tabs = (4*level)*" "
   for i in range(len(obj)):
      if isinstance(obj[i],Model): 
         i,verts,cells = obj[i]
         if obj[i].__name__() == None:
            name = id(obj[i])
         else: 
            name = obj[i].__name__()
         print tabs, "i =",i
         print tabs, "name =",name
         print tabs, "verts =",AA(eval)(AA(vcode)(verts))
         print tabs, "cells =",cells
         scene += [larApply(CTM)(obj[i])]
      elif (isinstance(obj[i],tuple) or isinstance(obj[i],list)) and len(obj[i])==2:
         verts,cells = obj[i]
         name = id(obj[i])
         print tabs, "i =",i
         print tabs, "name =",name
         print tabs, "verts =",AA(eval)(AA(vcode)(verts))
         print tabs, "cells =",cells
         scene += [larApply(CTM)(obj[i])]
      elif isinstance(obj[i],Mat): 
         print tabs, "tVector =", obj[i].T[-1].tolist()
         CTM = scipy.dot(CTM, obj[i])
      elif isinstance(obj[i], Struct):
         if obj[i].__name__() == None:
            name = id(obj[i])
         else: 
            name = obj[i].__name__()
         print tabs, "i =",i
         print tabs, "name =",name
         stack.append(CTM) 
         level += 1
         printTraversal(CTM, stack, obj[i], scene, level)
         level -= 1
         CTM = stack.pop()
   return scene
@}
%-------------------------------------------------------------------------------


%===============================================================================
\section{\texttt{Iot3D} Exporting}
%===============================================================================

%------------------------------------------------------------------
@O lib/py/iot3d.py
@{"""Module with automatic generation of simplified 3D buildings"""
import sys; sys.path.insert(0, 'lib/py/')
from architectural import *
@< transform svg primitives to basic lar format @>
@< transform a lar model to a list of lar structures @>
@< transform an absolute lar model to a relative lar structure @>
@< print a lar structure to a geoJson file @>
@< Traverse a structure to print a geoJson file @>
@}
%------------------------------------------------------------------

%===============================================================================
\section{Examples}
%===============================================================================


%===============================================================================
\appendix
%===============================================================================



\bibliographystyle{amsalpha}
\bibliography{iot3d}

\end{document}
